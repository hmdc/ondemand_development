var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/clipboard/dist/clipboard.js
var require_clipboard = __commonJS({
  "node_modules/clipboard/dist/clipboard.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["ClipboardJS"] = factory();
      else
        root["ClipboardJS"] = factory();
    })(exports, function() {
      return function() {
        var __webpack_modules__ = {
          686: function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.d(__webpack_exports__, {
              "default": function() {
                return clipboard;
              }
            });
            var tiny_emitter = __webpack_require__2(279);
            var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
            var listen = __webpack_require__2(370);
            var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
            var src_select = __webpack_require__2(817);
            var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
            ;
            function command(type) {
              try {
                return document.execCommand(type);
              } catch (err) {
                return false;
              }
            }
            ;
            var ClipboardActionCut = function ClipboardActionCut2(target) {
              var selectedText = select_default()(target);
              command("cut");
              return selectedText;
            };
            var actions_cut = ClipboardActionCut;
            ;
            function createFakeElement(value) {
              var isRTL = document.documentElement.getAttribute("dir") === "rtl";
              var fakeElement = document.createElement("textarea");
              fakeElement.style.fontSize = "12pt";
              fakeElement.style.border = "0";
              fakeElement.style.padding = "0";
              fakeElement.style.margin = "0";
              fakeElement.style.position = "absolute";
              fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
              var yPosition = window.pageYOffset || document.documentElement.scrollTop;
              fakeElement.style.top = "".concat(yPosition, "px");
              fakeElement.setAttribute("readonly", "");
              fakeElement.value = value;
              return fakeElement;
            }
            ;
            var fakeCopyAction = function fakeCopyAction2(value, options) {
              var fakeElement = createFakeElement(value);
              options.container.appendChild(fakeElement);
              var selectedText = select_default()(fakeElement);
              command("copy");
              fakeElement.remove();
              return selectedText;
            };
            var ClipboardActionCopy = function ClipboardActionCopy2(target) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                container: document.body
              };
              var selectedText = "";
              if (typeof target === "string") {
                selectedText = fakeCopyAction(target, options);
              } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                selectedText = fakeCopyAction(target.value, options);
              } else {
                selectedText = select_default()(target);
                command("copy");
              }
              return selectedText;
            };
            var actions_copy = ClipboardActionCopy;
            ;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var ClipboardActionDefault = function ClipboardActionDefault2() {
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
              if (action !== "copy" && action !== "cut") {
                throw new Error('Invalid "action" value, use either "copy" or "cut"');
              }
              if (target !== void 0) {
                if (target && _typeof(target) === "object" && target.nodeType === 1) {
                  if (action === "copy" && target.hasAttribute("disabled")) {
                    throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                  }
                  if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                    throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                  }
                } else {
                  throw new Error('Invalid "target" value, use a valid Element');
                }
              }
              if (text) {
                return actions_copy(text, {
                  container
                });
              }
              if (target) {
                return action === "cut" ? actions_cut(target) : actions_copy(target, {
                  container
                });
              }
            };
            var actions_default = ClipboardActionDefault;
            ;
            function clipboard_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                clipboard_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                clipboard_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return clipboard_typeof(obj);
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o2, p2) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
                o3.__proto__ = p3;
                return o3;
              };
              return _setPrototypeOf(o2, p2);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                }));
                return true;
              } catch (e2) {
                return false;
              }
            }
            function _getPrototypeOf(o2) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
                return o3.__proto__ || Object.getPrototypeOf(o3);
              };
              return _getPrototypeOf(o2);
            }
            function getAttributeValue(suffix, element) {
              var attribute = "data-clipboard-".concat(suffix);
              if (!element.hasAttribute(attribute)) {
                return;
              }
              return element.getAttribute(attribute);
            }
            var Clipboard = /* @__PURE__ */ function(_Emitter) {
              _inherits(Clipboard2, _Emitter);
              var _super = _createSuper(Clipboard2);
              function Clipboard2(trigger, options) {
                var _this;
                _classCallCheck(this, Clipboard2);
                _this = _super.call(this);
                _this.resolveOptions(options);
                _this.listenClick(trigger);
                return _this;
              }
              _createClass(Clipboard2, [{
                key: "resolveOptions",
                value: function resolveOptions() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                  this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                  this.text = typeof options.text === "function" ? options.text : this.defaultText;
                  this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                }
              }, {
                key: "listenClick",
                value: function listenClick(trigger) {
                  var _this2 = this;
                  this.listener = listen_default()(trigger, "click", function(e2) {
                    return _this2.onClick(e2);
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(e2) {
                  var trigger = e2.delegateTarget || e2.currentTarget;
                  var action = this.action(trigger) || "copy";
                  var text = actions_default({
                    action,
                    container: this.container,
                    target: this.target(trigger),
                    text: this.text(trigger)
                  });
                  this.emit(text ? "success" : "error", {
                    action,
                    text,
                    trigger,
                    clearSelection: function clearSelection() {
                      if (trigger) {
                        trigger.focus();
                      }
                      window.getSelection().removeAllRanges();
                    }
                  });
                }
              }, {
                key: "defaultAction",
                value: function defaultAction(trigger) {
                  return getAttributeValue("action", trigger);
                }
              }, {
                key: "defaultTarget",
                value: function defaultTarget(trigger) {
                  var selector = getAttributeValue("target", trigger);
                  if (selector) {
                    return document.querySelector(selector);
                  }
                }
              }, {
                key: "defaultText",
                value: function defaultText(trigger) {
                  return getAttributeValue("text", trigger);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this.listener.destroy();
                }
              }], [{
                key: "copy",
                value: function copy(target) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    container: document.body
                  };
                  return actions_copy(target, options);
                }
              }, {
                key: "cut",
                value: function cut(target) {
                  return actions_cut(target);
                }
              }, {
                key: "isSupported",
                value: function isSupported() {
                  var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                  var actions = typeof action === "string" ? [action] : action;
                  var support = !!document.queryCommandSupported;
                  actions.forEach(function(action2) {
                    support = support && !!document.queryCommandSupported(action2);
                  });
                  return support;
                }
              }]);
              return Clipboard2;
            }(tiny_emitter_default());
            var clipboard = Clipboard;
          },
          828: function(module2) {
            var DOCUMENT_NODE_TYPE = 9;
            if (typeof Element !== "undefined" && !Element.prototype.matches) {
              var proto = Element.prototype;
              proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
            }
            function closest(element, selector) {
              while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                if (typeof element.matches === "function" && element.matches(selector)) {
                  return element;
                }
                element = element.parentNode;
              }
            }
            module2.exports = closest;
          },
          438: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var closest = __webpack_require__2(828);
            function _delegate(element, selector, type, callback, useCapture) {
              var listenerFn = listener.apply(this, arguments);
              element.addEventListener(type, listenerFn, useCapture);
              return {
                destroy: function() {
                  element.removeEventListener(type, listenerFn, useCapture);
                }
              };
            }
            function delegate(elements, selector, type, callback, useCapture) {
              if (typeof elements.addEventListener === "function") {
                return _delegate.apply(null, arguments);
              }
              if (typeof type === "function") {
                return _delegate.bind(null, document).apply(null, arguments);
              }
              if (typeof elements === "string") {
                elements = document.querySelectorAll(elements);
              }
              return Array.prototype.map.call(elements, function(element) {
                return _delegate(element, selector, type, callback, useCapture);
              });
            }
            function listener(element, selector, type, callback) {
              return function(e2) {
                e2.delegateTarget = closest(e2.target, selector);
                if (e2.delegateTarget) {
                  callback.call(element, e2);
                }
              };
            }
            module2.exports = delegate;
          },
          879: function(__unused_webpack_module, exports2) {
            exports2.node = function(value) {
              return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
            };
            exports2.nodeList = function(value) {
              var type = Object.prototype.toString.call(value);
              return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
            };
            exports2.string = function(value) {
              return typeof value === "string" || value instanceof String;
            };
            exports2.fn = function(value) {
              var type = Object.prototype.toString.call(value);
              return type === "[object Function]";
            };
          },
          370: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var is = __webpack_require__2(879);
            var delegate = __webpack_require__2(438);
            function listen(target, type, callback) {
              if (!target && !type && !callback) {
                throw new Error("Missing required arguments");
              }
              if (!is.string(type)) {
                throw new TypeError("Second argument must be a String");
              }
              if (!is.fn(callback)) {
                throw new TypeError("Third argument must be a Function");
              }
              if (is.node(target)) {
                return listenNode(target, type, callback);
              } else if (is.nodeList(target)) {
                return listenNodeList(target, type, callback);
              } else if (is.string(target)) {
                return listenSelector(target, type, callback);
              } else {
                throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
              }
            }
            function listenNode(node, type, callback) {
              node.addEventListener(type, callback);
              return {
                destroy: function() {
                  node.removeEventListener(type, callback);
                }
              };
            }
            function listenNodeList(nodeList, type, callback) {
              Array.prototype.forEach.call(nodeList, function(node) {
                node.addEventListener(type, callback);
              });
              return {
                destroy: function() {
                  Array.prototype.forEach.call(nodeList, function(node) {
                    node.removeEventListener(type, callback);
                  });
                }
              };
            }
            function listenSelector(selector, type, callback) {
              return delegate(document.body, selector, type, callback);
            }
            module2.exports = listen;
          },
          817: function(module2) {
            function select(element) {
              var selectedText;
              if (element.nodeName === "SELECT") {
                element.focus();
                selectedText = element.value;
              } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                var isReadOnly = element.hasAttribute("readonly");
                if (!isReadOnly) {
                  element.setAttribute("readonly", "");
                }
                element.select();
                element.setSelectionRange(0, element.value.length);
                if (!isReadOnly) {
                  element.removeAttribute("readonly");
                }
                selectedText = element.value;
              } else {
                if (element.hasAttribute("contenteditable")) {
                  element.focus();
                }
                var selection = window.getSelection();
                var range = document.createRange();
                range.selectNodeContents(element);
                selection.removeAllRanges();
                selection.addRange(range);
                selectedText = selection.toString();
              }
              return selectedText;
            }
            module2.exports = select;
          },
          279: function(module2) {
            function E2() {
            }
            E2.prototype = {
              on: function(name, callback, ctx) {
                var e2 = this.e || (this.e = {});
                (e2[name] || (e2[name] = [])).push({
                  fn: callback,
                  ctx
                });
                return this;
              },
              once: function(name, callback, ctx) {
                var self2 = this;
                function listener() {
                  self2.off(name, listener);
                  callback.apply(ctx, arguments);
                }
                ;
                listener._ = callback;
                return this.on(name, listener, ctx);
              },
              emit: function(name) {
                var data = [].slice.call(arguments, 1);
                var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                var i2 = 0;
                var len = evtArr.length;
                for (i2; i2 < len; i2++) {
                  evtArr[i2].fn.apply(evtArr[i2].ctx, data);
                }
                return this;
              },
              off: function(name, callback) {
                var e2 = this.e || (this.e = {});
                var evts = e2[name];
                var liveEvents = [];
                if (evts && callback) {
                  for (var i2 = 0, len = evts.length; i2 < len; i2++) {
                    if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
                      liveEvents.push(evts[i2]);
                  }
                }
                liveEvents.length ? e2[name] = liveEvents : delete e2[name];
                return this;
              }
            };
            module2.exports = E2;
            module2.exports.TinyEmitter = E2;
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          if (__webpack_module_cache__[moduleId]) {
            return __webpack_module_cache__[moduleId].exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        !function() {
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function() {
              return module2["default"];
            } : function() {
              return module2;
            };
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        }();
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        return __webpack_require__(686);
      }().default;
    });
  }
});

// node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.extend = extend;
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.createFrame = createFrame;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g;
    var possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape2[chr];
    }
    function extend(obj) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        for (var key in arguments[i2]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i2], key)) {
            obj[key] = arguments[i2][key];
          }
        }
      }
      return obj;
    }
    var toString = Object.prototype.toString;
    exports.toString = toString;
    var isFunction = function isFunction2(value) {
      return typeof value === "function";
    };
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function(value) {
        return typeof value === "function" && toString.call(value) === "[object Function]";
      };
    }
    exports.isFunction = isFunction;
    var isArray = Array.isArray || function(value) {
      return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
    };
    exports.isArray = isArray;
    function indexOf(array, value) {
      for (var i2 = 0, len = array.length; i2 < len; i2++) {
        if (array[i2] === value) {
          return i2;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== "string") {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return "";
        } else if (!string) {
          return string + "";
        }
        string = "" + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
    function Exception(message, node) {
      var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
      if (loc) {
        line = loc.start.line;
        endLineNumber = loc.end.line;
        column = loc.start.column;
        endColumn = loc.end.column;
        message += " - " + line + ":" + column;
      }
      var tmp = Error.prototype.constructor.call(this, message);
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
      try {
        if (loc) {
          this.lineNumber = line;
          this.endLineNumber = endLineNumber;
          if (Object.defineProperty) {
            Object.defineProperty(this, "column", {
              value: column,
              enumerable: true
            });
            Object.defineProperty(this, "endColumn", {
              value: endColumn,
              enumerable: true
            });
          } else {
            this.column = column;
            this.endColumn = endColumn;
          }
        }
      } catch (nop) {
      }
    }
    Exception.prototype = new Error();
    exports["default"] = Exception;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse, fn = options.fn;
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (_utils.isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
            options = { data };
          }
          return fn(context, options);
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("each", function(context, options) {
        if (!options) {
          throw new _exception2["default"]("Must pass iterator to #each");
        }
        var fn = options.fn, inverse = options.inverse, i2 = 0, ret = "", data = void 0, contextPath = void 0;
        if (options.data && options.ids) {
          contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        if (options.data) {
          data = _utils.createFrame(options.data);
        }
        function execIteration(field, index, last) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last;
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
          ret = ret + fn(context[field], {
            data,
            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
        if (context && typeof context === "object") {
          if (_utils.isArray(context)) {
            for (var j2 = context.length; i2 < j2; i2++) {
              if (i2 in context) {
                execIteration(i2, i2, i2 === context.length - 1);
              }
            }
          } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
            var newContext = [];
            var iterator = context[Symbol.iterator]();
            for (var it = iterator.next(); !it.done; it = iterator.next()) {
              newContext.push(it.value);
            }
            context = newContext;
            for (var j2 = context.length; i2 < j2; i2++) {
              execIteration(i2, i2, i2 === context.length - 1);
            }
          } else {
            (function() {
              var priorKey = void 0;
              Object.keys(context).forEach(function(key) {
                if (priorKey !== void 0) {
                  execIteration(priorKey, i2 - 1);
                }
                priorKey = key;
                i2++;
              });
              if (priorKey !== void 0) {
                execIteration(priorKey, i2 - 1, true);
              }
            })();
          }
        }
        if (i2 === 0) {
          ret = inverse(this);
        }
        return ret;
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("helperMissing", function() {
        if (arguments.length === 1) {
          return void 0;
        } else {
          throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("if", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#if requires exactly one argument");
        }
        if (_utils.isFunction(conditional)) {
          conditional = conditional.call(this);
        }
        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
      instance.registerHelper("unless", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#unless requires exactly one argument");
        }
        return instance.helpers["if"].call(this, conditional, {
          fn: options.inverse,
          inverse: options.fn,
          hash: options.hash
        });
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("log", function() {
        var args = [void 0], options = arguments[arguments.length - 1];
        for (var i2 = 0; i2 < arguments.length - 1; i2++) {
          args.push(arguments[i2]);
        }
        var level = 1;
        if (options.hash.level != null) {
          level = options.hash.level;
        } else if (options.data && options.data.level != null) {
          level = options.data.level;
        }
        args[0] = level;
        instance.log.apply(instance, args);
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("lookup", function(obj, field, options) {
        if (!obj) {
          return obj;
        }
        return options.lookupProperty(obj, field);
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("with", function(context, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#with requires exactly one argument");
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        var fn = options.fn;
        if (!_utils.isEmpty(context)) {
          var data = options.data;
          if (options.data && options.ids) {
            data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
          }
          return fn(context, {
            data,
            blockParams: _utils.blockParams([context], [data && data.contextPath])
          });
        } else {
          return options.inverse(this);
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultHelpers = registerDefaultHelpers;
    exports.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = require_block_helper_missing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = require_each();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = require_helper_missing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = require_log();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = require_lookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2["default"](instance);
      _helpersEach2["default"](instance);
      _helpersHelperMissing2["default"](instance);
      _helpersIf2["default"](instance);
      _helpersLog2["default"](instance);
      _helpersLookup2["default"](instance);
      _helpersWith2["default"](instance);
    }
    function moveHelperToHooks(instance, helperName, keepHelper) {
      if (instance.helpers[helperName]) {
        instance.hooks[helperName] = instance.helpers[helperName];
        if (!keepHelper) {
          delete instance.helpers[helperName];
        }
      }
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    exports["default"] = function(instance) {
      instance.registerDecorator("inline", function(fn, props, container, options) {
        var ret = fn;
        if (!props.partials) {
          props.partials = {};
          ret = function(context, options2) {
            var original = container.partials;
            container.partials = _utils.extend({}, original, props.partials);
            var ret2 = fn(context, options2);
            container.partials = original;
            return ret2;
          };
        }
        props.partials[options.args[0]] = options.fn;
        return ret;
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = require_inline();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2["default"](instance);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var logger = {
      methodMap: ["debug", "info", "warn", "error"],
      level: "info",
      lookupLevel: function lookupLevel(level) {
        if (typeof level === "string") {
          var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
          if (levelMap >= 0) {
            level = levelMap;
          } else {
            level = parseInt(level, 10);
          }
        }
        return level;
      },
      log: function log(level) {
        level = logger.lookupLevel(level);
        if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
          var method = logger.methodMap[level];
          if (!console[method]) {
            method = "log";
          }
          for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            message[_key - 1] = arguments[_key];
          }
          console[method].apply(console, message);
        }
      }
    };
    exports["default"] = logger;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createNewLookupObject = createNewLookupObject;
    var _utils = require_utils();
    function createNewLookupObject() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createProtoAccessControl = createProtoAccessControl;
    exports.resultIsAllowed = resultIsAllowed;
    exports.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _createNewLookupObject = require_create_new_lookup_object();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var loggedProperties = /* @__PURE__ */ Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result, protoAccessControl, propertyName) {
      if (typeof result === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = require_helpers();
    var _decorators = require_decorators();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = require_proto_access();
    var VERSION = "4.7.8";
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 8;
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers, partials, decorators) {
      this.helpers = helpers || {};
      this.partials = partials || {};
      this.decorators = decorators || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log = _logger2["default"].log;
    exports.log = log;
    exports.createFrame = _utils.createFrame;
    exports.logger = _logger2["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function SafeString(string) {
      this.string = string;
    }
    SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
      return "" + this.string;
    };
    exports["default"] = SafeString;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.wrapHelper = wrapHelper;
    function wrapHelper(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = require_utils();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = require_base();
    var _helpers = require_helpers();
    var _internalWrapHelper = require_wrapHelper();
    var _internalProtoAccess = require_proto_access();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, extendedOptions);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split("\n");
            for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              if (!lines[i2] && i2 + 1 === l2) {
                break;
              }
              lines[i2] = options.indent + lines[i2];
            }
            result = lines.join("\n");
          }
          return result;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result = parent[propertyName];
          if (result == null) {
            return result;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result;
          }
          if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
            return result;
          }
          return void 0;
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i2 = 0; i2 < len; i2++) {
            var result = depths[i2] && container.lookupProperty(depths[i2], name);
            if (result != null) {
              return depths[i2][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i2) {
          var ret2 = templateSpec[i2];
          ret2.decorator = templateSpec[i2 + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i2, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i2], fn = this.fn(i2);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i2, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i2] = wrapProgram(this, i2, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i2, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i2, templateSpec[i2], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i2, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i2;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === "@partial-block") {
          partial = options.data["partial-block"];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial === void 0 && partialBlock) {
        partial = partialBlock;
      }
      if (partial === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop() {
      return "";
    }
    function initData(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(Handlebars4) {
      (function() {
        if (typeof globalThis === "object")
          return;
        Object.prototype.__defineGetter__("__magic__", function() {
          return this;
        });
        __magic__.globalThis = __magic__;
        delete Object.prototype.__magic__;
      })();
      var $Handlebars = globalThis.Handlebars;
      Handlebars4.noConflict = function() {
        if (globalThis.Handlebars === Handlebars4) {
          globalThis.Handlebars = $Handlebars;
        }
        return Handlebars4;
      };
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _handlebarsBase = require_base();
    var base = _interopRequireWildcard(_handlebarsBase);
    var _handlebarsSafeString = require_safe_string();
    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    var _handlebarsException = require_exception();
    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    var _handlebarsUtils = require_utils();
    var Utils = _interopRequireWildcard(_handlebarsUtils);
    var _handlebarsRuntime = require_runtime();
    var runtime = _interopRequireWildcard(_handlebarsRuntime);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    function create() {
      var hb = new base.HandlebarsEnvironment();
      Utils.extend(hb, base);
      hb.SafeString = _handlebarsSafeString2["default"];
      hb.Exception = _handlebarsException2["default"];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
      hb.VM = runtime;
      hb.template = function(spec) {
        return runtime.template(spec, hb);
      };
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst["default"] = inst;
    exports["default"] = inst;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var AST = {
      helpers: {
        helperExpression: function helperExpression(node) {
          return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
        },
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    exports["default"] = AST;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var handlebars = function() {
      var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              return $$[$0 - 1];
              break;
            case 2:
              this.$ = yy.prepareProgram($$[$0]);
              break;
            case 3:
              this.$ = $$[$0];
              break;
            case 4:
              this.$ = $$[$0];
              break;
            case 5:
              this.$ = $$[$0];
              break;
            case 6:
              this.$ = $$[$0];
              break;
            case 7:
              this.$ = $$[$0];
              break;
            case 8:
              this.$ = $$[$0];
              break;
            case 9:
              this.$ = {
                type: "CommentStatement",
                value: yy.stripComment($$[$0]),
                strip: yy.stripFlags($$[$0], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 10:
              this.$ = {
                type: "ContentStatement",
                original: $$[$0],
                value: $$[$0],
                loc: yy.locInfo(this._$)
              };
              break;
            case 11:
              this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 12:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
              break;
            case 13:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
              break;
            case 14:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
              break;
            case 15:
              this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 16:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 17:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 18:
              this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
              break;
            case 19:
              var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
              program.chained = true;
              this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
              break;
            case 20:
              this.$ = $$[$0];
              break;
            case 21:
              this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
              break;
            case 22:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 23:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 24:
              this.$ = {
                type: "PartialStatement",
                name: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                indent: "",
                strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 25:
              this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 26:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
              break;
            case 27:
              this.$ = $$[$0];
              break;
            case 28:
              this.$ = $$[$0];
              break;
            case 29:
              this.$ = {
                type: "SubExpression",
                path: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                loc: yy.locInfo(this._$)
              };
              break;
            case 30:
              this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 31:
              this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 32:
              this.$ = yy.id($$[$0 - 1]);
              break;
            case 33:
              this.$ = $$[$0];
              break;
            case 34:
              this.$ = $$[$0];
              break;
            case 35:
              this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 36:
              this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
              break;
            case 37:
              this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
              break;
            case 38:
              this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
              break;
            case 39:
              this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
              break;
            case 40:
              this.$ = $$[$0];
              break;
            case 41:
              this.$ = $$[$0];
              break;
            case 42:
              this.$ = yy.preparePath(true, $$[$0], this._$);
              break;
            case 43:
              this.$ = yy.preparePath(false, $$[$0], this._$);
              break;
            case 44:
              $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
              this.$ = $$[$0 - 2];
              break;
            case 45:
              this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
              break;
            case 46:
              this.$ = [];
              break;
            case 47:
              $$[$0 - 1].push($$[$0]);
              break;
            case 48:
              this.$ = [];
              break;
            case 49:
              $$[$0 - 1].push($$[$0]);
              break;
            case 50:
              this.$ = [];
              break;
            case 51:
              $$[$0 - 1].push($$[$0]);
              break;
            case 58:
              this.$ = [];
              break;
            case 59:
              $$[$0 - 1].push($$[$0]);
              break;
            case 64:
              this.$ = [];
              break;
            case 65:
              $$[$0 - 1].push($$[$0]);
              break;
            case 70:
              this.$ = [];
              break;
            case 71:
              $$[$0 - 1].push($$[$0]);
              break;
            case 78:
              this.$ = [];
              break;
            case 79:
              $$[$0 - 1].push($$[$0]);
              break;
            case 82:
              this.$ = [];
              break;
            case 83:
              $$[$0 - 1].push($$[$0]);
              break;
            case 86:
              this.$ = [];
              break;
            case 87:
              $$[$0 - 1].push($$[$0]);
              break;
            case 90:
              this.$ = [];
              break;
            case 91:
              $$[$0 - 1].push($$[$0]);
              break;
            case 94:
              this.$ = [];
              break;
            case 95:
              $$[$0 - 1].push($$[$0]);
              break;
            case 98:
              this.$ = [$$[$0]];
              break;
            case 99:
              $$[$0 - 1].push($$[$0]);
              break;
            case 100:
              this.$ = [$$[$0]];
              break;
            case 101:
              $$[$0 - 1].push($$[$0]);
              break;
          }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self2 = this, stack = [0], vstack = [null], lstack = [], table2 = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          this.yy.parser = this;
          if (typeof this.lexer.yylloc == "undefined")
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          var ranges = this.lexer.options && this.lexer.options.ranges;
          if (typeof this.yy.parseError === "function")
            this.parseError = this.yy.parseError;
          function popStack(n2) {
            stack.length = stack.length - 2 * n2;
            vstack.length = vstack.length - n2;
            lstack.length = lstack.length - n2;
          }
          function lex() {
            var token;
            token = self2.lexer.lex() || 1;
            if (typeof token !== "number") {
              token = self2.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a2, r2, yyval = {}, p2, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
              }
              action = table2[state] && table2[state][symbol];
            }
            if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                expected = [];
                for (p2 in table2[state])
                  if (this.terminals_[p2] && p2 > 2) {
                    expected.push("'" + this.terminals_[p2] + "'");
                  }
                if (this.lexer.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
              }
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                    recovering--;
                } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                }
                r2 = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r2 !== "undefined") {
                  return r2;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table2[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      var lexer = function() {
        var lexer2 = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          setInput: function setInput(input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = ["INITIAL"];
            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
            if (this.options.ranges)
              this.yylloc.range = [0, 0];
            this.offset = 0;
            return this;
          },
          input: function input() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges)
              this.yylloc.range[1]++;
            this._input = this._input.slice(1);
            return ch;
          },
          unput: function unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1)
              this.yylineno -= lines.length - 1;
            var r2 = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
            }
            return this;
          },
          more: function more() {
            this._more = true;
            return this;
          },
          less: function less(n2) {
            this.unput(this.match.slice(n2));
          },
          pastInput: function pastInput() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          upcomingInput: function upcomingInput() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          showPosition: function showPosition() {
            var pre = this.pastInput();
            var c2 = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c2 + "^";
          },
          next: function next() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input)
              this.done = true;
            var token, match, tempMatch, index, col, lines;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i2 = 0; i2 < rules.length; i2++) {
              tempMatch = this._input.match(this.rules[rules[i2]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i2;
                if (!this.options.flex)
                  break;
              }
            }
            if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines)
                this.yylineno += lines.length;
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input)
                this.done = false;
              if (token)
                return token;
              else
                return;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
            }
          },
          lex: function lex() {
            var r2 = this.next();
            if (typeof r2 !== "undefined") {
              return r2;
            } else {
              return this.lex();
            }
          },
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          popState: function popState() {
            return this.conditionStack.pop();
          },
          _currentRules: function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          },
          topState: function topState() {
            return this.conditionStack[this.conditionStack.length - 2];
          },
          pushState: function begin(condition) {
            this.begin(condition);
          }
        };
        lexer2.options = {};
        lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          function strip(start, end) {
            return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
          }
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
            case 0:
              if (yy_.yytext.slice(-2) === "\\\\") {
                strip(0, 1);
                this.begin("mu");
              } else if (yy_.yytext.slice(-1) === "\\") {
                strip(0, 1);
                this.begin("emu");
              } else {
                this.begin("mu");
              }
              if (yy_.yytext)
                return 15;
              break;
            case 1:
              return 15;
              break;
            case 2:
              this.popState();
              return 15;
              break;
            case 3:
              this.begin("raw");
              return 15;
              break;
            case 4:
              this.popState();
              if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                return 15;
              } else {
                strip(5, 9);
                return "END_RAW_BLOCK";
              }
              break;
            case 5:
              return 15;
              break;
            case 6:
              this.popState();
              return 14;
              break;
            case 7:
              return 65;
              break;
            case 8:
              return 68;
              break;
            case 9:
              return 19;
              break;
            case 10:
              this.popState();
              this.begin("raw");
              return 23;
              break;
            case 11:
              return 55;
              break;
            case 12:
              return 60;
              break;
            case 13:
              return 29;
              break;
            case 14:
              return 47;
              break;
            case 15:
              this.popState();
              return 44;
              break;
            case 16:
              this.popState();
              return 44;
              break;
            case 17:
              return 34;
              break;
            case 18:
              return 39;
              break;
            case 19:
              return 51;
              break;
            case 20:
              return 48;
              break;
            case 21:
              this.unput(yy_.yytext);
              this.popState();
              this.begin("com");
              break;
            case 22:
              this.popState();
              return 14;
              break;
            case 23:
              return 48;
              break;
            case 24:
              return 73;
              break;
            case 25:
              return 72;
              break;
            case 26:
              return 72;
              break;
            case 27:
              return 87;
              break;
            case 28:
              break;
            case 29:
              this.popState();
              return 54;
              break;
            case 30:
              this.popState();
              return 33;
              break;
            case 31:
              yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
              return 80;
              break;
            case 32:
              yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
              return 80;
              break;
            case 33:
              return 85;
              break;
            case 34:
              return 82;
              break;
            case 35:
              return 82;
              break;
            case 36:
              return 83;
              break;
            case 37:
              return 84;
              break;
            case 38:
              return 81;
              break;
            case 39:
              return 75;
              break;
            case 40:
              return 77;
              break;
            case 41:
              return 72;
              break;
            case 42:
              yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
              return 72;
              break;
            case 43:
              return "INVALID";
              break;
            case 44:
              return 5;
              break;
          }
        };
        lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer2;
      }();
      parser.lexer = lexer;
      function Parser() {
        this.yy = {};
      }
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser();
    }();
    exports["default"] = handlebars;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function Visitor() {
      this.parents = [];
    }
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
      acceptKey: function acceptKey(node, name) {
        var value = this.accept(node[name]);
        if (this.mutating) {
          if (value && !Visitor.prototype[value.type]) {
            throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
          }
          node[name] = value;
        }
      },
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
        if (!node[name]) {
          throw new _exception2["default"](node.type + " requires " + name);
        }
      },
      acceptArray: function acceptArray(array) {
        for (var i2 = 0, l2 = array.length; i2 < l2; i2++) {
          this.acceptKey(array, i2);
          if (!array[i2]) {
            array.splice(i2, 1);
            i2--;
            l2--;
          }
        }
      },
      accept: function accept(object) {
        if (!object) {
          return;
        }
        if (!this[object.type]) {
          throw new _exception2["default"]("Unknown type: " + object.type, object);
        }
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object;
        var ret = this[object.type](object);
        this.current = this.parents.shift();
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object;
        }
      },
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
      MustacheStatement: visitSubExpression,
      Decorator: visitSubExpression,
      BlockStatement: visitBlock,
      DecoratorBlock: visitBlock,
      PartialStatement: visitPartial,
      PartialBlockStatement: function PartialBlockStatement(partial) {
        visitPartial.call(this, partial);
        this.acceptKey(partial, "program");
      },
      ContentStatement: function ContentStatement() {
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: visitSubExpression,
      PathExpression: function PathExpression() {
      },
      StringLiteral: function StringLiteral() {
      },
      NumberLiteral: function NumberLiteral() {
      },
      BooleanLiteral: function BooleanLiteral() {
      },
      UndefinedLiteral: function UndefinedLiteral() {
      },
      NullLiteral: function NullLiteral() {
      },
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, "value");
      }
    };
    function visitSubExpression(mustache) {
      this.acceptRequired(mustache, "path");
      this.acceptArray(mustache.params);
      this.acceptKey(mustache, "hash");
    }
    function visitBlock(block) {
      visitSubExpression.call(this, block);
      this.acceptKey(block, "program");
      this.acceptKey(block, "inverse");
    }
    function visitPartial(partial) {
      this.acceptRequired(partial, "name");
      this.acceptArray(partial.params);
      this.acceptKey(partial, "hash");
    }
    exports["default"] = Visitor;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _visitor = require_visitor();
    var _visitor2 = _interopRequireDefault(_visitor);
    function WhitespaceControl() {
      var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
      this.options = options;
    }
    WhitespaceControl.prototype = new _visitor2["default"]();
    WhitespaceControl.prototype.Program = function(program) {
      var doStandalone = !this.options.ignoreStandalone;
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
      var body = program.body;
      for (var i2 = 0, l2 = body.length; i2 < l2; i2++) {
        var current = body[i2], strip = this.accept(current);
        if (!strip) {
          continue;
        }
        var _isPrevWhitespace = isPrevWhitespace(body, i2, isRoot), _isNextWhitespace = isNextWhitespace(body, i2, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
        if (strip.close) {
          omitRight(body, i2, true);
        }
        if (strip.open) {
          omitLeft(body, i2, true);
        }
        if (doStandalone && inlineStandalone) {
          omitRight(body, i2);
          if (omitLeft(body, i2)) {
            if (current.type === "PartialStatement") {
              current.indent = /([ \t]+$)/.exec(body[i2 - 1].original)[1];
            }
          }
        }
        if (doStandalone && openStandalone) {
          omitRight((current.program || current.inverse).body);
          omitLeft(body, i2);
        }
        if (doStandalone && closeStandalone) {
          omitRight(body, i2);
          omitLeft((current.inverse || current.program).body);
        }
      }
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
      this.accept(block.program);
      this.accept(block.inverse);
      var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
      if (inverse) {
        var inverseStrip = block.inverseStrip;
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
        if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
      return strip;
    };
    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
      return mustache.strip;
    };
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    function isPrevWhitespace(body, i2, isRoot) {
      if (i2 === void 0) {
        i2 = body.length;
      }
      var prev = body[i2 - 1], sibling = body[i2 - 2];
      if (!prev) {
        return isRoot;
      }
      if (prev.type === "ContentStatement") {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i2, isRoot) {
      if (i2 === void 0) {
        i2 = -1;
      }
      var next = body[i2 + 1], sibling = body[i2 + 2];
      if (!next) {
        return isRoot;
      }
      if (next.type === "ContentStatement") {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    function omitRight(body, i2, multiple) {
      var current = body[i2 == null ? 0 : i2 + 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
      current.rightStripped = current.value !== original;
    }
    function omitLeft(body, i2, multiple) {
      var current = body[i2 == null ? body.length - 1 : i2 - 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    exports["default"] = WhitespaceControl;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    exports.prepareProgram = prepareProgram;
    exports.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substring(1, token.length - 1);
      } else {
        return token;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i2 = 0, l2 = parts.length; i2 < l2; i2++) {
        var part = parts[i2].part, isLiteral = parts[i2].original !== part;
        original += (parts[i2].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseWithoutProcessing = parseWithoutProcessing;
    exports.parse = parse;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = require_parser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = require_whitespace_control();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = require_helpers2();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = require_utils();
    exports.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast = _parser2["default"].parse(input);
      return ast;
    }
    function parse(input, options) {
      var ast = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _ast = require_ast();
    var _ast2 = _interopRequireDefault(_ast);
    var slice = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i2 = 0; i2 < len; i2++) {
          var opcode = this.opcodes[i2], otherOpcode = other.opcodes[i2];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (!this.children[i2].equals(other.children[i2])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile2(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result.usePartial;
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i2 = 0; i2 < bodyLength; i2++) {
          this.accept(body[i2]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
        var program = block.program, inverse = block.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block);
        if (type === "helper") {
          this.helperSexpr(block, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
        var program = partial.program;
        if (program) {
          program = this.compileProgram(partial.program);
        }
        var params = partial.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial.name);
        }
        this.setupFullMustacheParams(partial, program, void 0, true);
        var indent = partial.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string) {
        this.opcode("pushString", string.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs = hash.pairs, i2 = 0, l2 = pairs.length;
        this.opcode("pushHash");
        for (; i2 < l2; i2++) {
          this.pushParam(pairs[i2].value);
        }
        while (i2--) {
          this.opcode("assignToHash", pairs[i2].key);
        }
        this.opcode("popHash");
      },
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i2 = 0, l2 = params.length; i2 < l2; i2++) {
          this.pushParam(params[i2]);
        }
      },
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile(input, options, env) {
      if (options === void 0)
        options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i2, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i2, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a2, b2) {
      if (a2 === b2) {
        return true;
      }
      if (_utils.isArray(a2) && _utils.isArray(b2) && a2.length === b2.length) {
        for (var i2 = 0; i2 < a2.length; i2++) {
          if (!argEquals(a2[i2], b2[i2])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path = url2.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url2) {
        url2.path = path;
        return urlGenerate(url2);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set.add(aArray[i2], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x2, y2) {
      var temp = ary[x2];
      ary[x2] = ary[y2];
      ary[y2] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p2, r2) {
      if (p2 < r2) {
        var pivotIndex = randomIntInRange(p2, r2);
        var i2 = p2 - 1;
        swap(ary, pivotIndex, r2);
        var pivot = ary[r2];
        for (var j2 = p2; j2 < r2; j2++) {
          if (comparator(ary[j2], pivot) <= 0) {
            i2 += 1;
            swap(ary, i2, j2);
          }
        }
        swap(ary, i2 + 1, j2);
        var q2 = i2 + 1;
        doQuickSort(ary, comparator, p2, q2 - 1);
        doQuickSort(ary, comparator, q2 + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c2 = aStr.charAt(index);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s2, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
            sources.push(this._sections[i2].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk = this.children[i2];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils();
    var SourceNode = void 0;
    try {
      if (typeof define !== "function" || !define.amd) {
        SourceMap = require_source_map();
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {
    }
    var SourceMap;
    if (!SourceNode) {
      SourceNode = function(line, column, srcFile, chunks) {
        this.src = "";
        if (chunks) {
          this.add(chunks);
        }
      };
      SourceNode.prototype = {
        add: function add(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString() {
          return this.src;
        }
      };
    }
    function castChunk(chunk, codeGen, loc) {
      if (_utils.isArray(chunk)) {
        var ret = [];
        for (var i2 = 0, len = chunk.length; i2 < len; i2++) {
          ret.push(codeGen.wrap(chunk[i2], loc));
        }
        return ret;
      } else if (typeof chunk === "boolean" || typeof chunk === "number") {
        return chunk + "";
      }
      return chunk;
    }
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    CodeGen.prototype = {
      isEmpty: function isEmpty() {
        return !this.source.length;
      },
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
      merge: function merge() {
        var source = this.empty();
        this.each(function(line) {
          source.add(["  ", line, "\n"]);
        });
        return source;
      },
      each: function each(iter) {
        for (var i2 = 0, len = this.source.length; i2 < len; i2++) {
          iter(this.source[i2]);
        }
      },
      empty: function empty() {
        var loc = this.currentLocation || { start: {} };
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap(chunk) {
        var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
        if (chunk instanceof SourceNode) {
          return chunk;
        }
        chunk = castChunk(chunk, this, loc);
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
      },
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
      },
      quotedString: function quotedString(str) {
        return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
      },
      objectLiteral: function objectLiteral(obj) {
        var _this = this;
        var pairs = [];
        Object.keys(obj).forEach(function(key) {
          var value = castChunk(obj[key], _this);
          if (value !== "undefined") {
            pairs.push([_this.quotedString(key), ":", value]);
          }
        });
        var ret = this.generateList(pairs);
        ret.prepend("{");
        ret.add("}");
        return ret;
      },
      generateList: function generateList(entries) {
        var ret = this.empty();
        for (var i2 = 0, len = entries.length; i2 < len; i2++) {
          if (i2) {
            ret.add(",");
          }
          ret.add(castChunk(entries[i2], this));
        }
        return ret;
      },
      generateArray: function generateArray(entries) {
        var ret = this.generateList(entries);
        ret.prepend("[");
        ret.add("]");
        return ret;
      }
    };
    exports["default"] = CodeGen;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _base = require_base();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils();
    var _codeGen = require_code_gen();
    var _codeGen2 = _interopRequireDefault(_codeGen);
    function Literal(value) {
      this.value = value;
    }
    function JavaScriptCompiler() {
    }
    JavaScriptCompiler.prototype = {
      nameLookup: function nameLookup(parent, name) {
        return this.internalNameLookup(parent, name);
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
      },
      compilerInfo: function compilerInfo() {
        var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
        return [revision, versions];
      },
      appendToBuffer: function appendToBuffer(source, location2, explicit) {
        if (!_utils.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location2);
        if (this.environment.isSimple) {
          return ["return ", source, ";"];
        } else if (explicit) {
          return ["buffer += ", source, ";"];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
      initializeBuffer: function initializeBuffer() {
        return this.quotedString("");
      },
      internalNameLookup: function internalNameLookup(parent, name) {
        this.lookupPropertyFunctionIsUsed = true;
        return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
      },
      lookupPropertyFunctionIsUsed: false,
      compile: function compile(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          decorators: [],
          programs: [],
          environments: []
        };
        this.preamble();
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
        this.compileChildren(environment, options);
        this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
        var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i2 = void 0, l2 = void 0;
        for (i2 = 0, l2 = opcodes.length; i2 < l2; i2++) {
          opcode = opcodes[i2];
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
        this.source.currentLocation = firstLoc;
        this.pushSource("");
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _exception2["default"]("Compile completed with content left on stack");
        }
        if (!this.decorators.isEmpty()) {
          this.useDecorators = true;
          this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
          this.decorators.push("return fn;");
          if (asObject) {
            this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
          } else {
            this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
            this.decorators.push("}\n");
            this.decorators = this.decorators.merge();
          }
        } else {
          this.decorators = void 0;
        }
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          if (this.decorators) {
            ret.main_d = this.decorators;
            ret.useDecorators = true;
          }
          var _context = this.context;
          var programs = _context.programs;
          var decorators = _context.decorators;
          for (i2 = 0, l2 = programs.length; i2 < l2; i2++) {
            if (programs[i2]) {
              ret[i2] = programs[i2];
              if (decorators[i2]) {
                ret[i2 + "_d"] = decorators[i2];
                ret.useDecorators = true;
              }
            }
          }
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
          return ret;
        } else {
          return fn;
        }
      },
      preamble: function preamble() {
        this.lastContext = 0;
        this.source = new _codeGen2["default"](this.options.srcName);
        this.decorators = new _codeGen2["default"](this.options.srcName);
      },
      createFunctionContext: function createFunctionContext(asObject) {
        var _this = this;
        var varDeclarations = "";
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ", " + locals.join(", ");
        }
        var aliasCount = 0;
        Object.keys(this.aliases).forEach(function(alias) {
          var node = _this.aliases[alias];
          if (node.children && node.referenceCount > 1) {
            varDeclarations += ", alias" + ++aliasCount + "=" + alias;
            node.children[0] = "alias" + aliasCount;
          }
        });
        if (this.lookupPropertyFunctionIsUsed) {
          varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
        }
        var params = ["container", "depth0", "helpers", "partials", "data"];
        if (this.useBlockParams || this.useDepths) {
          params.push("blockParams");
        }
        if (this.useDepths) {
          params.push("depths");
        }
        var source = this.mergeSource(varDeclarations);
        if (asObject) {
          params.push(source);
          return Function.apply(this, params);
        } else {
          return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
        this.source.each(function(line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend("  + ");
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend("buffer += ");
              }
              bufferEnd.add(";");
              bufferStart = bufferEnd = void 0;
            }
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend("return ");
            bufferEnd.add(";");
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
          if (bufferStart) {
            bufferStart.prepend("return buffer + ");
            bufferEnd.add(";");
          } else {
            this.source.push("return buffer;");
          }
        }
        if (varDeclarations) {
          this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
        }
        return this.source.merge();
      },
      lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
        return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
      },
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
        this.push(this.source.functionCall(blockHelperMissing, "call", params));
      },
      ambiguousBlockValue: function ambiguousBlockValue() {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs("", 0, params, true);
        this.flushInline();
        var current = this.topStack();
        params.splice(1, 0, current);
        this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
      },
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
        this.pendingContent = content;
      },
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function(current) {
            return [" != null ? ", current, ' : ""'];
          });
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
          if (this.environment.isSimple) {
            this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
          }
        }
      },
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
      },
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
      lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
        var i2 = 0;
        if (!scoped && this.options.compat && !this.lastContext) {
          this.push(this.depthedLookup(parts[i2++]));
        } else {
          this.pushContext();
        }
        this.resolvePath("context", parts, i2, falsy, strict);
      },
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
        this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
        this.resolvePath("context", parts, 1);
      },
      lookupData: function lookupData(depth, parts, strict) {
        if (!depth) {
          this.pushStackLiteral("data");
        } else {
          this.pushStackLiteral("container.data(data, " + depth + ")");
        }
        this.resolvePath("data", parts, 0, true, strict);
      },
      resolvePath: function resolvePath(type, parts, i2, falsy, strict) {
        var _this2 = this;
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict && strict, this, parts, i2, type));
          return;
        }
        var len = parts.length;
        for (; i2 < len; i2++) {
          this.replaceStack(function(current) {
            var lookup = _this2.nameLookup(current, parts[i2], type);
            if (!falsy) {
              return [" != null ? ", lookup, " : ", current];
            } else {
              return [" && ", lookup];
            }
          });
        }
      },
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
      },
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
        if (type !== "SubExpression") {
          if (typeof string === "string") {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push("{}");
        }
        if (this.stringParams) {
          this.push("{}");
          this.push("{}");
        }
        this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: {}, types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
        this.push(this.objectLiteral(hash.values));
      },
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
      pushLiteral: function pushLiteral(value) {
        this.pushStackLiteral(value);
      },
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
      registerDecorator: function registerDecorator(paramSize, name) {
        var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
        this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
      },
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
        var possibleFunctionCalls = [];
        if (isSimple) {
          possibleFunctionCalls.push(helper.name);
        }
        possibleFunctionCalls.push(nonHelper);
        if (!this.options.strict) {
          possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
        }
        var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
        var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
        this.push(functionCall);
      },
      itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
        var result = [];
        result.push(items[0]);
        for (var i2 = 1; i2 < items.length; i2++) {
          result.push(separator, items[i2]);
        }
        return result;
      },
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, "call", helper.callParams));
      },
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister("helper");
        var nonHelper = this.popStack();
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
        var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
        var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
        if (!this.options.strict) {
          lookup[0] = "(helper = ";
          lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
        }
        this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
      },
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [], options = this.setupParams(name, 1, params);
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = "helpers";
        options.partials = "partials";
        options.decorators = "container.decorators";
        if (!isDynamic) {
          params.unshift(this.nameLookup("partials", name, "partial"));
        } else {
          params.unshift(name);
        }
        if (this.options.compat) {
          options.depths = "depths";
        }
        options = this.objectLiteral(options);
        params.push(options);
        this.push(this.source.functionCall("container.invokePartial", "", params));
      },
      assignToHash: function assignToHash(key) {
        var value = this.popStack(), context = void 0, type = void 0, id = void 0;
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value;
      },
      pushId: function pushId(type, name, child) {
        if (type === "BlockParam") {
          this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
        } else if (type === "PathExpression") {
          this.pushString(name);
        } else if (type === "SubExpression") {
          this.pushStackLiteral("true");
        } else {
          this.pushStackLiteral("null");
        }
      },
      compiler: JavaScriptCompiler,
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children, child = void 0, compiler = void 0;
        for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
          child = children[i2];
          compiler = new this.compiler();
          var existing = this.matchExistingProgram(child);
          if (existing == null) {
            this.context.programs.push("");
            var index = this.context.programs.length;
            child.index = index;
            child.name = "program" + index;
            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.decorators[index] = compiler.decorators;
            this.context.environments[index] = child;
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
            child.useDepths = this.useDepths;
            child.useBlockParams = this.useBlockParams;
          } else {
            child.index = existing.index;
            child.name = "program" + existing.index;
            this.useDepths = this.useDepths || existing.useDepths;
            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i2 = 0, len = this.context.environments.length; i2 < len; i2++) {
          var environment = this.context.environments[i2];
          if (environment && environment.equals(child)) {
            return environment;
          }
        }
      },
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
        if (this.useBlockParams || this.useDepths) {
          programParams.push("blockParams");
        }
        if (this.useDepths) {
          programParams.push("depths");
        }
        return "container.program(" + programParams.join(", ") + ")";
      },
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
      push: function push(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
        this.inlineStack.push(expr);
        return expr;
      },
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = void 0;
        }
        if (source) {
          this.source.push(source);
        }
      },
      replaceStack: function replaceStack(callback) {
        var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
        if (!this.isInline()) {
          throw new _exception2["default"]("replaceStack on non-inline");
        }
        var top = this.popStack(true);
        if (top instanceof Literal) {
          stack = [top.value];
          prefix = ["(", stack];
          usedLiteral = true;
        } else {
          createdStack = true;
          var _name = this.incrStack();
          prefix = ["((", this.push(_name), " = ", top, ")"];
          stack = this.topStack();
        }
        var item = callback.call(this, stack);
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ")"));
      },
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push("stack" + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return "stack" + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i2 = 0, len = inlineStack.length; i2 < len; i2++) {
          var entry = inlineStack[i2];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, " = ", entry, ";"]);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline() {
        return this.inlineStack.length;
      },
      popStack: function popStack(wrapped) {
        var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            if (!this.stackSlot) {
              throw new _exception2["default"]("Invalid stack pop");
            }
            this.stackSlot--;
          }
          return item;
        }
      },
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return "depths[" + context + "]";
        } else {
          return "depth" + context;
        }
      },
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
        return ret;
      },
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
        return {
          params,
          paramsInit,
          name: foundHelper,
          callParams: [callContext].concat(params)
        };
      },
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {}, contexts = [], types = [], ids = [], objectArgs = !params, param = void 0;
        if (objectArgs) {
          params = [];
        }
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
        var inverse = this.popStack(), program = this.popStack();
        if (program || inverse) {
          options.fn = program || "container.noop";
          options.inverse = inverse || "container.noop";
        }
        var i2 = paramSize;
        while (i2--) {
          param = this.popStack();
          params[i2] = param;
          if (this.trackIds) {
            ids[i2] = this.popStack();
          }
          if (this.stringParams) {
            types[i2] = this.popStack();
            contexts[i2] = this.popStack();
          }
        }
        if (objectArgs) {
          options.args = this.source.generateArray(params);
        }
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types);
          options.contexts = this.source.generateArray(contexts);
        }
        if (this.options.data) {
          options.data = "data";
        }
        if (this.useBlockParams) {
          options.blockParams = "blockParams";
        }
        return options;
      },
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params);
        options.loc = JSON.stringify(this.source.currentLocation);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister("options");
          params.push("options");
          return ["options=", options];
        } else if (params) {
          params.push(options);
          return "";
        } else {
          return options;
        }
      }
    };
    (function() {
      var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
      for (var i2 = 0, l2 = reservedWords.length; i2 < l2; i2++) {
        compilerWords[reservedWords[i2]] = true;
      }
    })();
    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    function strictLookup(requireTerminal, compiler, parts, i2, type) {
      var stack = compiler.popStack(), len = parts.length;
      if (requireTerminal) {
        len--;
      }
      for (; i2 < len; i2++) {
        stack = compiler.nameLookup(stack, parts[i2], type);
      }
      if (requireTerminal) {
        return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i2]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
      } else {
        return stack;
      }
    }
    exports["default"] = JavaScriptCompiler;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _handlebarsRuntime = require_handlebars_runtime();
    var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
    var _handlebarsCompilerAst = require_ast();
    var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
    var _handlebarsCompilerBase = require_base2();
    var _handlebarsCompilerCompiler = require_compiler();
    var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
    var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
    var _handlebarsCompilerVisitor = require_visitor();
    var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    var _create = _handlebarsRuntime2["default"].create;
    function create() {
      var hb = _create();
      hb.compile = function(input, options) {
        return _handlebarsCompilerCompiler.compile(input, options, hb);
      };
      hb.precompile = function(input, options) {
        return _handlebarsCompilerCompiler.precompile(input, options, hb);
      };
      hb.AST = _handlebarsCompilerAst2["default"];
      hb.Compiler = _handlebarsCompilerCompiler.Compiler;
      hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
      hb.Parser = _handlebarsCompilerBase.parser;
      hb.parse = _handlebarsCompilerBase.parse;
      hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst.Visitor = _handlebarsCompilerVisitor2["default"];
    inst["default"] = inst;
    exports["default"] = inst;
    module.exports = exports["default"];
  }
});

// node_modules/sweetalert2/dist/sweetalert2.all.js
var require_sweetalert2_all = __commonJS({
  "node_modules/sweetalert2/dist/sweetalert2.all.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Sweetalert2 = factory());
    })(exports, function() {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null)
            break;
        }
        return object;
      }
      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get2(target2, property2, receiver2) {
            var base = _superPropBase(target2, property2);
            if (!base)
              return;
            var desc = Object.getOwnPropertyDescriptor(base, property2);
            if (desc.get) {
              return desc.get.call(receiver2);
            }
            return desc.value;
          };
        }
        return _get(target, property, receiver || target);
      }
      var consolePrefix = "SweetAlert2:";
      var uniqueArray = function uniqueArray2(arr) {
        var result = [];
        for (var i2 = 0; i2 < arr.length; i2++) {
          if (result.indexOf(arr[i2]) === -1) {
            result.push(arr[i2]);
          }
        }
        return result;
      };
      var capitalizeFirstLetter = function capitalizeFirstLetter2(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      };
      var objectValues = function objectValues2(obj) {
        return Object.keys(obj).map(function(key) {
          return obj[key];
        });
      };
      var toArray = function toArray2(nodeList) {
        return Array.prototype.slice.call(nodeList);
      };
      var warn = function warn2(message) {
        console.warn("".concat(consolePrefix, " ").concat(_typeof(message) === "object" ? message.join(" ") : message));
      };
      var error = function error2(message) {
        console.error("".concat(consolePrefix, " ").concat(message));
      };
      var previousWarnOnceMessages = [];
      var warnOnce = function warnOnce2(message) {
        if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
          previousWarnOnceMessages.push(message);
          warn(message);
        }
      };
      var warnAboutDeprecation = function warnAboutDeprecation2(deprecatedParam, useInstead) {
        warnOnce('"'.concat(deprecatedParam, '" is deprecated and will be removed in the next major release. Please use "').concat(useInstead, '" instead.'));
      };
      var callIfFunction = function callIfFunction2(arg) {
        return typeof arg === "function" ? arg() : arg;
      };
      var hasToPromiseFn = function hasToPromiseFn2(arg) {
        return arg && typeof arg.toPromise === "function";
      };
      var asPromise = function asPromise2(arg) {
        return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
      };
      var isPromise = function isPromise2(arg) {
        return arg && Promise.resolve(arg) === arg;
      };
      var DismissReason = Object.freeze({
        cancel: "cancel",
        backdrop: "backdrop",
        close: "close",
        esc: "esc",
        timer: "timer"
      });
      var isJqueryElement = function isJqueryElement2(elem) {
        return _typeof(elem) === "object" && elem.jquery;
      };
      var isElement = function isElement2(elem) {
        return elem instanceof Element || isJqueryElement(elem);
      };
      var argsToParams = function argsToParams2(args) {
        var params = {};
        if (_typeof(args[0]) === "object" && !isElement(args[0])) {
          _extends(params, args[0]);
        } else {
          ["title", "html", "icon"].forEach(function(name, index) {
            var arg = args[index];
            if (typeof arg === "string" || isElement(arg)) {
              params[name] = arg;
            } else if (arg !== void 0) {
              error("Unexpected type of ".concat(name, '! Expected "string" or "Element", got ').concat(_typeof(arg)));
            }
          });
        }
        return params;
      };
      var swalPrefix = "swal2-";
      var prefix = function prefix2(items) {
        var result = {};
        for (var i2 in items) {
          result[items[i2]] = swalPrefix + items[i2];
        }
        return result;
      };
      var swalClasses = prefix(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "header", "content", "html-container", "actions", "confirm", "deny", "cancel", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"]);
      var iconTypes = prefix(["success", "warning", "info", "question", "error"]);
      var getContainer = function getContainer2() {
        return document.body.querySelector(".".concat(swalClasses.container));
      };
      var elementBySelector = function elementBySelector2(selectorString) {
        var container = getContainer();
        return container ? container.querySelector(selectorString) : null;
      };
      var elementByClass = function elementByClass2(className) {
        return elementBySelector(".".concat(className));
      };
      var getPopup = function getPopup2() {
        return elementByClass(swalClasses.popup);
      };
      var getIcon = function getIcon2() {
        return elementByClass(swalClasses.icon);
      };
      var getTitle = function getTitle2() {
        return elementByClass(swalClasses.title);
      };
      var getContent = function getContent2() {
        return elementByClass(swalClasses.content);
      };
      var getHtmlContainer = function getHtmlContainer2() {
        return elementByClass(swalClasses["html-container"]);
      };
      var getImage = function getImage2() {
        return elementByClass(swalClasses.image);
      };
      var getProgressSteps = function getProgressSteps2() {
        return elementByClass(swalClasses["progress-steps"]);
      };
      var getValidationMessage = function getValidationMessage2() {
        return elementByClass(swalClasses["validation-message"]);
      };
      var getConfirmButton = function getConfirmButton2() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
      };
      var getDenyButton = function getDenyButton2() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
      };
      var getInputLabel = function getInputLabel2() {
        return elementByClass(swalClasses["input-label"]);
      };
      var getLoader = function getLoader2() {
        return elementBySelector(".".concat(swalClasses.loader));
      };
      var getCancelButton = function getCancelButton2() {
        return elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
      };
      var getActions = function getActions2() {
        return elementByClass(swalClasses.actions);
      };
      var getHeader = function getHeader2() {
        return elementByClass(swalClasses.header);
      };
      var getFooter = function getFooter2() {
        return elementByClass(swalClasses.footer);
      };
      var getTimerProgressBar = function getTimerProgressBar2() {
        return elementByClass(swalClasses["timer-progress-bar"]);
      };
      var getCloseButton = function getCloseButton2() {
        return elementByClass(swalClasses.close);
      };
      var focusable = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n';
      var getFocusableElements = function getFocusableElements2() {
        var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(function(a2, b2) {
          a2 = parseInt(a2.getAttribute("tabindex"));
          b2 = parseInt(b2.getAttribute("tabindex"));
          if (a2 > b2) {
            return 1;
          } else if (a2 < b2) {
            return -1;
          }
          return 0;
        });
        var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function(el) {
          return el.getAttribute("tabindex") !== "-1";
        });
        return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function(el) {
          return isVisible(el);
        });
      };
      var isModal = function isModal2() {
        return !isToast() && !document.body.classList.contains(swalClasses["no-backdrop"]);
      };
      var isToast = function isToast2() {
        return document.body.classList.contains(swalClasses["toast-shown"]);
      };
      var isLoading = function isLoading2() {
        return getPopup().hasAttribute("data-loading");
      };
      var states = {
        previousBodyPadding: null
      };
      var setInnerHtml = function setInnerHtml2(elem, html) {
        elem.textContent = "";
        if (html) {
          var parser = new DOMParser();
          var parsed = parser.parseFromString(html, "text/html");
          toArray(parsed.querySelector("head").childNodes).forEach(function(child) {
            elem.appendChild(child);
          });
          toArray(parsed.querySelector("body").childNodes).forEach(function(child) {
            elem.appendChild(child);
          });
        }
      };
      var hasClass = function hasClass2(elem, className) {
        if (!className) {
          return false;
        }
        var classList = className.split(/\s+/);
        for (var i2 = 0; i2 < classList.length; i2++) {
          if (!elem.classList.contains(classList[i2])) {
            return false;
          }
        }
        return true;
      };
      var removeCustomClasses = function removeCustomClasses2(elem, params) {
        toArray(elem.classList).forEach(function(className) {
          if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1) && !(objectValues(params.showClass).indexOf(className) !== -1)) {
            elem.classList.remove(className);
          }
        });
      };
      var applyCustomClass = function applyCustomClass2(elem, params, className) {
        removeCustomClasses(elem, params);
        if (params.customClass && params.customClass[className]) {
          if (typeof params.customClass[className] !== "string" && !params.customClass[className].forEach) {
            return warn("Invalid type of customClass.".concat(className, '! Expected string or iterable object, got "').concat(_typeof(params.customClass[className]), '"'));
          }
          addClass(elem, params.customClass[className]);
        }
      };
      function getInput(content, inputType) {
        if (!inputType) {
          return null;
        }
        switch (inputType) {
          case "select":
          case "textarea":
          case "file":
            return getChildByClass(content, swalClasses[inputType]);
          case "checkbox":
            return content.querySelector(".".concat(swalClasses.checkbox, " input"));
          case "radio":
            return content.querySelector(".".concat(swalClasses.radio, " input:checked")) || content.querySelector(".".concat(swalClasses.radio, " input:first-child"));
          case "range":
            return content.querySelector(".".concat(swalClasses.range, " input"));
          default:
            return getChildByClass(content, swalClasses.input);
        }
      }
      var focusInput = function focusInput2(input) {
        input.focus();
        if (input.type !== "file") {
          var val = input.value;
          input.value = "";
          input.value = val;
        }
      };
      var toggleClass = function toggleClass2(target, classList, condition) {
        if (!target || !classList) {
          return;
        }
        if (typeof classList === "string") {
          classList = classList.split(/\s+/).filter(Boolean);
        }
        classList.forEach(function(className) {
          if (target.forEach) {
            target.forEach(function(elem) {
              condition ? elem.classList.add(className) : elem.classList.remove(className);
            });
          } else {
            condition ? target.classList.add(className) : target.classList.remove(className);
          }
        });
      };
      var addClass = function addClass2(target, classList) {
        toggleClass(target, classList, true);
      };
      var removeClass = function removeClass2(target, classList) {
        toggleClass(target, classList, false);
      };
      var getChildByClass = function getChildByClass2(elem, className) {
        for (var i2 = 0; i2 < elem.childNodes.length; i2++) {
          if (hasClass(elem.childNodes[i2], className)) {
            return elem.childNodes[i2];
          }
        }
      };
      var applyNumericalStyle = function applyNumericalStyle2(elem, property, value) {
        if (value === "".concat(parseInt(value))) {
          value = parseInt(value);
        }
        if (value || parseInt(value) === 0) {
          elem.style[property] = typeof value === "number" ? "".concat(value, "px") : value;
        } else {
          elem.style.removeProperty(property);
        }
      };
      var show = function show2(elem) {
        var display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex";
        elem.style.display = display;
      };
      var hide = function hide2(elem) {
        elem.style.display = "none";
      };
      var setStyle = function setStyle2(parent, selector, property, value) {
        var el = parent.querySelector(selector);
        if (el) {
          el.style[property] = value;
        }
      };
      var toggle = function toggle2(elem, condition, display) {
        condition ? show(elem, display) : hide(elem);
      };
      var isVisible = function isVisible2(elem) {
        return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
      };
      var allButtonsAreHidden = function allButtonsAreHidden2() {
        return !isVisible(getConfirmButton()) && !isVisible(getDenyButton()) && !isVisible(getCancelButton());
      };
      var isScrollable = function isScrollable2(elem) {
        return !!(elem.scrollHeight > elem.clientHeight);
      };
      var hasCssAnimation = function hasCssAnimation2(elem) {
        var style = window.getComputedStyle(elem);
        var animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
        var transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
        return animDuration > 0 || transDuration > 0;
      };
      var contains = function contains2(haystack, needle) {
        if (typeof haystack.contains === "function") {
          return haystack.contains(needle);
        }
      };
      var animateTimerProgressBar = function animateTimerProgressBar2(timer) {
        var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var timerProgressBar = getTimerProgressBar();
        if (isVisible(timerProgressBar)) {
          if (reset) {
            timerProgressBar.style.transition = "none";
            timerProgressBar.style.width = "100%";
          }
          setTimeout(function() {
            timerProgressBar.style.transition = "width ".concat(timer / 1e3, "s linear");
            timerProgressBar.style.width = "0%";
          }, 10);
        }
      };
      var stopTimerProgressBar = function stopTimerProgressBar2() {
        var timerProgressBar = getTimerProgressBar();
        var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        timerProgressBar.style.removeProperty("transition");
        timerProgressBar.style.width = "100%";
        var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        var timerProgressBarPercent = parseInt(timerProgressBarWidth / timerProgressBarFullWidth * 100);
        timerProgressBar.style.removeProperty("transition");
        timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
      };
      var isNodeEnv = function isNodeEnv2() {
        return typeof window === "undefined" || typeof document === "undefined";
      };
      var sweetHTML = '\n <div aria-labelledby="'.concat(swalClasses.title, '" aria-describedby="').concat(swalClasses.content, '" class="').concat(swalClasses.popup, '" tabindex="-1">\n   <div class="').concat(swalClasses.header, '">\n     <ul class="').concat(swalClasses["progress-steps"], '"></ul>\n     <div class="').concat(swalClasses.icon, '"></div>\n     <img class="').concat(swalClasses.image, '" />\n     <h2 class="').concat(swalClasses.title, '" id="').concat(swalClasses.title, '"></h2>\n     <button type="button" class="').concat(swalClasses.close, '"></button>\n   </div>\n   <div class="').concat(swalClasses.content, '">\n     <div id="').concat(swalClasses.content, '" class="').concat(swalClasses["html-container"], '"></div>\n     <input class="').concat(swalClasses.input, '" />\n     <input type="file" class="').concat(swalClasses.file, '" />\n     <div class="').concat(swalClasses.range, '">\n       <input type="range" />\n       <output></output>\n     </div>\n     <select class="').concat(swalClasses.select, '"></select>\n     <div class="').concat(swalClasses.radio, '"></div>\n     <label for="').concat(swalClasses.checkbox, '" class="').concat(swalClasses.checkbox, '">\n       <input type="checkbox" />\n       <span class="').concat(swalClasses.label, '"></span>\n     </label>\n     <textarea class="').concat(swalClasses.textarea, '"></textarea>\n     <div class="').concat(swalClasses["validation-message"], '" id="').concat(swalClasses["validation-message"], '"></div>\n   </div>\n   <div class="').concat(swalClasses.actions, '">\n     <div class="').concat(swalClasses.loader, '"></div>\n     <button type="button" class="').concat(swalClasses.confirm, '"></button>\n     <button type="button" class="').concat(swalClasses.deny, '"></button>\n     <button type="button" class="').concat(swalClasses.cancel, '"></button>\n   </div>\n   <div class="').concat(swalClasses.footer, '"></div>\n   <div class="').concat(swalClasses["timer-progress-bar-container"], '">\n     <div class="').concat(swalClasses["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, "");
      var resetOldContainer = function resetOldContainer2() {
        var oldContainer = getContainer();
        if (!oldContainer) {
          return false;
        }
        oldContainer.parentNode.removeChild(oldContainer);
        removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
        return true;
      };
      var oldInputVal;
      var resetValidationMessage = function resetValidationMessage2(e2) {
        if (Swal2.isVisible() && oldInputVal !== e2.target.value) {
          Swal2.resetValidationMessage();
        }
        oldInputVal = e2.target.value;
      };
      var addInputChangeListeners = function addInputChangeListeners2() {
        var content = getContent();
        var input = getChildByClass(content, swalClasses.input);
        var file = getChildByClass(content, swalClasses.file);
        var range = content.querySelector(".".concat(swalClasses.range, " input"));
        var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
        var select = getChildByClass(content, swalClasses.select);
        var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
        var textarea = getChildByClass(content, swalClasses.textarea);
        input.oninput = resetValidationMessage;
        file.onchange = resetValidationMessage;
        select.onchange = resetValidationMessage;
        checkbox.onchange = resetValidationMessage;
        textarea.oninput = resetValidationMessage;
        range.oninput = function(e2) {
          resetValidationMessage(e2);
          rangeOutput.value = range.value;
        };
        range.onchange = function(e2) {
          resetValidationMessage(e2);
          range.nextSibling.value = range.value;
        };
      };
      var getTarget = function getTarget2(target) {
        return typeof target === "string" ? document.querySelector(target) : target;
      };
      var setupAccessibility = function setupAccessibility2(params) {
        var popup = getPopup();
        popup.setAttribute("role", params.toast ? "alert" : "dialog");
        popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
        if (!params.toast) {
          popup.setAttribute("aria-modal", "true");
        }
      };
      var setupRTL = function setupRTL2(targetElement) {
        if (window.getComputedStyle(targetElement).direction === "rtl") {
          addClass(getContainer(), swalClasses.rtl);
        }
      };
      var init = function init2(params) {
        var oldContainerExisted = resetOldContainer();
        if (isNodeEnv()) {
          error("SweetAlert2 requires document to initialize");
          return;
        }
        var container = document.createElement("div");
        container.className = swalClasses.container;
        if (oldContainerExisted) {
          addClass(container, swalClasses["no-transition"]);
        }
        setInnerHtml(container, sweetHTML);
        var targetElement = getTarget(params.target);
        targetElement.appendChild(container);
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
      };
      var parseHtmlToContainer = function parseHtmlToContainer2(param, target) {
        if (param instanceof HTMLElement) {
          target.appendChild(param);
        } else if (_typeof(param) === "object") {
          handleObject(param, target);
        } else if (param) {
          setInnerHtml(target, param);
        }
      };
      var handleObject = function handleObject2(param, target) {
        if (param.jquery) {
          handleJqueryElem(target, param);
        } else {
          setInnerHtml(target, param.toString());
        }
      };
      var handleJqueryElem = function handleJqueryElem2(target, elem) {
        target.textContent = "";
        if (0 in elem) {
          for (var i2 = 0; i2 in elem; i2++) {
            target.appendChild(elem[i2].cloneNode(true));
          }
        } else {
          target.appendChild(elem.cloneNode(true));
        }
      };
      var animationEndEvent = function() {
        if (isNodeEnv()) {
          return false;
        }
        var testEl = document.createElement("div");
        var transEndEventNames = {
          WebkitAnimation: "webkitAnimationEnd",
          OAnimation: "oAnimationEnd oanimationend",
          animation: "animationend"
        };
        for (var i2 in transEndEventNames) {
          if (Object.prototype.hasOwnProperty.call(transEndEventNames, i2) && typeof testEl.style[i2] !== "undefined") {
            return transEndEventNames[i2];
          }
        }
        return false;
      }();
      var measureScrollbar = function measureScrollbar2() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = swalClasses["scrollbar-measure"];
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };
      var renderActions = function renderActions2(instance, params) {
        var actions = getActions();
        var loader = getLoader();
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
          hide(actions);
        }
        applyCustomClass(actions, params, "actions");
        renderButton(confirmButton, "confirm", params);
        renderButton(denyButton, "deny", params);
        renderButton(cancelButton, "cancel", params);
        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
        if (params.reverseButtons) {
          actions.insertBefore(cancelButton, loader);
          actions.insertBefore(denyButton, loader);
          actions.insertBefore(confirmButton, loader);
        }
        setInnerHtml(loader, params.loaderHtml);
        applyCustomClass(loader, params, "loader");
      };
      function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
        if (!params.buttonsStyling) {
          return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
        }
        addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
        if (params.confirmButtonColor) {
          confirmButton.style.backgroundColor = params.confirmButtonColor;
        }
        if (params.denyButtonColor) {
          denyButton.style.backgroundColor = params.denyButtonColor;
        }
        if (params.cancelButtonColor) {
          cancelButton.style.backgroundColor = params.cancelButtonColor;
        }
      }
      function renderButton(button, buttonType, params) {
        toggle(button, params["show".concat(capitalizeFirstLetter(buttonType), "Button")], "inline-block");
        setInnerHtml(button, params["".concat(buttonType, "ButtonText")]);
        button.setAttribute("aria-label", params["".concat(buttonType, "ButtonAriaLabel")]);
        button.className = swalClasses[buttonType];
        applyCustomClass(button, params, "".concat(buttonType, "Button"));
        addClass(button, params["".concat(buttonType, "ButtonClass")]);
      }
      function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === "string") {
          container.style.background = backdrop;
        } else if (!backdrop) {
          addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
        }
      }
      function handlePositionParam(container, position) {
        if (position in swalClasses) {
          addClass(container, swalClasses[position]);
        } else {
          warn('The "position" parameter is not valid, defaulting to "center"');
          addClass(container, swalClasses.center);
        }
      }
      function handleGrowParam(container, grow) {
        if (grow && typeof grow === "string") {
          var growClass = "grow-".concat(grow);
          if (growClass in swalClasses) {
            addClass(container, swalClasses[growClass]);
          }
        }
      }
      var renderContainer = function renderContainer2(instance, params) {
        var container = getContainer();
        if (!container) {
          return;
        }
        handleBackdropParam(container, params.backdrop);
        if (!params.backdrop && params.allowOutsideClick) {
          warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        }
        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow);
        applyCustomClass(container, params, "container");
        var queueStep = document.body.getAttribute("data-swal2-queue-step");
        if (queueStep) {
          container.setAttribute("data-queue-step", queueStep);
          document.body.removeAttribute("data-swal2-queue-step");
        }
      };
      var privateProps = {
        promise: /* @__PURE__ */ new WeakMap(),
        innerParams: /* @__PURE__ */ new WeakMap(),
        domCache: /* @__PURE__ */ new WeakMap()
      };
      var inputTypes = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
      var renderInput = function renderInput2(instance, params) {
        var content = getContent();
        var innerParams = privateProps.innerParams.get(instance);
        var rerender = !innerParams || params.input !== innerParams.input;
        inputTypes.forEach(function(inputType) {
          var inputClass = swalClasses[inputType];
          var inputContainer = getChildByClass(content, inputClass);
          setAttributes(inputType, params.inputAttributes);
          inputContainer.className = inputClass;
          if (rerender) {
            hide(inputContainer);
          }
        });
        if (params.input) {
          if (rerender) {
            showInput(params);
          }
          setCustomClass(params);
        }
      };
      var showInput = function showInput2(params) {
        if (!renderInputType[params.input]) {
          return error('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(params.input, '"'));
        }
        var inputContainer = getInputContainer(params.input);
        var input = renderInputType[params.input](inputContainer, params);
        show(input);
        setTimeout(function() {
          focusInput(input);
        });
      };
      var removeAttributes = function removeAttributes2(input) {
        for (var i2 = 0; i2 < input.attributes.length; i2++) {
          var attrName = input.attributes[i2].name;
          if (!(["type", "value", "style"].indexOf(attrName) !== -1)) {
            input.removeAttribute(attrName);
          }
        }
      };
      var setAttributes = function setAttributes2(inputType, inputAttributes) {
        var input = getInput(getContent(), inputType);
        if (!input) {
          return;
        }
        removeAttributes(input);
        for (var attr in inputAttributes) {
          if (inputType === "range" && attr === "placeholder") {
            continue;
          }
          input.setAttribute(attr, inputAttributes[attr]);
        }
      };
      var setCustomClass = function setCustomClass2(params) {
        var inputContainer = getInputContainer(params.input);
        if (params.customClass) {
          addClass(inputContainer, params.customClass.input);
        }
      };
      var setInputPlaceholder = function setInputPlaceholder2(input, params) {
        if (!input.placeholder || params.inputPlaceholder) {
          input.placeholder = params.inputPlaceholder;
        }
      };
      var setInputLabel = function setInputLabel2(input, prependTo, params) {
        if (params.inputLabel) {
          input.id = swalClasses.input;
          var label = document.createElement("label");
          var labelClass = swalClasses["input-label"];
          label.setAttribute("for", input.id);
          label.className = labelClass;
          addClass(label, params.customClass.inputLabel);
          label.innerText = params.inputLabel;
          prependTo.insertAdjacentElement("beforebegin", label);
        }
      };
      var getInputContainer = function getInputContainer2(inputType) {
        var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
        return getChildByClass(getContent(), inputClass);
      };
      var renderInputType = {};
      renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function(input, params) {
        if (typeof params.inputValue === "string" || typeof params.inputValue === "number") {
          input.value = params.inputValue;
        } else if (!isPromise(params.inputValue)) {
          warn('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(_typeof(params.inputValue), '"'));
        }
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        input.type = params.input;
        return input;
      };
      renderInputType.file = function(input, params) {
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        return input;
      };
      renderInputType.range = function(range, params) {
        var rangeInput = range.querySelector("input");
        var rangeOutput = range.querySelector("output");
        rangeInput.value = params.inputValue;
        rangeInput.type = params.input;
        rangeOutput.value = params.inputValue;
        setInputLabel(rangeInput, range, params);
        return range;
      };
      renderInputType.select = function(select, params) {
        select.textContent = "";
        if (params.inputPlaceholder) {
          var placeholder = document.createElement("option");
          setInnerHtml(placeholder, params.inputPlaceholder);
          placeholder.value = "";
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }
        setInputLabel(select, select, params);
        return select;
      };
      renderInputType.radio = function(radio) {
        radio.textContent = "";
        return radio;
      };
      renderInputType.checkbox = function(checkboxContainer, params) {
        var checkbox = getInput(getContent(), "checkbox");
        checkbox.value = 1;
        checkbox.id = swalClasses.checkbox;
        checkbox.checked = Boolean(params.inputValue);
        var label = checkboxContainer.querySelector("span");
        setInnerHtml(label, params.inputPlaceholder);
        return checkboxContainer;
      };
      renderInputType.textarea = function(textarea, params) {
        textarea.value = params.inputValue;
        setInputPlaceholder(textarea, params);
        setInputLabel(textarea, textarea, params);
        var getPadding = function getPadding2(el) {
          return parseInt(window.getComputedStyle(el).paddingLeft) + parseInt(window.getComputedStyle(el).paddingRight);
        };
        if ("MutationObserver" in window) {
          var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
          var outputsize = function outputsize2() {
            var contentWidth = textarea.offsetWidth + getPadding(getPopup()) + getPadding(getContent());
            if (contentWidth > initialPopupWidth) {
              getPopup().style.width = "".concat(contentWidth, "px");
            } else {
              getPopup().style.width = null;
            }
          };
          new MutationObserver(outputsize).observe(textarea, {
            attributes: true,
            attributeFilter: ["style"]
          });
        }
        return textarea;
      };
      var renderContent = function renderContent2(instance, params) {
        var htmlContainer = getHtmlContainer();
        applyCustomClass(htmlContainer, params, "htmlContainer");
        if (params.html) {
          parseHtmlToContainer(params.html, htmlContainer);
          show(htmlContainer, "block");
        } else if (params.text) {
          htmlContainer.textContent = params.text;
          show(htmlContainer, "block");
        } else {
          hide(htmlContainer);
        }
        renderInput(instance, params);
        applyCustomClass(getContent(), params, "content");
      };
      var renderFooter = function renderFooter2(instance, params) {
        var footer = getFooter();
        toggle(footer, params.footer);
        if (params.footer) {
          parseHtmlToContainer(params.footer, footer);
        }
        applyCustomClass(footer, params, "footer");
      };
      var renderCloseButton = function renderCloseButton2(instance, params) {
        var closeButton = getCloseButton();
        setInnerHtml(closeButton, params.closeButtonHtml);
        applyCustomClass(closeButton, params, "closeButton");
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute("aria-label", params.closeButtonAriaLabel);
      };
      var renderIcon = function renderIcon2(instance, params) {
        var innerParams = privateProps.innerParams.get(instance);
        var icon = getIcon();
        if (innerParams && params.icon === innerParams.icon) {
          setContent(icon, params);
          applyStyles(icon, params);
          return;
        }
        if (!params.icon && !params.iconHtml) {
          return hide(icon);
        }
        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
          error('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(params.icon, '"'));
          return hide(icon);
        }
        show(icon);
        setContent(icon, params);
        applyStyles(icon, params);
        addClass(icon, params.showClass.icon);
      };
      var applyStyles = function applyStyles2(icon, params) {
        for (var iconType in iconTypes) {
          if (params.icon !== iconType) {
            removeClass(icon, iconTypes[iconType]);
          }
        }
        addClass(icon, iconTypes[params.icon]);
        setColor(icon, params);
        adjustSuccessIconBackgoundColor();
        applyCustomClass(icon, params, "icon");
      };
      var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor2() {
        var popup = getPopup();
        var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
        var successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
        for (var i2 = 0; i2 < successIconParts.length; i2++) {
          successIconParts[i2].style.backgroundColor = popupBackgroundColor;
        }
      };
      var setContent = function setContent2(icon, params) {
        icon.textContent = "";
        if (params.iconHtml) {
          setInnerHtml(icon, iconContent(params.iconHtml));
        } else if (params.icon === "success") {
          setInnerHtml(icon, '\n      <div class="swal2-success-circular-line-left"></div>\n      <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n      <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n      <div class="swal2-success-circular-line-right"></div>\n    ');
        } else if (params.icon === "error") {
          setInnerHtml(icon, '\n      <span class="swal2-x-mark">\n        <span class="swal2-x-mark-line-left"></span>\n        <span class="swal2-x-mark-line-right"></span>\n      </span>\n    ');
        } else {
          var defaultIconHtml = {
            question: "?",
            warning: "!",
            info: "i"
          };
          setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
        }
      };
      var setColor = function setColor2(icon, params) {
        if (!params.iconColor) {
          return;
        }
        icon.style.color = params.iconColor;
        icon.style.borderColor = params.iconColor;
        for (var _i = 0, _arr = [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]; _i < _arr.length; _i++) {
          var sel = _arr[_i];
          setStyle(icon, sel, "backgroundColor", params.iconColor);
        }
        setStyle(icon, ".swal2-success-ring", "borderColor", params.iconColor);
      };
      var iconContent = function iconContent2(content) {
        return '<div class="'.concat(swalClasses["icon-content"], '">').concat(content, "</div>");
      };
      var renderImage = function renderImage2(instance, params) {
        var image = getImage();
        if (!params.imageUrl) {
          return hide(image);
        }
        show(image, "");
        image.setAttribute("src", params.imageUrl);
        image.setAttribute("alt", params.imageAlt);
        applyNumericalStyle(image, "width", params.imageWidth);
        applyNumericalStyle(image, "height", params.imageHeight);
        image.className = swalClasses.image;
        applyCustomClass(image, params, "image");
      };
      var currentSteps = [];
      var queue = function queue2(steps) {
        warnAboutDeprecation("Swal.queue()", "async/await");
        var Swal3 = this;
        currentSteps = steps;
        var resetAndResolve = function resetAndResolve2(resolve, value) {
          currentSteps = [];
          resolve(value);
        };
        var queueResult = [];
        return new Promise(function(resolve) {
          (function step(i2, callback) {
            if (i2 < currentSteps.length) {
              document.body.setAttribute("data-swal2-queue-step", i2);
              Swal3.fire(currentSteps[i2]).then(function(result) {
                if (typeof result.value !== "undefined") {
                  queueResult.push(result.value);
                  step(i2 + 1, callback);
                } else {
                  resetAndResolve(resolve, {
                    dismiss: result.dismiss
                  });
                }
              });
            } else {
              resetAndResolve(resolve, {
                value: queueResult
              });
            }
          })(0);
        });
      };
      var getQueueStep = function getQueueStep2() {
        return getContainer() && getContainer().getAttribute("data-queue-step");
      };
      var insertQueueStep = function insertQueueStep2(step, index) {
        if (index && index < currentSteps.length) {
          return currentSteps.splice(index, 0, step);
        }
        return currentSteps.push(step);
      };
      var deleteQueueStep = function deleteQueueStep2(index) {
        if (typeof currentSteps[index] !== "undefined") {
          currentSteps.splice(index, 1);
        }
      };
      var createStepElement = function createStepElement2(step) {
        var stepEl = document.createElement("li");
        addClass(stepEl, swalClasses["progress-step"]);
        setInnerHtml(stepEl, step);
        return stepEl;
      };
      var createLineElement = function createLineElement2(params) {
        var lineEl = document.createElement("li");
        addClass(lineEl, swalClasses["progress-step-line"]);
        if (params.progressStepsDistance) {
          lineEl.style.width = params.progressStepsDistance;
        }
        return lineEl;
      };
      var renderProgressSteps = function renderProgressSteps2(instance, params) {
        var progressStepsContainer = getProgressSteps();
        if (!params.progressSteps || params.progressSteps.length === 0) {
          return hide(progressStepsContainer);
        }
        show(progressStepsContainer);
        progressStepsContainer.textContent = "";
        var currentProgressStep = parseInt(params.currentProgressStep === void 0 ? getQueueStep() : params.currentProgressStep);
        if (currentProgressStep >= params.progressSteps.length) {
          warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
        }
        params.progressSteps.forEach(function(step, index) {
          var stepEl = createStepElement(step);
          progressStepsContainer.appendChild(stepEl);
          if (index === currentProgressStep) {
            addClass(stepEl, swalClasses["active-progress-step"]);
          }
          if (index !== params.progressSteps.length - 1) {
            var lineEl = createLineElement(params);
            progressStepsContainer.appendChild(lineEl);
          }
        });
      };
      var renderTitle = function renderTitle2(instance, params) {
        var title = getTitle();
        toggle(title, params.title || params.titleText, "block");
        if (params.title) {
          parseHtmlToContainer(params.title, title);
        }
        if (params.titleText) {
          title.innerText = params.titleText;
        }
        applyCustomClass(title, params, "title");
      };
      var renderHeader = function renderHeader2(instance, params) {
        var header = getHeader();
        applyCustomClass(header, params, "header");
        renderProgressSteps(instance, params);
        renderIcon(instance, params);
        renderImage(instance, params);
        renderTitle(instance, params);
        renderCloseButton(instance, params);
      };
      var renderPopup = function renderPopup2(instance, params) {
        var container = getContainer();
        var popup = getPopup();
        if (params.toast) {
          applyNumericalStyle(container, "width", params.width);
          popup.style.width = "100%";
        } else {
          applyNumericalStyle(popup, "width", params.width);
        }
        applyNumericalStyle(popup, "padding", params.padding);
        if (params.background) {
          popup.style.background = params.background;
        }
        hide(getValidationMessage());
        addClasses(popup, params);
      };
      var addClasses = function addClasses2(popup, params) {
        popup.className = "".concat(swalClasses.popup, " ").concat(isVisible(popup) ? params.showClass.popup : "");
        if (params.toast) {
          addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
          addClass(popup, swalClasses.toast);
        } else {
          addClass(popup, swalClasses.modal);
        }
        applyCustomClass(popup, params, "popup");
        if (typeof params.customClass === "string") {
          addClass(popup, params.customClass);
        }
        if (params.icon) {
          addClass(popup, swalClasses["icon-".concat(params.icon)]);
        }
      };
      var render = function render2(instance, params) {
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderHeader(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);
        if (typeof params.didRender === "function") {
          params.didRender(getPopup());
        } else if (typeof params.onRender === "function") {
          params.onRender(getPopup());
        }
      };
      var isVisible$1 = function isVisible$$1() {
        return isVisible(getPopup());
      };
      var clickConfirm = function clickConfirm2() {
        return getConfirmButton() && getConfirmButton().click();
      };
      var clickDeny = function clickDeny2() {
        return getDenyButton() && getDenyButton().click();
      };
      var clickCancel = function clickCancel2() {
        return getCancelButton() && getCancelButton().click();
      };
      function fire() {
        var Swal3 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _construct(Swal3, args);
      }
      function mixin(mixinParams) {
        var MixinSwal = /* @__PURE__ */ function(_this) {
          _inherits(MixinSwal2, _this);
          var _super = _createSuper(MixinSwal2);
          function MixinSwal2() {
            _classCallCheck(this, MixinSwal2);
            return _super.apply(this, arguments);
          }
          _createClass(MixinSwal2, [{
            key: "_main",
            value: function _main2(params, priorityMixinParams) {
              return _get(_getPrototypeOf(MixinSwal2.prototype), "_main", this).call(this, params, _extends({}, mixinParams, priorityMixinParams));
            }
          }]);
          return MixinSwal2;
        }(this);
        return MixinSwal;
      }
      var showLoading = function showLoading2(buttonToReplace) {
        var popup = getPopup();
        if (!popup) {
          Swal2.fire();
        }
        popup = getPopup();
        var actions = getActions();
        var loader = getLoader();
        if (!buttonToReplace && isVisible(getConfirmButton())) {
          buttonToReplace = getConfirmButton();
        }
        show(actions);
        if (buttonToReplace) {
          hide(buttonToReplace);
          loader.setAttribute("data-button-to-replace", buttonToReplace.className);
        }
        loader.parentNode.insertBefore(loader, buttonToReplace);
        addClass([popup, actions], swalClasses.loading);
        show(loader);
        popup.setAttribute("data-loading", true);
        popup.setAttribute("aria-busy", true);
        popup.focus();
      };
      var RESTORE_FOCUS_TIMEOUT = 100;
      var globalState = {};
      var focusPreviousActiveElement = function focusPreviousActiveElement2() {
        if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
          globalState.previousActiveElement.focus();
          globalState.previousActiveElement = null;
        } else if (document.body) {
          document.body.focus();
        }
      };
      var restoreActiveElement = function restoreActiveElement2(returnFocus) {
        return new Promise(function(resolve) {
          if (!returnFocus) {
            return resolve();
          }
          var x2 = window.scrollX;
          var y2 = window.scrollY;
          globalState.restoreFocusTimeout = setTimeout(function() {
            focusPreviousActiveElement();
            resolve();
          }, RESTORE_FOCUS_TIMEOUT);
          if (typeof x2 !== "undefined" && typeof y2 !== "undefined") {
            window.scrollTo(x2, y2);
          }
        });
      };
      var getTimerLeft = function getTimerLeft2() {
        return globalState.timeout && globalState.timeout.getTimerLeft();
      };
      var stopTimer = function stopTimer2() {
        if (globalState.timeout) {
          stopTimerProgressBar();
          return globalState.timeout.stop();
        }
      };
      var resumeTimer = function resumeTimer2() {
        if (globalState.timeout) {
          var remaining = globalState.timeout.start();
          animateTimerProgressBar(remaining);
          return remaining;
        }
      };
      var toggleTimer = function toggleTimer2() {
        var timer = globalState.timeout;
        return timer && (timer.running ? stopTimer() : resumeTimer());
      };
      var increaseTimer = function increaseTimer2(n2) {
        if (globalState.timeout) {
          var remaining = globalState.timeout.increase(n2);
          animateTimerProgressBar(remaining, true);
          return remaining;
        }
      };
      var isTimerRunning = function isTimerRunning2() {
        return globalState.timeout && globalState.timeout.isRunning();
      };
      var bodyClickListenerAdded = false;
      var clickHandlers = {};
      function bindClickHandler() {
        var attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template";
        clickHandlers[attr] = this;
        if (!bodyClickListenerAdded) {
          document.body.addEventListener("click", bodyClickListener);
          bodyClickListenerAdded = true;
        }
      }
      var bodyClickListener = function bodyClickListener2(event2) {
        for (var el = event2.target; el && el !== document; el = el.parentNode) {
          for (var attr in clickHandlers) {
            var template = el.getAttribute(attr);
            if (template) {
              clickHandlers[attr].fire({
                template
              });
              return;
            }
          }
        }
      };
      var defaultParams = {
        title: "",
        titleText: "",
        text: "",
        html: "",
        footer: "",
        icon: void 0,
        iconColor: void 0,
        iconHtml: void 0,
        template: void 0,
        toast: false,
        animation: true,
        showClass: {
          popup: "swal2-show",
          backdrop: "swal2-backdrop-show",
          icon: "swal2-icon-show"
        },
        hideClass: {
          popup: "swal2-hide",
          backdrop: "swal2-backdrop-hide",
          icon: "swal2-icon-hide"
        },
        customClass: {},
        target: "body",
        backdrop: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showDenyButton: false,
        showCancelButton: false,
        preConfirm: void 0,
        preDeny: void 0,
        confirmButtonText: "OK",
        confirmButtonAriaLabel: "",
        confirmButtonColor: void 0,
        denyButtonText: "No",
        denyButtonAriaLabel: "",
        denyButtonColor: void 0,
        cancelButtonText: "Cancel",
        cancelButtonAriaLabel: "",
        cancelButtonColor: void 0,
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusDeny: false,
        focusCancel: false,
        returnFocus: true,
        showCloseButton: false,
        closeButtonHtml: "&times;",
        closeButtonAriaLabel: "Close this dialog",
        loaderHtml: "",
        showLoaderOnConfirm: false,
        showLoaderOnDeny: false,
        imageUrl: void 0,
        imageWidth: void 0,
        imageHeight: void 0,
        imageAlt: "",
        timer: void 0,
        timerProgressBar: false,
        width: void 0,
        padding: void 0,
        background: void 0,
        input: void 0,
        inputPlaceholder: "",
        inputLabel: "",
        inputValue: "",
        inputOptions: {},
        inputAutoTrim: true,
        inputAttributes: {},
        inputValidator: void 0,
        returnInputValueOnDeny: false,
        validationMessage: void 0,
        grow: false,
        position: "center",
        progressSteps: [],
        currentProgressStep: void 0,
        progressStepsDistance: void 0,
        onBeforeOpen: void 0,
        onOpen: void 0,
        willOpen: void 0,
        didOpen: void 0,
        onRender: void 0,
        didRender: void 0,
        onClose: void 0,
        onAfterClose: void 0,
        willClose: void 0,
        didClose: void 0,
        onDestroy: void 0,
        didDestroy: void 0,
        scrollbarPadding: true
      };
      var updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "onAfterClose", "onClose", "onDestroy", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"];
      var deprecatedParams = {
        animation: 'showClass" and "hideClass',
        onBeforeOpen: "willOpen",
        onOpen: "didOpen",
        onRender: "didRender",
        onClose: "willClose",
        onAfterClose: "didClose",
        onDestroy: "didDestroy"
      };
      var toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
      var isValidParameter = function isValidParameter2(paramName) {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
      };
      var isUpdatableParameter = function isUpdatableParameter2(paramName) {
        return updatableParams.indexOf(paramName) !== -1;
      };
      var isDeprecatedParameter = function isDeprecatedParameter2(paramName) {
        return deprecatedParams[paramName];
      };
      var checkIfParamIsValid = function checkIfParamIsValid2(param) {
        if (!isValidParameter(param)) {
          warn('Unknown parameter "'.concat(param, '"'));
        }
      };
      var checkIfToastParamIsValid = function checkIfToastParamIsValid2(param) {
        if (toastIncompatibleParams.indexOf(param) !== -1) {
          warn('The parameter "'.concat(param, '" is incompatible with toasts'));
        }
      };
      var checkIfParamIsDeprecated = function checkIfParamIsDeprecated2(param) {
        if (isDeprecatedParameter(param)) {
          warnAboutDeprecation(param, isDeprecatedParameter(param));
        }
      };
      var showWarningsForParams = function showWarningsForParams2(params) {
        for (var param in params) {
          checkIfParamIsValid(param);
          if (params.toast) {
            checkIfToastParamIsValid(param);
          }
          checkIfParamIsDeprecated(param);
        }
      };
      var staticMethods = /* @__PURE__ */ Object.freeze({
        isValidParameter,
        isUpdatableParameter,
        isDeprecatedParameter,
        argsToParams,
        isVisible: isVisible$1,
        clickConfirm,
        clickDeny,
        clickCancel,
        getContainer,
        getPopup,
        getTitle,
        getContent,
        getHtmlContainer,
        getImage,
        getIcon,
        getInputLabel,
        getCloseButton,
        getActions,
        getConfirmButton,
        getDenyButton,
        getCancelButton,
        getLoader,
        getHeader,
        getFooter,
        getTimerProgressBar,
        getFocusableElements,
        getValidationMessage,
        isLoading,
        fire,
        mixin,
        queue,
        getQueueStep,
        insertQueueStep,
        deleteQueueStep,
        showLoading,
        enableLoading: showLoading,
        getTimerLeft,
        stopTimer,
        resumeTimer,
        toggleTimer,
        increaseTimer,
        isTimerRunning,
        bindClickHandler
      });
      function hideLoading() {
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
          return;
        }
        var domCache = privateProps.domCache.get(this);
        hide(domCache.loader);
        var buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
        if (buttonToReplace.length) {
          show(buttonToReplace[0], "inline-block");
        } else if (allButtonsAreHidden()) {
          hide(domCache.actions);
        }
        removeClass([domCache.popup, domCache.actions], swalClasses.loading);
        domCache.popup.removeAttribute("aria-busy");
        domCache.popup.removeAttribute("data-loading");
        domCache.confirmButton.disabled = false;
        domCache.denyButton.disabled = false;
        domCache.cancelButton.disabled = false;
      }
      function getInput$1(instance) {
        var innerParams = privateProps.innerParams.get(instance || this);
        var domCache = privateProps.domCache.get(instance || this);
        if (!domCache) {
          return null;
        }
        return getInput(domCache.content, innerParams.input);
      }
      var fixScrollbar = function fixScrollbar2() {
        if (states.previousBodyPadding !== null) {
          return;
        }
        if (document.body.scrollHeight > window.innerHeight) {
          states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
          document.body.style.paddingRight = "".concat(states.previousBodyPadding + measureScrollbar(), "px");
        }
      };
      var undoScrollbar = function undoScrollbar2() {
        if (states.previousBodyPadding !== null) {
          document.body.style.paddingRight = "".concat(states.previousBodyPadding, "px");
          states.previousBodyPadding = null;
        }
      };
      var iOSfix = function iOSfix2() {
        var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
          var offset = document.body.scrollTop;
          document.body.style.top = "".concat(offset * -1, "px");
          addClass(document.body, swalClasses.iosfix);
          lockBodyScroll();
          addBottomPaddingForTallPopups();
        }
      };
      var addBottomPaddingForTallPopups = function addBottomPaddingForTallPopups2() {
        var safari = !navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i);
        if (safari) {
          var bottomPanelHeight = 44;
          if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {
            getContainer().style.paddingBottom = "".concat(bottomPanelHeight, "px");
          }
        }
      };
      var lockBodyScroll = function lockBodyScroll2() {
        var container = getContainer();
        var preventTouchMove;
        container.ontouchstart = function(e2) {
          preventTouchMove = shouldPreventTouchMove(e2);
        };
        container.ontouchmove = function(e2) {
          if (preventTouchMove) {
            e2.preventDefault();
            e2.stopPropagation();
          }
        };
      };
      var shouldPreventTouchMove = function shouldPreventTouchMove2(event2) {
        var target = event2.target;
        var container = getContainer();
        if (isStylys(event2) || isZoom(event2)) {
          return false;
        }
        if (target === container) {
          return true;
        }
        if (!isScrollable(container) && target.tagName !== "INPUT" && !(isScrollable(getContent()) && getContent().contains(target))) {
          return true;
        }
        return false;
      };
      var isStylys = function isStylys2(event2) {
        return event2.touches && event2.touches.length && event2.touches[0].touchType === "stylus";
      };
      var isZoom = function isZoom2(event2) {
        return event2.touches && event2.touches.length > 1;
      };
      var undoIOSfix = function undoIOSfix2() {
        if (hasClass(document.body, swalClasses.iosfix)) {
          var offset = parseInt(document.body.style.top, 10);
          removeClass(document.body, swalClasses.iosfix);
          document.body.style.top = "";
          document.body.scrollTop = offset * -1;
        }
      };
      var isIE11 = function isIE112() {
        return !!window.MSInputMethodContext && !!document.documentMode;
      };
      var fixVerticalPositionIE = function fixVerticalPositionIE2() {
        var container = getContainer();
        var popup = getPopup();
        container.style.removeProperty("align-items");
        if (popup.offsetTop < 0) {
          container.style.alignItems = "flex-start";
        }
      };
      var IEfix = function IEfix2() {
        if (typeof window !== "undefined" && isIE11()) {
          fixVerticalPositionIE();
          window.addEventListener("resize", fixVerticalPositionIE);
        }
      };
      var undoIEfix = function undoIEfix2() {
        if (typeof window !== "undefined" && isIE11()) {
          window.removeEventListener("resize", fixVerticalPositionIE);
        }
      };
      var setAriaHidden = function setAriaHidden2() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function(el) {
          if (el === getContainer() || contains(el, getContainer())) {
            return;
          }
          if (el.hasAttribute("aria-hidden")) {
            el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden"));
          }
          el.setAttribute("aria-hidden", "true");
        });
      };
      var unsetAriaHidden = function unsetAriaHidden2() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function(el) {
          if (el.hasAttribute("data-previous-aria-hidden")) {
            el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden"));
            el.removeAttribute("data-previous-aria-hidden");
          } else {
            el.removeAttribute("aria-hidden");
          }
        });
      };
      var privateMethods = {
        swalPromiseResolve: /* @__PURE__ */ new WeakMap()
      };
      function removePopupAndResetState(instance, container, returnFocus, didClose) {
        if (isToast()) {
          triggerDidCloseAndDispose(instance, didClose);
        } else {
          restoreActiveElement(returnFocus).then(function() {
            return triggerDidCloseAndDispose(instance, didClose);
          });
          globalState.keydownTarget.removeEventListener("keydown", globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = false;
        }
        if (container.parentNode && !document.body.getAttribute("data-swal2-queue-step")) {
          container.parentNode.removeChild(container);
        }
        if (isModal()) {
          undoScrollbar();
          undoIOSfix();
          undoIEfix();
          unsetAriaHidden();
        }
        removeBodyClasses();
      }
      function removeBodyClasses() {
        removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
      }
      function close(resolveValue) {
        var popup = getPopup();
        if (!popup) {
          return;
        }
        resolveValue = prepareResolveValue(resolveValue);
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
          return;
        }
        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        removeClass(popup, innerParams.showClass.popup);
        addClass(popup, innerParams.hideClass.popup);
        var backdrop = getContainer();
        removeClass(backdrop, innerParams.showClass.backdrop);
        addClass(backdrop, innerParams.hideClass.backdrop);
        handlePopupAnimation(this, popup, innerParams);
        swalPromiseResolve(resolveValue);
      }
      var prepareResolveValue = function prepareResolveValue2(resolveValue) {
        if (typeof resolveValue === "undefined") {
          return {
            isConfirmed: false,
            isDenied: false,
            isDismissed: true
          };
        }
        return _extends({
          isConfirmed: false,
          isDenied: false,
          isDismissed: false
        }, resolveValue);
      };
      var handlePopupAnimation = function handlePopupAnimation2(instance, popup, innerParams) {
        var container = getContainer();
        var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
        var onClose = innerParams.onClose, onAfterClose = innerParams.onAfterClose, willClose = innerParams.willClose, didClose = innerParams.didClose;
        runDidClose(popup, willClose, onClose);
        if (animationIsSupported) {
          animatePopup(instance, popup, container, innerParams.returnFocus, didClose || onAfterClose);
        } else {
          removePopupAndResetState(instance, container, innerParams.returnFocus, didClose || onAfterClose);
        }
      };
      var runDidClose = function runDidClose2(popup, willClose, onClose) {
        if (willClose !== null && typeof willClose === "function") {
          willClose(popup);
        } else if (onClose !== null && typeof onClose === "function") {
          onClose(popup);
        }
      };
      var animatePopup = function animatePopup2(instance, popup, container, returnFocus, didClose) {
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
        popup.addEventListener(animationEndEvent, function(e2) {
          if (e2.target === popup) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
          }
        });
      };
      var triggerDidCloseAndDispose = function triggerDidCloseAndDispose2(instance, didClose) {
        setTimeout(function() {
          if (typeof didClose === "function") {
            didClose();
          }
          instance._destroy();
        });
      };
      function setButtonsDisabled(instance, buttons, disabled) {
        var domCache = privateProps.domCache.get(instance);
        buttons.forEach(function(button) {
          domCache[button].disabled = disabled;
        });
      }
      function setInputDisabled(input, disabled) {
        if (!input) {
          return false;
        }
        if (input.type === "radio") {
          var radiosContainer = input.parentNode.parentNode;
          var radios = radiosContainer.querySelectorAll("input");
          for (var i2 = 0; i2 < radios.length; i2++) {
            radios[i2].disabled = disabled;
          }
        } else {
          input.disabled = disabled;
        }
      }
      function enableButtons() {
        setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
      }
      function disableButtons() {
        setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
      }
      function enableInput() {
        return setInputDisabled(this.getInput(), false);
      }
      function disableInput() {
        return setInputDisabled(this.getInput(), true);
      }
      function showValidationMessage(error2) {
        var domCache = privateProps.domCache.get(this);
        var params = privateProps.innerParams.get(this);
        setInnerHtml(domCache.validationMessage, error2);
        domCache.validationMessage.className = swalClasses["validation-message"];
        if (params.customClass && params.customClass.validationMessage) {
          addClass(domCache.validationMessage, params.customClass.validationMessage);
        }
        show(domCache.validationMessage);
        var input = this.getInput();
        if (input) {
          input.setAttribute("aria-invalid", true);
          input.setAttribute("aria-describedBy", swalClasses["validation-message"]);
          focusInput(input);
          addClass(input, swalClasses.inputerror);
        }
      }
      function resetValidationMessage$1() {
        var domCache = privateProps.domCache.get(this);
        if (domCache.validationMessage) {
          hide(domCache.validationMessage);
        }
        var input = this.getInput();
        if (input) {
          input.removeAttribute("aria-invalid");
          input.removeAttribute("aria-describedBy");
          removeClass(input, swalClasses.inputerror);
        }
      }
      function getProgressSteps$1() {
        var domCache = privateProps.domCache.get(this);
        return domCache.progressSteps;
      }
      var Timer = /* @__PURE__ */ function() {
        function Timer2(callback, delay) {
          _classCallCheck(this, Timer2);
          this.callback = callback;
          this.remaining = delay;
          this.running = false;
          this.start();
        }
        _createClass(Timer2, [{
          key: "start",
          value: function start() {
            if (!this.running) {
              this.running = true;
              this.started = new Date();
              this.id = setTimeout(this.callback, this.remaining);
            }
            return this.remaining;
          }
        }, {
          key: "stop",
          value: function stop() {
            if (this.running) {
              this.running = false;
              clearTimeout(this.id);
              this.remaining -= new Date() - this.started;
            }
            return this.remaining;
          }
        }, {
          key: "increase",
          value: function increase(n2) {
            var running = this.running;
            if (running) {
              this.stop();
            }
            this.remaining += n2;
            if (running) {
              this.start();
            }
            return this.remaining;
          }
        }, {
          key: "getTimerLeft",
          value: function getTimerLeft2() {
            if (this.running) {
              this.stop();
              this.start();
            }
            return this.remaining;
          }
        }, {
          key: "isRunning",
          value: function isRunning() {
            return this.running;
          }
        }]);
        return Timer2;
      }();
      var defaultInputValidators = {
        email: function email(string, validationMessage) {
          return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
        },
        url: function url2(string, validationMessage) {
          return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
        }
      };
      function setDefaultInputValidators(params) {
        if (!params.inputValidator) {
          Object.keys(defaultInputValidators).forEach(function(key) {
            if (params.input === key) {
              params.inputValidator = defaultInputValidators[key];
            }
          });
        }
      }
      function validateCustomTargetElement(params) {
        if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
          warn('Target parameter is not valid, defaulting to "body"');
          params.target = "body";
        }
      }
      function setParameters(params) {
        setDefaultInputValidators(params);
        if (params.showLoaderOnConfirm && !params.preConfirm) {
          warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
        }
        params.animation = callIfFunction(params.animation);
        validateCustomTargetElement(params);
        if (typeof params.title === "string") {
          params.title = params.title.split("\n").join("<br />");
        }
        init(params);
      }
      var swalStringParams = ["swal-title", "swal-html", "swal-footer"];
      var getTemplateParams = function getTemplateParams2(params) {
        var template = typeof params.template === "string" ? document.querySelector(params.template) : params.template;
        if (!template) {
          return {};
        }
        var templateContent = template.content || template;
        showWarningsForElements(templateContent);
        var result = _extends(getSwalParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
        return result;
      };
      var getSwalParams = function getSwalParams2(templateContent) {
        var result = {};
        toArray(templateContent.querySelectorAll("swal-param")).forEach(function(param) {
          showWarningsForAttributes(param, ["name", "value"]);
          var paramName = param.getAttribute("name");
          var value = param.getAttribute("value");
          if (typeof defaultParams[paramName] === "boolean" && value === "false") {
            value = false;
          }
          if (_typeof(defaultParams[paramName]) === "object") {
            value = JSON.parse(value);
          }
          result[paramName] = value;
        });
        return result;
      };
      var getSwalButtons = function getSwalButtons2(templateContent) {
        var result = {};
        toArray(templateContent.querySelectorAll("swal-button")).forEach(function(button) {
          showWarningsForAttributes(button, ["type", "color", "aria-label"]);
          var type = button.getAttribute("type");
          result["".concat(type, "ButtonText")] = button.innerHTML;
          result["show".concat(capitalizeFirstLetter(type), "Button")] = true;
          if (button.hasAttribute("color")) {
            result["".concat(type, "ButtonColor")] = button.getAttribute("color");
          }
          if (button.hasAttribute("aria-label")) {
            result["".concat(type, "ButtonAriaLabel")] = button.getAttribute("aria-label");
          }
        });
        return result;
      };
      var getSwalImage = function getSwalImage2(templateContent) {
        var result = {};
        var image = templateContent.querySelector("swal-image");
        if (image) {
          showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
          if (image.hasAttribute("src")) {
            result.imageUrl = image.getAttribute("src");
          }
          if (image.hasAttribute("width")) {
            result.imageWidth = image.getAttribute("width");
          }
          if (image.hasAttribute("height")) {
            result.imageHeight = image.getAttribute("height");
          }
          if (image.hasAttribute("alt")) {
            result.imageAlt = image.getAttribute("alt");
          }
        }
        return result;
      };
      var getSwalIcon = function getSwalIcon2(templateContent) {
        var result = {};
        var icon = templateContent.querySelector("swal-icon");
        if (icon) {
          showWarningsForAttributes(icon, ["type", "color"]);
          if (icon.hasAttribute("type")) {
            result.icon = icon.getAttribute("type");
          }
          if (icon.hasAttribute("color")) {
            result.iconColor = icon.getAttribute("color");
          }
          result.iconHtml = icon.innerHTML;
        }
        return result;
      };
      var getSwalInput = function getSwalInput2(templateContent) {
        var result = {};
        var input = templateContent.querySelector("swal-input");
        if (input) {
          showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
          result.input = input.getAttribute("type") || "text";
          if (input.hasAttribute("label")) {
            result.inputLabel = input.getAttribute("label");
          }
          if (input.hasAttribute("placeholder")) {
            result.inputPlaceholder = input.getAttribute("placeholder");
          }
          if (input.hasAttribute("value")) {
            result.inputValue = input.getAttribute("value");
          }
        }
        var inputOptions = templateContent.querySelectorAll("swal-input-option");
        if (inputOptions.length) {
          result.inputOptions = {};
          toArray(inputOptions).forEach(function(option) {
            showWarningsForAttributes(option, ["value"]);
            var optionValue = option.getAttribute("value");
            var optionName = option.innerHTML;
            result.inputOptions[optionValue] = optionName;
          });
        }
        return result;
      };
      var getSwalStringParams = function getSwalStringParams2(templateContent, paramNames) {
        var result = {};
        for (var i2 in paramNames) {
          var paramName = paramNames[i2];
          var tag = templateContent.querySelector(paramName);
          if (tag) {
            showWarningsForAttributes(tag, []);
            result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
          }
        }
        return result;
      };
      var showWarningsForElements = function showWarningsForElements2(template) {
        var allowedElements = swalStringParams.concat(["swal-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
        toArray(template.querySelectorAll("*")).forEach(function(el) {
          if (el.parentNode !== template) {
            return;
          }
          var tagName = el.tagName.toLowerCase();
          if (allowedElements.indexOf(tagName) === -1) {
            warn("Unrecognized element <".concat(tagName, ">"));
          }
        });
      };
      var showWarningsForAttributes = function showWarningsForAttributes2(el, allowedAttributes) {
        toArray(el.attributes).forEach(function(attribute) {
          if (allowedAttributes.indexOf(attribute.name) === -1) {
            warn(['Unrecognized attribute "'.concat(attribute.name, '" on <').concat(el.tagName.toLowerCase(), ">."), "".concat(allowedAttributes.length ? "Allowed attributes are: ".concat(allowedAttributes.join(", ")) : "To set the value, use HTML within the element.")]);
          }
        });
      };
      var SHOW_CLASS_TIMEOUT = 10;
      var openPopup = function openPopup2(params) {
        var container = getContainer();
        var popup = getPopup();
        if (typeof params.willOpen === "function") {
          params.willOpen(popup);
        } else if (typeof params.onBeforeOpen === "function") {
          params.onBeforeOpen(popup);
        }
        var bodyStyles = window.getComputedStyle(document.body);
        var initialBodyOverflow = bodyStyles.overflowY;
        addClasses$1(container, popup, params);
        setTimeout(function() {
          setScrollingVisibility(container, popup);
        }, SHOW_CLASS_TIMEOUT);
        if (isModal()) {
          fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
          setAriaHidden();
        }
        if (!isToast() && !globalState.previousActiveElement) {
          globalState.previousActiveElement = document.activeElement;
        }
        runDidOpen(popup, params);
        removeClass(container, swalClasses["no-transition"]);
      };
      var runDidOpen = function runDidOpen2(popup, params) {
        if (typeof params.didOpen === "function") {
          setTimeout(function() {
            return params.didOpen(popup);
          });
        } else if (typeof params.onOpen === "function") {
          setTimeout(function() {
            return params.onOpen(popup);
          });
        }
      };
      var swalOpenAnimationFinished = function swalOpenAnimationFinished2(event2) {
        var popup = getPopup();
        if (event2.target !== popup) {
          return;
        }
        var container = getContainer();
        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished2);
        container.style.overflowY = "auto";
      };
      var setScrollingVisibility = function setScrollingVisibility2(container, popup) {
        if (animationEndEvent && hasCssAnimation(popup)) {
          container.style.overflowY = "hidden";
          popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
        } else {
          container.style.overflowY = "auto";
        }
      };
      var fixScrollContainer = function fixScrollContainer2(container, scrollbarPadding, initialBodyOverflow) {
        iOSfix();
        IEfix();
        if (scrollbarPadding && initialBodyOverflow !== "hidden") {
          fixScrollbar();
        }
        setTimeout(function() {
          container.scrollTop = 0;
        });
      };
      var addClasses$1 = function addClasses2(container, popup, params) {
        addClass(container, params.showClass.backdrop);
        popup.style.setProperty("opacity", "0", "important");
        show(popup);
        setTimeout(function() {
          addClass(popup, params.showClass.popup);
          popup.style.removeProperty("opacity");
        }, SHOW_CLASS_TIMEOUT);
        addClass([document.documentElement, document.body], swalClasses.shown);
        if (params.heightAuto && params.backdrop && !params.toast) {
          addClass([document.documentElement, document.body], swalClasses["height-auto"]);
        }
      };
      var handleInputOptionsAndValue = function handleInputOptionsAndValue2(instance, params) {
        if (params.input === "select" || params.input === "radio") {
          handleInputOptions(instance, params);
        } else if (["text", "email", "number", "tel", "textarea"].indexOf(params.input) !== -1 && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
          handleInputValue(instance, params);
        }
      };
      var getInputValue = function getInputValue2(instance, innerParams) {
        var input = instance.getInput();
        if (!input) {
          return null;
        }
        switch (innerParams.input) {
          case "checkbox":
            return getCheckboxValue(input);
          case "radio":
            return getRadioValue(input);
          case "file":
            return getFileValue(input);
          default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
      };
      var getCheckboxValue = function getCheckboxValue2(input) {
        return input.checked ? 1 : 0;
      };
      var getRadioValue = function getRadioValue2(input) {
        return input.checked ? input.value : null;
      };
      var getFileValue = function getFileValue2(input) {
        return input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
      };
      var handleInputOptions = function handleInputOptions2(instance, params) {
        var content = getContent();
        var processInputOptions = function processInputOptions2(inputOptions) {
          return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
        };
        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
          showLoading(getConfirmButton());
          asPromise(params.inputOptions).then(function(inputOptions) {
            instance.hideLoading();
            processInputOptions(inputOptions);
          });
        } else if (_typeof(params.inputOptions) === "object") {
          processInputOptions(params.inputOptions);
        } else {
          error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
        }
      };
      var handleInputValue = function handleInputValue2(instance, params) {
        var input = instance.getInput();
        hide(input);
        asPromise(params.inputValue).then(function(inputValue) {
          input.value = params.input === "number" ? parseFloat(inputValue) || 0 : "".concat(inputValue);
          show(input);
          input.focus();
          instance.hideLoading();
        })["catch"](function(err) {
          error("Error in inputValue promise: ".concat(err));
          input.value = "";
          show(input);
          input.focus();
          instance.hideLoading();
        });
      };
      var populateInputOptions = {
        select: function select(content, inputOptions, params) {
          var select2 = getChildByClass(content, swalClasses.select);
          var renderOption = function renderOption2(parent, optionLabel, optionValue) {
            var option = document.createElement("option");
            option.value = optionValue;
            setInnerHtml(option, optionLabel);
            option.selected = isSelected(optionValue, params.inputValue);
            parent.appendChild(option);
          };
          inputOptions.forEach(function(inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1];
            if (Array.isArray(optionLabel)) {
              var optgroup = document.createElement("optgroup");
              optgroup.label = optionValue;
              optgroup.disabled = false;
              select2.appendChild(optgroup);
              optionLabel.forEach(function(o2) {
                return renderOption(optgroup, o2[1], o2[0]);
              });
            } else {
              renderOption(select2, optionLabel, optionValue);
            }
          });
          select2.focus();
        },
        radio: function radio(content, inputOptions, params) {
          var radio2 = getChildByClass(content, swalClasses.radio);
          inputOptions.forEach(function(inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement("input");
            var radioLabelElement = document.createElement("label");
            radioInput.type = "radio";
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;
            if (isSelected(radioValue, params.inputValue)) {
              radioInput.checked = true;
            }
            var label = document.createElement("span");
            setInnerHtml(label, radioLabel);
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio2.appendChild(radioLabelElement);
          });
          var radios = radio2.querySelectorAll("input");
          if (radios.length) {
            radios[0].focus();
          }
        }
      };
      var formatInputOptions = function formatInputOptions2(inputOptions) {
        var result = [];
        if (typeof Map !== "undefined" && inputOptions instanceof Map) {
          inputOptions.forEach(function(value, key) {
            var valueFormatted = value;
            if (_typeof(valueFormatted) === "object") {
              valueFormatted = formatInputOptions2(valueFormatted);
            }
            result.push([key, valueFormatted]);
          });
        } else {
          Object.keys(inputOptions).forEach(function(key) {
            var valueFormatted = inputOptions[key];
            if (_typeof(valueFormatted) === "object") {
              valueFormatted = formatInputOptions2(valueFormatted);
            }
            result.push([key, valueFormatted]);
          });
        }
        return result;
      };
      var isSelected = function isSelected2(optionValue, inputValue) {
        return inputValue && inputValue.toString() === optionValue.toString();
      };
      var handleConfirmButtonClick = function handleConfirmButtonClick2(instance, innerParams) {
        instance.disableButtons();
        if (innerParams.input) {
          handleConfirmOrDenyWithInput(instance, innerParams, "confirm");
        } else {
          confirm(instance, innerParams, true);
        }
      };
      var handleDenyButtonClick = function handleDenyButtonClick2(instance, innerParams) {
        instance.disableButtons();
        if (innerParams.returnInputValueOnDeny) {
          handleConfirmOrDenyWithInput(instance, innerParams, "deny");
        } else {
          deny(instance, innerParams, false);
        }
      };
      var handleCancelButtonClick = function handleCancelButtonClick2(instance, dismissWith) {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
      };
      var handleConfirmOrDenyWithInput = function handleConfirmOrDenyWithInput2(instance, innerParams, type) {
        var inputValue = getInputValue(instance, innerParams);
        if (innerParams.inputValidator) {
          handleInputValidator(instance, innerParams, inputValue);
        } else if (!instance.getInput().checkValidity()) {
          instance.enableButtons();
          instance.showValidationMessage(innerParams.validationMessage);
        } else if (type === "deny") {
          deny(instance, innerParams, inputValue);
        } else {
          confirm(instance, innerParams, inputValue);
        }
      };
      var handleInputValidator = function handleInputValidator2(instance, innerParams, inputValue) {
        instance.disableInput();
        var validationPromise = Promise.resolve().then(function() {
          return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
        });
        validationPromise.then(function(validationMessage) {
          instance.enableButtons();
          instance.enableInput();
          if (validationMessage) {
            instance.showValidationMessage(validationMessage);
          } else {
            confirm(instance, innerParams, inputValue);
          }
        });
      };
      var deny = function deny2(instance, innerParams, value) {
        if (innerParams.showLoaderOnDeny) {
          showLoading(getDenyButton());
        }
        if (innerParams.preDeny) {
          var preDenyPromise = Promise.resolve().then(function() {
            return asPromise(innerParams.preDeny(value, innerParams.validationMessage));
          });
          preDenyPromise.then(function(preDenyValue) {
            if (preDenyValue === false) {
              instance.hideLoading();
            } else {
              instance.closePopup({
                isDenied: true,
                value: typeof preDenyValue === "undefined" ? value : preDenyValue
              });
            }
          });
        } else {
          instance.closePopup({
            isDenied: true,
            value
          });
        }
      };
      var succeedWith = function succeedWith2(instance, value) {
        instance.closePopup({
          isConfirmed: true,
          value
        });
      };
      var confirm = function confirm2(instance, innerParams, value) {
        if (innerParams.showLoaderOnConfirm) {
          showLoading();
        }
        if (innerParams.preConfirm) {
          instance.resetValidationMessage();
          var preConfirmPromise = Promise.resolve().then(function() {
            return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
          });
          preConfirmPromise.then(function(preConfirmValue) {
            if (isVisible(getValidationMessage()) || preConfirmValue === false) {
              instance.hideLoading();
            } else {
              succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
            }
          });
        } else {
          succeedWith(instance, value);
        }
      };
      var addKeydownHandler = function addKeydownHandler2(instance, globalState2, innerParams, dismissWith) {
        if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
          globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
            capture: globalState2.keydownListenerCapture
          });
          globalState2.keydownHandlerAdded = false;
        }
        if (!innerParams.toast) {
          globalState2.keydownHandler = function(e2) {
            return keydownHandler(instance, e2, dismissWith);
          };
          globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
          globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
          globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
            capture: globalState2.keydownListenerCapture
          });
          globalState2.keydownHandlerAdded = true;
        }
      };
      var setFocus = function setFocus2(innerParams, index, increment) {
        var focusableElements = getFocusableElements();
        if (focusableElements.length) {
          index = index + increment;
          if (index === focusableElements.length) {
            index = 0;
          } else if (index === -1) {
            index = focusableElements.length - 1;
          }
          return focusableElements[index].focus();
        }
        getPopup().focus();
      };
      var arrowKeysNextButton = [
        "ArrowRight",
        "ArrowDown",
        "Right",
        "Down"
      ];
      var arrowKeysPreviousButton = [
        "ArrowLeft",
        "ArrowUp",
        "Left",
        "Up"
      ];
      var escKeys = [
        "Escape",
        "Esc"
      ];
      var keydownHandler = function keydownHandler2(instance, e2, dismissWith) {
        var innerParams = privateProps.innerParams.get(instance);
        if (!innerParams) {
          return;
        }
        if (innerParams.stopKeydownPropagation) {
          e2.stopPropagation();
        }
        if (e2.key === "Enter") {
          handleEnter(instance, e2, innerParams);
        } else if (e2.key === "Tab") {
          handleTab(e2, innerParams);
        } else if ([].concat(arrowKeysNextButton, arrowKeysPreviousButton).indexOf(e2.key) !== -1) {
          handleArrows(e2.key);
        } else if (escKeys.indexOf(e2.key) !== -1) {
          handleEsc(e2, innerParams, dismissWith);
        }
      };
      var handleEnter = function handleEnter2(instance, e2, innerParams) {
        if (e2.isComposing) {
          return;
        }
        if (e2.target && instance.getInput() && e2.target.outerHTML === instance.getInput().outerHTML) {
          if (["textarea", "file"].indexOf(innerParams.input) !== -1) {
            return;
          }
          clickConfirm();
          e2.preventDefault();
        }
      };
      var handleTab = function handleTab2(e2, innerParams) {
        var targetElement = e2.target;
        var focusableElements = getFocusableElements();
        var btnIndex = -1;
        for (var i2 = 0; i2 < focusableElements.length; i2++) {
          if (targetElement === focusableElements[i2]) {
            btnIndex = i2;
            break;
          }
        }
        if (!e2.shiftKey) {
          setFocus(innerParams, btnIndex, 1);
        } else {
          setFocus(innerParams, btnIndex, -1);
        }
        e2.stopPropagation();
        e2.preventDefault();
      };
      var handleArrows = function handleArrows2(key) {
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!([confirmButton, denyButton, cancelButton].indexOf(document.activeElement) !== -1)) {
          return;
        }
        var sibling = arrowKeysNextButton.indexOf(key) !== -1 ? "nextElementSibling" : "previousElementSibling";
        var buttonToFocus = document.activeElement[sibling];
        if (buttonToFocus) {
          buttonToFocus.focus();
        }
      };
      var handleEsc = function handleEsc2(e2, innerParams, dismissWith) {
        if (callIfFunction(innerParams.allowEscapeKey)) {
          e2.preventDefault();
          dismissWith(DismissReason.esc);
        }
      };
      var handlePopupClick = function handlePopupClick2(instance, domCache, dismissWith) {
        var innerParams = privateProps.innerParams.get(instance);
        if (innerParams.toast) {
          handleToastClick(instance, domCache, dismissWith);
        } else {
          handleModalMousedown(domCache);
          handleContainerMousedown(domCache);
          handleModalClick(instance, domCache, dismissWith);
        }
      };
      var handleToastClick = function handleToastClick2(instance, domCache, dismissWith) {
        domCache.popup.onclick = function() {
          var innerParams = privateProps.innerParams.get(instance);
          if (innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.timer || innerParams.input) {
            return;
          }
          dismissWith(DismissReason.close);
        };
      };
      var ignoreOutsideClick = false;
      var handleModalMousedown = function handleModalMousedown2(domCache) {
        domCache.popup.onmousedown = function() {
          domCache.container.onmouseup = function(e2) {
            domCache.container.onmouseup = void 0;
            if (e2.target === domCache.container) {
              ignoreOutsideClick = true;
            }
          };
        };
      };
      var handleContainerMousedown = function handleContainerMousedown2(domCache) {
        domCache.container.onmousedown = function() {
          domCache.popup.onmouseup = function(e2) {
            domCache.popup.onmouseup = void 0;
            if (e2.target === domCache.popup || domCache.popup.contains(e2.target)) {
              ignoreOutsideClick = true;
            }
          };
        };
      };
      var handleModalClick = function handleModalClick2(instance, domCache, dismissWith) {
        domCache.container.onclick = function(e2) {
          var innerParams = privateProps.innerParams.get(instance);
          if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
          }
          if (e2.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(DismissReason.backdrop);
          }
        };
      };
      function _main(userParams) {
        var mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        showWarningsForParams(_extends({}, mixinParams, userParams));
        if (globalState.currentInstance) {
          globalState.currentInstance._destroy();
        }
        globalState.currentInstance = this;
        var innerParams = prepareParams(userParams, mixinParams);
        setParameters(innerParams);
        Object.freeze(innerParams);
        if (globalState.timeout) {
          globalState.timeout.stop();
          delete globalState.timeout;
        }
        clearTimeout(globalState.restoreFocusTimeout);
        var domCache = populateDomCache(this);
        render(this, innerParams);
        privateProps.innerParams.set(this, innerParams);
        return swalPromise(this, domCache, innerParams);
      }
      var prepareParams = function prepareParams2(userParams, mixinParams) {
        var templateParams = getTemplateParams(userParams);
        var params = _extends({}, defaultParams, mixinParams, templateParams, userParams);
        params.showClass = _extends({}, defaultParams.showClass, params.showClass);
        params.hideClass = _extends({}, defaultParams.hideClass, params.hideClass);
        if (userParams.animation === false) {
          params.showClass = {
            popup: "swal2-noanimation",
            backdrop: "swal2-noanimation"
          };
          params.hideClass = {};
        }
        return params;
      };
      var swalPromise = function swalPromise2(instance, domCache, innerParams) {
        return new Promise(function(resolve) {
          var dismissWith = function dismissWith2(dismiss) {
            instance.closePopup({
              isDismissed: true,
              dismiss
            });
          };
          privateMethods.swalPromiseResolve.set(instance, resolve);
          domCache.confirmButton.onclick = function() {
            return handleConfirmButtonClick(instance, innerParams);
          };
          domCache.denyButton.onclick = function() {
            return handleDenyButtonClick(instance, innerParams);
          };
          domCache.cancelButton.onclick = function() {
            return handleCancelButtonClick(instance, dismissWith);
          };
          domCache.closeButton.onclick = function() {
            return dismissWith(DismissReason.close);
          };
          handlePopupClick(instance, domCache, dismissWith);
          addKeydownHandler(instance, globalState, innerParams, dismissWith);
          handleInputOptionsAndValue(instance, innerParams);
          openPopup(innerParams);
          setupTimer(globalState, innerParams, dismissWith);
          initFocus(domCache, innerParams);
          setTimeout(function() {
            domCache.container.scrollTop = 0;
          });
        });
      };
      var populateDomCache = function populateDomCache2(instance) {
        var domCache = {
          popup: getPopup(),
          container: getContainer(),
          content: getContent(),
          actions: getActions(),
          confirmButton: getConfirmButton(),
          denyButton: getDenyButton(),
          cancelButton: getCancelButton(),
          loader: getLoader(),
          closeButton: getCloseButton(),
          validationMessage: getValidationMessage(),
          progressSteps: getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
      };
      var setupTimer = function setupTimer2(globalState$$1, innerParams, dismissWith) {
        var timerProgressBar = getTimerProgressBar();
        hide(timerProgressBar);
        if (innerParams.timer) {
          globalState$$1.timeout = new Timer(function() {
            dismissWith("timer");
            delete globalState$$1.timeout;
          }, innerParams.timer);
          if (innerParams.timerProgressBar) {
            show(timerProgressBar);
            setTimeout(function() {
              if (globalState$$1.timeout && globalState$$1.timeout.running) {
                animateTimerProgressBar(innerParams.timer);
              }
            });
          }
        }
      };
      var initFocus = function initFocus2(domCache, innerParams) {
        if (innerParams.toast) {
          return;
        }
        if (!callIfFunction(innerParams.allowEnterKey)) {
          return blurActiveElement();
        }
        if (!focusButton(domCache, innerParams)) {
          setFocus(innerParams, -1, 1);
        }
      };
      var focusButton = function focusButton2(domCache, innerParams) {
        if (innerParams.focusDeny && isVisible(domCache.denyButton)) {
          domCache.denyButton.focus();
          return true;
        }
        if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
          domCache.cancelButton.focus();
          return true;
        }
        if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
          domCache.confirmButton.focus();
          return true;
        }
        return false;
      };
      var blurActiveElement = function blurActiveElement2() {
        if (document.activeElement && typeof document.activeElement.blur === "function") {
          document.activeElement.blur();
        }
      };
      function update(params) {
        var popup = getPopup();
        var innerParams = privateProps.innerParams.get(this);
        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
          return warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
        }
        var validUpdatableParams = {};
        Object.keys(params).forEach(function(param) {
          if (Swal2.isUpdatableParameter(param)) {
            validUpdatableParams[param] = params[param];
          } else {
            warn('Invalid parameter to update: "'.concat(param, '". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\n\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md'));
          }
        });
        var updatedParams = _extends({}, innerParams, validUpdatableParams);
        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
          params: {
            value: _extends({}, this.params, params),
            writable: false,
            enumerable: true
          }
        });
      }
      function _destroy() {
        var domCache = privateProps.domCache.get(this);
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
          return;
        }
        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
          globalState.swalCloseEventFinishedCallback();
          delete globalState.swalCloseEventFinishedCallback;
        }
        if (globalState.deferDisposalTimer) {
          clearTimeout(globalState.deferDisposalTimer);
          delete globalState.deferDisposalTimer;
        }
        runDidDestroy(innerParams);
        disposeSwal(this);
      }
      var runDidDestroy = function runDidDestroy2(innerParams) {
        if (typeof innerParams.didDestroy === "function") {
          innerParams.didDestroy();
        } else if (typeof innerParams.onDestroy === "function") {
          innerParams.onDestroy();
        }
      };
      var disposeSwal = function disposeSwal2(instance) {
        delete instance.params;
        delete globalState.keydownHandler;
        delete globalState.keydownTarget;
        unsetWeakMaps(privateProps);
        unsetWeakMaps(privateMethods);
      };
      var unsetWeakMaps = function unsetWeakMaps2(obj) {
        for (var i2 in obj) {
          obj[i2] = /* @__PURE__ */ new WeakMap();
        }
      };
      var instanceMethods = /* @__PURE__ */ Object.freeze({
        hideLoading,
        disableLoading: hideLoading,
        getInput: getInput$1,
        close,
        closePopup: close,
        closeModal: close,
        closeToast: close,
        enableButtons,
        disableButtons,
        enableInput,
        disableInput,
        showValidationMessage,
        resetValidationMessage: resetValidationMessage$1,
        getProgressSteps: getProgressSteps$1,
        _main,
        update,
        _destroy
      });
      var currentInstance;
      var SweetAlert2 = /* @__PURE__ */ function() {
        function SweetAlert3() {
          _classCallCheck(this, SweetAlert3);
          if (typeof window === "undefined") {
            return;
          }
          if (typeof Promise === "undefined") {
            error("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");
          }
          currentInstance = this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var outerParams = Object.freeze(this.constructor.argsToParams(args));
          Object.defineProperties(this, {
            params: {
              value: outerParams,
              writable: false,
              enumerable: true,
              configurable: true
            }
          });
          var promise = this._main(this.params);
          privateProps.promise.set(this, promise);
        }
        _createClass(SweetAlert3, [{
          key: "then",
          value: function then(onFulfilled) {
            var promise = privateProps.promise.get(this);
            return promise.then(onFulfilled);
          }
        }, {
          key: "finally",
          value: function _finally(onFinally) {
            var promise = privateProps.promise.get(this);
            return promise["finally"](onFinally);
          }
        }]);
        return SweetAlert3;
      }();
      _extends(SweetAlert2.prototype, instanceMethods);
      _extends(SweetAlert2, staticMethods);
      Object.keys(instanceMethods).forEach(function(key) {
        SweetAlert2[key] = function() {
          if (currentInstance) {
            var _currentInstance;
            return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
          }
        };
      });
      SweetAlert2.DismissReason = DismissReason;
      SweetAlert2.version = "10.16.9";
      var Swal2 = SweetAlert2;
      Swal2["default"] = Swal2;
      return Swal2;
    });
    if (typeof exports !== "undefined" && exports.Sweetalert2) {
      exports.swal = exports.sweetAlert = exports.Swal = exports.SweetAlert = exports.Sweetalert2;
    }
    "undefined" != typeof document && function(e2, t2) {
      var n2 = e2.createElement("style");
      if (e2.getElementsByTagName("head")[0].appendChild(n2), n2.styleSheet)
        n2.styleSheet.disabled || (n2.styleSheet.cssText = t2);
      else
        try {
          n2.innerHTML = t2;
        } catch (e3) {
          n2.innerText = t2;
        }
    }(document, '.swal2-popup.swal2-toast{flex-direction:column;align-items:stretch;width:auto;padding:1.25em;overflow-y:hidden;background:#fff;box-shadow:0 0 .625em #d9d9d9}.swal2-popup.swal2-toast .swal2-header{flex-direction:row;padding:0}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:static;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;margin:0 .625em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container{padding:.625em 0 0}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{font-size:.25em}}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{flex:1;flex-basis:auto!important;align-self:stretch;width:auto;height:2.2em;height:auto;margin:0 .3125em;margin-top:.3125em;padding:0}.swal2-popup.swal2-toast .swal2-styled{margin:.125em .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(100,150,200,.5)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:flex;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-bottom-end>:first-child,.swal2-container.swal2-bottom-left>:first-child,.swal2-container.swal2-bottom-right>:first-child,.swal2-container.swal2-bottom-start>:first-child,.swal2-container.swal2-bottom>:first-child{margin-top:auto}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-no-transition{transition:none!important}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-popup{display:none;position:relative;box-sizing:border-box;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border:none;border-radius:5px;background:#fff;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-header{display:flex;flex-direction:column;align-items:center;padding:0 1.8em}.swal2-title{position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:100%;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;box-shadow:none;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#2778c4;color:#fff;font-size:1em}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#d14529;color:#fff;font-size:1em}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#757575;color:#fff;font-size:1em}.swal2-styled:focus{outline:0;box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;height:.25em;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:1.25em auto}.swal2-close{position:absolute;z-index:2;top:0;right:0;align-items:center;justify-content:center;width:1.2em;height:1.2em;padding:0;overflow:hidden;transition:color .1s ease-out;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-content{z-index:1;justify-content:center;margin:0;padding:0 1.6em;color:#545454;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em auto}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em auto;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-input[type=number]{max-width:10em}.swal2-file{background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto}.swal2-validation-message{align-items:center;justify-content:center;margin:0 -2.7em;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:0 0 1.25em;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{top:auto;right:auto;bottom:auto;left:auto;max-width:calc(100% - .625em * 2);background-color:transparent!important}body.swal2-no-backdrop .swal2-container>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-container.swal2-top{top:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-top-left,body.swal2-no-backdrop .swal2-container.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-top-end,body.swal2-no-backdrop .swal2-container.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-container.swal2-center{top:50%;left:50%;transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-left,body.swal2-no-backdrop .swal2-container.swal2-center-start{top:50%;left:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-center-end,body.swal2-no-backdrop .swal2-container.swal2-center-right{top:50%;right:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom{bottom:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-container.swal2-bottom-left,body.swal2-no-backdrop .swal2-container.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-container.swal2-bottom-end,body.swal2-no-backdrop .swal2-container.swal2-bottom-right{right:0;bottom:0}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}');
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _5.defaults(root.Object(), context, _5.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _5 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _5;
        define(function() {
          return _5;
        });
      } else if (freeModule) {
        (freeModule.exports = _5)._ = _5;
        freeExports._ = _5;
      } else {
        root._ = _5;
      }
    }).call(exports);
  }
});

// node_modules/@uppy/utils/lib/getTimeStamp.js
var require_getTimeStamp = __commonJS({
  "node_modules/@uppy/utils/lib/getTimeStamp.js"(exports, module) {
    "use strict";
    function pad(number) {
      return number < 10 ? `0${number}` : number.toString();
    }
    function getTimeStamp() {
      const date = new Date();
      const hours = pad(date.getHours());
      const minutes = pad(date.getMinutes());
      const seconds = pad(date.getSeconds());
      return `${hours}:${minutes}:${seconds}`;
    }
    module.exports = getTimeStamp;
  }
});

// node_modules/@uppy/core/lib/loggers.js
var require_loggers = __commonJS({
  "node_modules/@uppy/core/lib/loggers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.justErrorsLogger = exports.debugLogger = void 0;
    var getTimeStamp = require_getTimeStamp();
    var justErrorsLogger = {
      debug: () => {
      },
      warn: () => {
      },
      error: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
      }
    };
    exports.justErrorsLogger = justErrorsLogger;
    var debugLogger = {
      debug: function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return console.debug(`[Uppy] [${getTimeStamp()}]`, ...args);
      },
      warn: function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return console.warn(`[Uppy] [${getTimeStamp()}]`, ...args);
      },
      error: function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
      }
    };
    exports.debugLogger = debugLogger;
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i2 = size;
        while (i2--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i2 = size;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module.exports = { nanoid, customAlphabet };
  }
});

// node_modules/@transloadit/prettier-bytes/prettierBytes.js
var require_prettierBytes = __commonJS({
  "node_modules/@transloadit/prettier-bytes/prettierBytes.js"(exports, module) {
    module.exports = function prettierBytes(num) {
      if (typeof num !== "number" || isNaN(num)) {
        throw new TypeError("Expected a number, got " + typeof num);
      }
      var neg = num < 0;
      var units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      if (neg) {
        num = -num;
      }
      if (num < 1) {
        return (neg ? "-" : "") + num + " B";
      }
      var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
      num = Number(num / Math.pow(1024, exponent));
      var unit = units[exponent];
      if (num >= 10 || num % 1 === 0) {
        return (neg ? "-" : "") + num.toFixed(0) + " " + unit;
      } else {
        return (neg ? "-" : "") + num.toFixed(1) + " " + unit;
      }
    };
  }
});

// node_modules/wildcard/index.js
var require_wildcard = __commonJS({
  "node_modules/wildcard/index.js"(exports, module) {
    "use strict";
    function WildcardMatcher(text, separator) {
      this.text = text = text || "";
      this.hasWild = ~text.indexOf("*");
      this.separator = separator;
      this.parts = text.split(separator);
    }
    WildcardMatcher.prototype.match = function(input) {
      var matches = true;
      var parts = this.parts;
      var ii;
      var partsCount = parts.length;
      var testParts;
      if (typeof input == "string" || input instanceof String) {
        if (!this.hasWild && this.text != input) {
          matches = false;
        } else {
          testParts = (input || "").split(this.separator);
          for (ii = 0; matches && ii < partsCount; ii++) {
            if (parts[ii] === "*") {
              continue;
            } else if (ii < testParts.length) {
              matches = parts[ii] === testParts[ii];
            } else {
              matches = false;
            }
          }
          matches = matches && testParts;
        }
      } else if (typeof input.splice == "function") {
        matches = [];
        for (ii = input.length; ii--; ) {
          if (this.match(input[ii])) {
            matches[matches.length] = input[ii];
          }
        }
      } else if (typeof input == "object") {
        matches = {};
        for (var key in input) {
          if (this.match(key)) {
            matches[key] = input[key];
          }
        }
      }
      return matches;
    };
    module.exports = function(text, test, separator) {
      var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
      if (typeof test != "undefined") {
        return matcher.match(test);
      }
      return matcher;
    };
  }
});

// node_modules/mime-match/index.js
var require_mime_match = __commonJS({
  "node_modules/mime-match/index.js"(exports, module) {
    var wildcard = require_wildcard();
    var reMimePartSplit = /[\/\+\.]/;
    module.exports = function(target, pattern) {
      function test(pattern2) {
        var result = wildcard(pattern2, target, reMimePartSplit);
        return result && result.length >= 2;
      }
      return pattern ? test(pattern.split(";")[0]) : test;
    };
  }
});

// node_modules/@uppy/core/lib/Restricter.js
var require_Restricter = __commonJS({
  "node_modules/@uppy/core/lib/Restricter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultOptions = exports.RestrictionError = exports.Restricter = void 0;
    var prettierBytes = require_prettierBytes();
    var match = require_mime_match();
    var defaultOptions = {
      maxFileSize: null,
      minFileSize: null,
      maxTotalFileSize: null,
      maxNumberOfFiles: null,
      minNumberOfFiles: null,
      allowedFileTypes: null,
      requiredMetaFields: []
    };
    exports.defaultOptions = defaultOptions;
    var RestrictionError = class extends Error {
      constructor() {
        super(...arguments);
        this.isRestriction = true;
      }
    };
    exports.RestrictionError = RestrictionError;
    if (typeof AggregateError === "undefined") {
      globalThis.AggregateError = class AggregateError extends Error {
        constructor(errors, message) {
          super(message);
          this.errors = errors;
        }
      };
    }
    var Restricter = class {
      constructor(getOpts, i18n) {
        this.i18n = i18n;
        this.getOpts = () => {
          const opts = getOpts();
          if (opts.restrictions.allowedFileTypes != null && !Array.isArray(opts.restrictions.allowedFileTypes)) {
            throw new TypeError("`restrictions.allowedFileTypes` must be an array");
          }
          return opts;
        };
      }
      validate(file, files) {
        const {
          maxFileSize: maxFileSize2,
          minFileSize,
          maxTotalFileSize,
          maxNumberOfFiles,
          allowedFileTypes
        } = this.getOpts().restrictions;
        if (maxNumberOfFiles) {
          const nonGhostFiles = files.filter((f2) => !f2.isGhost);
          if (nonGhostFiles.length + 1 > maxNumberOfFiles) {
            throw new RestrictionError(`${this.i18n("youCanOnlyUploadX", {
              smart_count: maxNumberOfFiles
            })}`);
          }
        }
        if (allowedFileTypes) {
          const isCorrectFileType = allowedFileTypes.some((type) => {
            if (type.includes("/")) {
              if (!file.type)
                return false;
              return match(file.type.replace(/;.*?$/, ""), type);
            }
            if (type[0] === "." && file.extension) {
              return file.extension.toLowerCase() === type.slice(1).toLowerCase();
            }
            return false;
          });
          if (!isCorrectFileType) {
            const allowedFileTypesString = allowedFileTypes.join(", ");
            throw new RestrictionError(this.i18n("youCanOnlyUploadFileTypes", {
              types: allowedFileTypesString
            }));
          }
        }
        if (maxTotalFileSize && file.size != null) {
          const totalFilesSize = files.reduce((total, f2) => total + f2.size, file.size);
          if (totalFilesSize > maxTotalFileSize) {
            throw new RestrictionError(this.i18n("exceedsSize", {
              size: prettierBytes(maxTotalFileSize),
              file: file.name
            }));
          }
        }
        if (maxFileSize2 && file.size != null && file.size > maxFileSize2) {
          throw new RestrictionError(this.i18n("exceedsSize", {
            size: prettierBytes(maxFileSize2),
            file: file.name
          }));
        }
        if (minFileSize && file.size != null && file.size < minFileSize) {
          throw new RestrictionError(this.i18n("inferiorSize", {
            size: prettierBytes(minFileSize)
          }));
        }
      }
      validateMinNumberOfFiles(files) {
        const {
          minNumberOfFiles
        } = this.getOpts().restrictions;
        if (Object.keys(files).length < minNumberOfFiles) {
          throw new RestrictionError(this.i18n("youHaveToAtLeastSelectX", {
            smart_count: minNumberOfFiles
          }));
        }
      }
      getMissingRequiredMetaFields(file) {
        const error = new RestrictionError(this.i18n("missingRequiredMetaFieldOnFile", {
          fileName: file.name
        }));
        const {
          requiredMetaFields
        } = this.getOpts().restrictions;
        const own = Object.prototype.hasOwnProperty;
        const missingFields = [];
        for (const field of requiredMetaFields) {
          if (!own.call(file.meta, field) || file.meta[field] === "") {
            missingFields.push(field);
          }
        }
        return {
          missingFields,
          error
        };
      }
    };
    exports.Restricter = Restricter;
  }
});

// node_modules/@uppy/utils/lib/hasProperty.js
var require_hasProperty = __commonJS({
  "node_modules/@uppy/utils/lib/hasProperty.js"(exports, module) {
    "use strict";
    function has(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    module.exports = has;
  }
});

// node_modules/@uppy/utils/lib/Translator.js
var require_Translator = __commonJS({
  "node_modules/@uppy/utils/lib/Translator.js"(exports, module) {
    "use strict";
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var has = require_hasProperty();
    function insertReplacement(source, rx, replacement) {
      const newParts = [];
      source.forEach((chunk) => {
        if (typeof chunk !== "string") {
          return newParts.push(chunk);
        }
        return rx[Symbol.split](chunk).forEach((raw, i2, list) => {
          if (raw !== "") {
            newParts.push(raw);
          }
          if (i2 < list.length - 1) {
            newParts.push(replacement);
          }
        });
      });
      return newParts;
    }
    function interpolate(phrase, options) {
      const dollarRegex = /\$/g;
      const dollarBillsYall = "$$$$";
      let interpolated = [phrase];
      if (options == null)
        return interpolated;
      for (const arg of Object.keys(options)) {
        if (arg !== "_") {
          let replacement = options[arg];
          if (typeof replacement === "string") {
            replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
          }
          interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, "g"), replacement);
        }
      }
      return interpolated;
    }
    var _apply = /* @__PURE__ */ _classPrivateFieldLooseKey("apply");
    var Translator = class {
      constructor(locales) {
        Object.defineProperty(this, _apply, {
          value: _apply2
        });
        this.locale = {
          strings: {},
          pluralize(n2) {
            if (n2 === 1) {
              return 0;
            }
            return 1;
          }
        };
        if (Array.isArray(locales)) {
          locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);
        } else {
          _classPrivateFieldLooseBase(this, _apply)[_apply](locales);
        }
      }
      translate(key, options) {
        return this.translateArray(key, options).join("");
      }
      translateArray(key, options) {
        if (!has(this.locale.strings, key)) {
          throw new Error(`missing string: ${key}`);
        }
        const string = this.locale.strings[key];
        const hasPluralForms = typeof string === "object";
        if (hasPluralForms) {
          if (options && typeof options.smart_count !== "undefined") {
            const plural = this.locale.pluralize(options.smart_count);
            return interpolate(string[plural], options);
          }
          throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
        }
        return interpolate(string, options);
      }
    };
    function _apply2(locale) {
      if (!(locale != null && locale.strings)) {
        return;
      }
      const prevLocale = this.locale;
      this.locale = {
        ...prevLocale,
        strings: {
          ...prevLocale.strings,
          ...locale.strings
        }
      };
      this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
    }
    module.exports = Translator;
  }
});

// node_modules/namespace-emitter/index.js
var require_namespace_emitter = __commonJS({
  "node_modules/namespace-emitter/index.js"(exports, module) {
    module.exports = function createNamespaceEmitter() {
      var emitter = {};
      var _fns = emitter._fns = {};
      emitter.emit = function emit(event2, arg1, arg2, arg3, arg4, arg5, arg6) {
        var toEmit = getListeners(event2);
        if (toEmit.length) {
          emitAll(event2, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6]);
        }
      };
      emitter.on = function on(event2, fn) {
        if (!_fns[event2]) {
          _fns[event2] = [];
        }
        _fns[event2].push(fn);
      };
      emitter.once = function once(event2, fn) {
        function one() {
          fn.apply(this, arguments);
          emitter.off(event2, one);
        }
        this.on(event2, one);
      };
      emitter.off = function off(event2, fn) {
        var keep = [];
        if (event2 && fn) {
          var fns = this._fns[event2];
          var i2 = 0;
          var l2 = fns ? fns.length : 0;
          for (i2; i2 < l2; i2++) {
            if (fns[i2] !== fn) {
              keep.push(fns[i2]);
            }
          }
        }
        keep.length ? this._fns[event2] = keep : delete this._fns[event2];
      };
      function getListeners(e2) {
        var out = _fns[e2] ? _fns[e2] : [];
        var idx = e2.indexOf(":");
        var args = idx === -1 ? [e2] : [e2.substring(0, idx), e2.substring(idx + 1)];
        var keys = Object.keys(_fns);
        var i2 = 0;
        var l2 = keys.length;
        for (i2; i2 < l2; i2++) {
          var key = keys[i2];
          if (key === "*") {
            out = out.concat(_fns[key]);
          }
          if (args.length === 2 && args[0] === key) {
            out = out.concat(_fns[key]);
            break;
          }
        }
        return out;
      }
      function emitAll(e2, fns, args) {
        var i2 = 0;
        var l2 = fns.length;
        for (i2; i2 < l2; i2++) {
          if (!fns[i2])
            break;
          fns[i2].event = e2;
          fns[i2].apply(fns[i2], args);
        }
      }
      return emitter;
    };
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/@uppy/store-default/lib/index.js
var require_lib = __commonJS({
  "node_modules/@uppy/store-default/lib/index.js"(exports, module) {
    "use strict";
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var packageJson = {
      "version": "2.1.1"
    };
    var _publish = /* @__PURE__ */ _classPrivateFieldLooseKey("publish");
    var DefaultStore = class {
      constructor() {
        Object.defineProperty(this, _publish, {
          value: _publish2
        });
        this.state = {};
        this.callbacks = [];
      }
      getState() {
        return this.state;
      }
      setState(patch) {
        const prevState = {
          ...this.state
        };
        const nextState = {
          ...this.state,
          ...patch
        };
        this.state = nextState;
        _classPrivateFieldLooseBase(this, _publish)[_publish](prevState, nextState, patch);
      }
      subscribe(listener) {
        this.callbacks.push(listener);
        return () => {
          this.callbacks.splice(this.callbacks.indexOf(listener), 1);
        };
      }
    };
    function _publish2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this.callbacks.forEach((listener) => {
        listener(...args);
      });
    }
    DefaultStore.VERSION = packageJson.version;
    function defaultStore() {
      return new DefaultStore();
    }
    module.exports = defaultStore;
  }
});

// node_modules/@uppy/utils/lib/getFileNameAndExtension.js
var require_getFileNameAndExtension = __commonJS({
  "node_modules/@uppy/utils/lib/getFileNameAndExtension.js"(exports, module) {
    "use strict";
    function getFileNameAndExtension(fullFileName) {
      const lastDot = fullFileName.lastIndexOf(".");
      if (lastDot === -1 || lastDot === fullFileName.length - 1) {
        return {
          name: fullFileName,
          extension: void 0
        };
      }
      return {
        name: fullFileName.slice(0, lastDot),
        extension: fullFileName.slice(lastDot + 1)
      };
    }
    module.exports = getFileNameAndExtension;
  }
});

// node_modules/@uppy/utils/lib/mimeTypes.js
var require_mimeTypes = __commonJS({
  "node_modules/@uppy/utils/lib/mimeTypes.js"(exports, module) {
    "use strict";
    module.exports = {
      md: "text/markdown",
      markdown: "text/markdown",
      mp4: "video/mp4",
      mp3: "audio/mp3",
      svg: "image/svg+xml",
      jpg: "image/jpeg",
      png: "image/png",
      gif: "image/gif",
      heic: "image/heic",
      heif: "image/heif",
      yaml: "text/yaml",
      yml: "text/yaml",
      csv: "text/csv",
      tsv: "text/tab-separated-values",
      tab: "text/tab-separated-values",
      avi: "video/x-msvideo",
      mks: "video/x-matroska",
      mkv: "video/x-matroska",
      mov: "video/quicktime",
      dicom: "application/dicom",
      doc: "application/msword",
      docm: "application/vnd.ms-word.document.macroenabled.12",
      docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      dot: "application/msword",
      dotm: "application/vnd.ms-word.template.macroenabled.12",
      dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
      xla: "application/vnd.ms-excel",
      xlam: "application/vnd.ms-excel.addin.macroenabled.12",
      xlc: "application/vnd.ms-excel",
      xlf: "application/x-xliff+xml",
      xlm: "application/vnd.ms-excel",
      xls: "application/vnd.ms-excel",
      xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
      xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      xlt: "application/vnd.ms-excel",
      xltm: "application/vnd.ms-excel.template.macroenabled.12",
      xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
      xlw: "application/vnd.ms-excel",
      txt: "text/plain",
      text: "text/plain",
      conf: "text/plain",
      log: "text/plain",
      pdf: "application/pdf",
      zip: "application/zip",
      "7z": "application/x-7z-compressed",
      rar: "application/x-rar-compressed",
      tar: "application/x-tar",
      gz: "application/gzip",
      dmg: "application/x-apple-diskimage"
    };
  }
});

// node_modules/@uppy/utils/lib/getFileType.js
var require_getFileType = __commonJS({
  "node_modules/@uppy/utils/lib/getFileType.js"(exports, module) {
    "use strict";
    var getFileNameAndExtension = require_getFileNameAndExtension();
    var mimeTypes = require_mimeTypes();
    function getFileType(file) {
      var _getFileNameAndExtens;
      if (file.type)
        return file.type;
      const fileExtension = file.name ? (_getFileNameAndExtens = getFileNameAndExtension(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;
      if (fileExtension && fileExtension in mimeTypes) {
        return mimeTypes[fileExtension];
      }
      return "application/octet-stream";
    }
    module.exports = getFileType;
  }
});

// node_modules/@uppy/utils/lib/generateFileID.js
var require_generateFileID = __commonJS({
  "node_modules/@uppy/utils/lib/generateFileID.js"(exports, module) {
    "use strict";
    function encodeCharacter(character) {
      return character.charCodeAt(0).toString(32);
    }
    function encodeFilename(name) {
      let suffix = "";
      return name.replace(/[^A-Z0-9]/ig, (character) => {
        suffix += `-${encodeCharacter(character)}`;
        return "/";
      }) + suffix;
    }
    function generateFileID(file) {
      let id = "uppy";
      if (typeof file.name === "string") {
        id += `-${encodeFilename(file.name.toLowerCase())}`;
      }
      if (file.type !== void 0) {
        id += `-${file.type}`;
      }
      if (file.meta && typeof file.meta.relativePath === "string") {
        id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
      }
      if (file.data.size !== void 0) {
        id += `-${file.data.size}`;
      }
      if (file.data.lastModified !== void 0) {
        id += `-${file.data.lastModified}`;
      }
      return id;
    }
    module.exports = generateFileID;
  }
});

// node_modules/@uppy/core/lib/supportsUploadProgress.js
var require_supportsUploadProgress = __commonJS({
  "node_modules/@uppy/core/lib/supportsUploadProgress.js"(exports, module) {
    "use strict";
    function supportsUploadProgress(userAgent) {
      if (userAgent == null && typeof navigator !== "undefined") {
        userAgent = navigator.userAgent;
      }
      if (!userAgent)
        return true;
      const m2 = /Edge\/(\d+\.\d+)/.exec(userAgent);
      if (!m2)
        return true;
      const edgeVersion = m2[1];
      let [major, minor] = edgeVersion.split(".");
      major = parseInt(major, 10);
      minor = parseInt(minor, 10);
      if (major < 15 || major === 15 && minor < 15063) {
        return true;
      }
      if (major > 18 || major === 18 && minor >= 18218) {
        return true;
      }
      return false;
    }
    module.exports = supportsUploadProgress;
  }
});

// node_modules/@uppy/core/lib/getFileName.js
var require_getFileName = __commonJS({
  "node_modules/@uppy/core/lib/getFileName.js"(exports, module) {
    "use strict";
    function getFileName(fileType, fileDescriptor) {
      if (fileDescriptor.name) {
        return fileDescriptor.name;
      }
      if (fileType.split("/")[0] === "image") {
        return `${fileType.split("/")[0]}.${fileType.split("/")[1]}`;
      }
      return "noname";
    }
    module.exports = getFileName;
  }
});

// node_modules/@uppy/core/lib/locale.js
var require_locale = __commonJS({
  "node_modules/@uppy/core/lib/locale.js"(exports, module) {
    "use strict";
    module.exports = {
      strings: {
        addBulkFilesFailed: {
          0: "Failed to add %{smart_count} file due to an internal error",
          1: "Failed to add %{smart_count} files due to internal errors"
        },
        youCanOnlyUploadX: {
          0: "You can only upload %{smart_count} file",
          1: "You can only upload %{smart_count} files"
        },
        youHaveToAtLeastSelectX: {
          0: "You have to select at least %{smart_count} file",
          1: "You have to select at least %{smart_count} files"
        },
        exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
        missingRequiredMetaField: "Missing required meta fields",
        missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
        inferiorSize: "This file is smaller than the allowed size of %{size}",
        youCanOnlyUploadFileTypes: "You can only upload: %{types}",
        noMoreFilesAllowed: "Cannot add more files",
        noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
        companionError: "Connection with Companion failed",
        authAborted: "Authentication aborted",
        companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
        failedToUpload: "Failed to upload %{file}",
        noInternetConnection: "No Internet connection",
        connectedToInternet: "Connected to the Internet",
        noFilesFound: "You have no files or folders here",
        selectX: {
          0: "Select %{smart_count}",
          1: "Select %{smart_count}"
        },
        allFilesFromFolderNamed: "All files from folder %{name}",
        openFolderNamed: "Open folder %{name}",
        cancel: "Cancel",
        logOut: "Log out",
        filter: "Filter",
        resetFilter: "Reset filter",
        loading: "Loading...",
        authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
        authenticateWith: "Connect to %{pluginName}",
        signInWithGoogle: "Sign in with Google",
        searchImages: "Search for images",
        enterTextToSearch: "Enter text to search for images",
        search: "Search",
        emptyFolderAdded: "No files were added from empty folder",
        folderAlreadyAdded: 'The folder "%{folder}" was already added',
        folderAdded: {
          0: "Added %{smart_count} file from %{folder}",
          1: "Added %{smart_count} files from %{folder}"
        }
      }
    };
  }
});

// node_modules/@uppy/core/lib/Uppy.js
var require_Uppy = __commonJS({
  "node_modules/@uppy/core/lib/Uppy.js"(exports, module) {
    "use strict";
    var _nonSecure = require_non_secure();
    var _loggers = require_loggers();
    var _Restricter = require_Restricter();
    var _Symbol$for;
    var _Symbol$for2;
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var Translator = require_Translator();
    var ee = require_namespace_emitter();
    var throttle = require_lodash2();
    var DefaultStore = require_lib();
    var getFileType = require_getFileType();
    var getFileNameAndExtension = require_getFileNameAndExtension();
    var generateFileID = require_generateFileID();
    var supportsUploadProgress = require_supportsUploadProgress();
    var getFileName = require_getFileName();
    var packageJson = {
      "version": "2.3.4"
    };
    var locale = require_locale();
    var _plugins = /* @__PURE__ */ _classPrivateFieldLooseKey("plugins");
    var _restricter = /* @__PURE__ */ _classPrivateFieldLooseKey("restricter");
    var _storeUnsubscribe = /* @__PURE__ */ _classPrivateFieldLooseKey("storeUnsubscribe");
    var _emitter = /* @__PURE__ */ _classPrivateFieldLooseKey("emitter");
    var _preProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey("preProcessors");
    var _uploaders = /* @__PURE__ */ _classPrivateFieldLooseKey("uploaders");
    var _postProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey("postProcessors");
    var _informAndEmit = /* @__PURE__ */ _classPrivateFieldLooseKey("informAndEmit");
    var _checkRequiredMetaFieldsOnFile = /* @__PURE__ */ _classPrivateFieldLooseKey("checkRequiredMetaFieldsOnFile");
    var _checkRequiredMetaFields = /* @__PURE__ */ _classPrivateFieldLooseKey("checkRequiredMetaFields");
    var _assertNewUploadAllowed = /* @__PURE__ */ _classPrivateFieldLooseKey("assertNewUploadAllowed");
    var _checkAndCreateFileStateObject = /* @__PURE__ */ _classPrivateFieldLooseKey("checkAndCreateFileStateObject");
    var _startIfAutoProceed = /* @__PURE__ */ _classPrivateFieldLooseKey("startIfAutoProceed");
    var _addListeners = /* @__PURE__ */ _classPrivateFieldLooseKey("addListeners");
    var _updateOnlineStatus = /* @__PURE__ */ _classPrivateFieldLooseKey("updateOnlineStatus");
    var _createUpload = /* @__PURE__ */ _classPrivateFieldLooseKey("createUpload");
    var _getUpload = /* @__PURE__ */ _classPrivateFieldLooseKey("getUpload");
    var _removeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey("removeUpload");
    var _runUpload = /* @__PURE__ */ _classPrivateFieldLooseKey("runUpload");
    _Symbol$for = Symbol.for("uppy test: getPlugins");
    _Symbol$for2 = Symbol.for("uppy test: createUpload");
    var Uppy2 = class {
      constructor(_opts) {
        Object.defineProperty(this, _runUpload, {
          value: _runUpload2
        });
        Object.defineProperty(this, _removeUpload, {
          value: _removeUpload2
        });
        Object.defineProperty(this, _getUpload, {
          value: _getUpload2
        });
        Object.defineProperty(this, _createUpload, {
          value: _createUpload2
        });
        Object.defineProperty(this, _addListeners, {
          value: _addListeners2
        });
        Object.defineProperty(this, _startIfAutoProceed, {
          value: _startIfAutoProceed2
        });
        Object.defineProperty(this, _checkAndCreateFileStateObject, {
          value: _checkAndCreateFileStateObject2
        });
        Object.defineProperty(this, _assertNewUploadAllowed, {
          value: _assertNewUploadAllowed2
        });
        Object.defineProperty(this, _checkRequiredMetaFields, {
          value: _checkRequiredMetaFields2
        });
        Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
          value: _checkRequiredMetaFieldsOnFile2
        });
        Object.defineProperty(this, _informAndEmit, {
          value: _informAndEmit2
        });
        Object.defineProperty(this, _plugins, {
          writable: true,
          value: /* @__PURE__ */ Object.create(null)
        });
        Object.defineProperty(this, _restricter, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _storeUnsubscribe, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _emitter, {
          writable: true,
          value: ee()
        });
        Object.defineProperty(this, _preProcessors, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        Object.defineProperty(this, _uploaders, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        Object.defineProperty(this, _postProcessors, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        Object.defineProperty(this, _updateOnlineStatus, {
          writable: true,
          value: this.updateOnlineStatus.bind(this)
        });
        this.defaultLocale = locale;
        const defaultOptions = {
          id: "uppy",
          autoProceed: false,
          allowMultipleUploads: true,
          allowMultipleUploadBatches: true,
          debug: false,
          restrictions: _Restricter.defaultOptions,
          meta: {},
          onBeforeFileAdded: (currentFile) => currentFile,
          onBeforeUpload: (files) => files,
          store: DefaultStore(),
          logger: _loggers.justErrorsLogger,
          infoTimeout: 5e3
        };
        this.opts = {
          ...defaultOptions,
          ..._opts,
          restrictions: {
            ...defaultOptions.restrictions,
            ..._opts && _opts.restrictions
          }
        };
        if (_opts && _opts.logger && _opts.debug) {
          this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning");
        } else if (_opts && _opts.debug) {
          this.opts.logger = _loggers.debugLogger;
        }
        this.log(`Using Core v${this.constructor.VERSION}`);
        this.i18nInit();
        this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
          leading: true,
          trailing: true
        });
        this.store = this.opts.store;
        this.setState({
          plugins: {},
          files: {},
          currentUploads: {},
          allowNewUpload: true,
          capabilities: {
            uploadProgress: supportsUploadProgress(),
            individualCancellation: true,
            resumableUploads: false
          },
          totalProgress: 0,
          meta: {
            ...this.opts.meta
          },
          info: [],
          recoveredState: null
        });
        _classPrivateFieldLooseBase(this, _restricter)[_restricter] = new _Restricter.Restricter(() => this.opts, this.i18n);
        _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {
          this.emit("state-update", prevState, nextState, patch);
          this.updateAll(nextState);
        });
        if (this.opts.debug && typeof window !== "undefined") {
          window[this.opts.id] = this;
        }
        _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();
      }
      emit(event2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event2, ...args);
      }
      on(event2, callback) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event2, callback);
        return this;
      }
      once(event2, callback) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event2, callback);
        return this;
      }
      off(event2, callback) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event2, callback);
        return this;
      }
      updateAll(state) {
        this.iteratePlugins((plugin) => {
          plugin.update(state);
        });
      }
      setState(patch) {
        this.store.setState(patch);
      }
      getState() {
        return this.store.getState();
      }
      get state() {
        return this.getState();
      }
      setFileState(fileID, state) {
        if (!this.getState().files[fileID]) {
          throw new Error(`Can\u2019t set state for ${fileID} (the file could have been removed)`);
        }
        this.setState({
          files: {
            ...this.getState().files,
            [fileID]: {
              ...this.getState().files[fileID],
              ...state
            }
          }
        });
      }
      i18nInit() {
        const translator = new Translator([this.defaultLocale, this.opts.locale]);
        this.i18n = translator.translate.bind(translator);
        this.i18nArray = translator.translateArray.bind(translator);
        this.locale = translator.locale;
      }
      setOptions(newOpts) {
        this.opts = {
          ...this.opts,
          ...newOpts,
          restrictions: {
            ...this.opts.restrictions,
            ...newOpts && newOpts.restrictions
          }
        };
        if (newOpts.meta) {
          this.setMeta(newOpts.meta);
        }
        this.i18nInit();
        if (newOpts.locale) {
          this.iteratePlugins((plugin) => {
            plugin.setOptions();
          });
        }
        this.setState();
      }
      resetProgress() {
        const defaultProgress = {
          percentage: 0,
          bytesUploaded: 0,
          uploadComplete: false,
          uploadStarted: null
        };
        const files = {
          ...this.getState().files
        };
        const updatedFiles = {};
        Object.keys(files).forEach((fileID) => {
          const updatedFile = {
            ...files[fileID]
          };
          updatedFile.progress = {
            ...updatedFile.progress,
            ...defaultProgress
          };
          updatedFiles[fileID] = updatedFile;
        });
        this.setState({
          files: updatedFiles,
          totalProgress: 0
        });
        this.emit("reset-progress");
      }
      addPreProcessor(fn) {
        _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);
      }
      removePreProcessor(fn) {
        return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);
      }
      addPostProcessor(fn) {
        _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);
      }
      removePostProcessor(fn) {
        return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);
      }
      addUploader(fn) {
        _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);
      }
      removeUploader(fn) {
        return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);
      }
      setMeta(data) {
        const updatedMeta = {
          ...this.getState().meta,
          ...data
        };
        const updatedFiles = {
          ...this.getState().files
        };
        Object.keys(updatedFiles).forEach((fileID) => {
          updatedFiles[fileID] = {
            ...updatedFiles[fileID],
            meta: {
              ...updatedFiles[fileID].meta,
              ...data
            }
          };
        });
        this.log("Adding metadata:");
        this.log(data);
        this.setState({
          meta: updatedMeta,
          files: updatedFiles
        });
      }
      setFileMeta(fileID, data) {
        const updatedFiles = {
          ...this.getState().files
        };
        if (!updatedFiles[fileID]) {
          this.log("Was trying to set metadata for a file that has been removed: ", fileID);
          return;
        }
        const newMeta = {
          ...updatedFiles[fileID].meta,
          ...data
        };
        updatedFiles[fileID] = {
          ...updatedFiles[fileID],
          meta: newMeta
        };
        this.setState({
          files: updatedFiles
        });
      }
      getFile(fileID) {
        return this.getState().files[fileID];
      }
      getFiles() {
        const {
          files
        } = this.getState();
        return Object.values(files);
      }
      getObjectOfFilesPerState() {
        const {
          files: filesObject,
          totalProgress,
          error
        } = this.getState();
        const files = Object.values(filesObject);
        const inProgressFiles = files.filter((_ref) => {
          let {
            progress
          } = _ref;
          return !progress.uploadComplete && progress.uploadStarted;
        });
        const newFiles = files.filter((file) => !file.progress.uploadStarted);
        const startedFiles = files.filter((file) => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess);
        const uploadStartedFiles = files.filter((file) => file.progress.uploadStarted);
        const pausedFiles = files.filter((file) => file.isPaused);
        const completeFiles = files.filter((file) => file.progress.uploadComplete);
        const erroredFiles = files.filter((file) => file.error);
        const inProgressNotPausedFiles = inProgressFiles.filter((file) => !file.isPaused);
        const processingFiles = files.filter((file) => file.progress.preprocess || file.progress.postprocess);
        return {
          newFiles,
          startedFiles,
          uploadStartedFiles,
          pausedFiles,
          completeFiles,
          erroredFiles,
          inProgressFiles,
          inProgressNotPausedFiles,
          processingFiles,
          isUploadStarted: uploadStartedFiles.length > 0,
          isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,
          isAllErrored: !!error && erroredFiles.length === files.length,
          isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,
          isUploadInProgress: inProgressFiles.length > 0,
          isSomeGhost: files.some((file) => file.isGhost)
        };
      }
      validateRestrictions(file, files) {
        if (files === void 0) {
          files = this.getFiles();
        }
        try {
          _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(file, files);
          return {
            result: true
          };
        } catch (err) {
          return {
            result: false,
            reason: err.message
          };
        }
      }
      checkIfFileAlreadyExists(fileID) {
        const {
          files
        } = this.getState();
        if (files[fileID] && !files[fileID].isGhost) {
          return true;
        }
        return false;
      }
      addFile(file) {
        _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);
        const {
          files
        } = this.getState();
        let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file);
        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = {
            ...files[newFile.id],
            data: file.data,
            isGhost: false
          };
          this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
        }
        this.setState({
          files: {
            ...files,
            [newFile.id]: newFile
          }
        });
        this.emit("file-added", newFile);
        this.emit("files-added", [newFile]);
        this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);
        _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();
        return newFile.id;
      }
      addFiles(fileDescriptors) {
        _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
        const files = {
          ...this.getState().files
        };
        const newFiles = [];
        const errors = [];
        for (let i2 = 0; i2 < fileDescriptors.length; i2++) {
          try {
            let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i2]);
            if (files[newFile.id] && files[newFile.id].isGhost) {
              newFile = {
                ...files[newFile.id],
                data: fileDescriptors[i2].data,
                isGhost: false
              };
              this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
            }
            files[newFile.id] = newFile;
            newFiles.push(newFile);
          } catch (err) {
            if (!err.isRestriction) {
              errors.push(err);
            }
          }
        }
        this.setState({
          files
        });
        newFiles.forEach((newFile) => {
          this.emit("file-added", newFile);
        });
        this.emit("files-added", newFiles);
        if (newFiles.length > 5) {
          this.log(`Added batch of ${newFiles.length} files`);
        } else {
          Object.keys(newFiles).forEach((fileID) => {
            this.log(`Added file: ${newFiles[fileID].name}
 id: ${newFiles[fileID].id}
 type: ${newFiles[fileID].type}`);
          });
        }
        if (newFiles.length > 0) {
          _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();
        }
        if (errors.length > 0) {
          let message = "Multiple errors occurred while adding files:\n";
          errors.forEach((subError) => {
            message += `
 * ${subError.message}`;
          });
          this.info({
            message: this.i18n("addBulkFilesFailed", {
              smart_count: errors.length
            }),
            details: message
          }, "error", this.opts.infoTimeout);
          if (typeof AggregateError === "function") {
            throw new AggregateError(errors, message);
          } else {
            const err = new Error(message);
            err.errors = errors;
            throw err;
          }
        }
      }
      removeFiles(fileIDs, reason) {
        const {
          files,
          currentUploads
        } = this.getState();
        const updatedFiles = {
          ...files
        };
        const updatedUploads = {
          ...currentUploads
        };
        const removedFiles = /* @__PURE__ */ Object.create(null);
        fileIDs.forEach((fileID) => {
          if (files[fileID]) {
            removedFiles[fileID] = files[fileID];
            delete updatedFiles[fileID];
          }
        });
        function fileIsNotRemoved(uploadFileID) {
          return removedFiles[uploadFileID] === void 0;
        }
        Object.keys(updatedUploads).forEach((uploadID) => {
          const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);
          if (newFileIDs.length === 0) {
            delete updatedUploads[uploadID];
            return;
          }
          const {
            capabilities
          } = this.getState();
          if (newFileIDs.length !== currentUploads[uploadID].fileIDs.length && !capabilities.individualCancellation) {
            throw new Error("individualCancellation is disabled");
          }
          updatedUploads[uploadID] = {
            ...currentUploads[uploadID],
            fileIDs: newFileIDs
          };
        });
        const stateUpdate = {
          currentUploads: updatedUploads,
          files: updatedFiles
        };
        if (Object.keys(updatedFiles).length === 0) {
          stateUpdate.allowNewUpload = true;
          stateUpdate.error = null;
          stateUpdate.recoveredState = null;
        }
        this.setState(stateUpdate);
        this.calculateTotalProgress();
        const removedFileIDs = Object.keys(removedFiles);
        removedFileIDs.forEach((fileID) => {
          this.emit("file-removed", removedFiles[fileID], reason);
        });
        if (removedFileIDs.length > 5) {
          this.log(`Removed ${removedFileIDs.length} files`);
        } else {
          this.log(`Removed files: ${removedFileIDs.join(", ")}`);
        }
      }
      removeFile(fileID, reason) {
        if (reason === void 0) {
          reason = null;
        }
        this.removeFiles([fileID], reason);
      }
      pauseResume(fileID) {
        if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
          return void 0;
        }
        const wasPaused = this.getFile(fileID).isPaused || false;
        const isPaused = !wasPaused;
        this.setFileState(fileID, {
          isPaused
        });
        this.emit("upload-pause", fileID, isPaused);
        return isPaused;
      }
      pauseAll() {
        const updatedFiles = {
          ...this.getState().files
        };
        const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
          return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
        });
        inProgressUpdatedFiles.forEach((file) => {
          const updatedFile = {
            ...updatedFiles[file],
            isPaused: true
          };
          updatedFiles[file] = updatedFile;
        });
        this.setState({
          files: updatedFiles
        });
        this.emit("pause-all");
      }
      resumeAll() {
        const updatedFiles = {
          ...this.getState().files
        };
        const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
          return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
        });
        inProgressUpdatedFiles.forEach((file) => {
          const updatedFile = {
            ...updatedFiles[file],
            isPaused: false,
            error: null
          };
          updatedFiles[file] = updatedFile;
        });
        this.setState({
          files: updatedFiles
        });
        this.emit("resume-all");
      }
      retryAll() {
        const updatedFiles = {
          ...this.getState().files
        };
        const filesToRetry = Object.keys(updatedFiles).filter((file) => {
          return updatedFiles[file].error;
        });
        filesToRetry.forEach((file) => {
          const updatedFile = {
            ...updatedFiles[file],
            isPaused: false,
            error: null
          };
          updatedFiles[file] = updatedFile;
        });
        this.setState({
          files: updatedFiles,
          error: null
        });
        this.emit("retry-all", filesToRetry);
        if (filesToRetry.length === 0) {
          return Promise.resolve({
            successful: [],
            failed: []
          });
        }
        const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {
          forceAllowNewUpload: true
        });
        return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
      }
      cancelAll(_temp) {
        let {
          reason = "user"
        } = _temp === void 0 ? {} : _temp;
        this.emit("cancel-all", {
          reason
        });
        if (reason === "user") {
          const {
            files
          } = this.getState();
          const fileIDs = Object.keys(files);
          if (fileIDs.length) {
            this.removeFiles(fileIDs, "cancel-all");
          }
          this.setState({
            totalProgress: 0,
            error: null,
            recoveredState: null
          });
        }
      }
      retryUpload(fileID) {
        this.setFileState(fileID, {
          error: null,
          isPaused: false
        });
        this.emit("upload-retry", fileID);
        const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([fileID], {
          forceAllowNewUpload: true
        });
        return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
      }
      reset() {
        this.cancelAll(...arguments);
      }
      logout() {
        this.iteratePlugins((plugin) => {
          if (plugin.provider && plugin.provider.logout) {
            plugin.provider.logout();
          }
        });
      }
      calculateProgress(file, data) {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
        this.setFileState(file.id, {
          progress: {
            ...this.getFile(file.id).progress,
            bytesUploaded: data.bytesUploaded,
            bytesTotal: data.bytesTotal,
            percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
          }
        });
        this.calculateTotalProgress();
      }
      calculateTotalProgress() {
        const files = this.getFiles();
        const inProgress = files.filter((file) => {
          return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
        });
        if (inProgress.length === 0) {
          this.emit("progress", 0);
          this.setState({
            totalProgress: 0
          });
          return;
        }
        const sizedFiles = inProgress.filter((file) => file.progress.bytesTotal != null);
        const unsizedFiles = inProgress.filter((file) => file.progress.bytesTotal == null);
        if (sizedFiles.length === 0) {
          const progressMax = inProgress.length * 100;
          const currentProgress = unsizedFiles.reduce((acc, file) => {
            return acc + file.progress.percentage;
          }, 0);
          const totalProgress2 = Math.round(currentProgress / progressMax * 100);
          this.setState({
            totalProgress: totalProgress2
          });
          return;
        }
        let totalSize = sizedFiles.reduce((acc, file) => {
          return acc + file.progress.bytesTotal;
        }, 0);
        const averageSize = totalSize / sizedFiles.length;
        totalSize += averageSize * unsizedFiles.length;
        let uploadedSize = 0;
        sizedFiles.forEach((file) => {
          uploadedSize += file.progress.bytesUploaded;
        });
        unsizedFiles.forEach((file) => {
          uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
        });
        let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);
        if (totalProgress > 100) {
          totalProgress = 100;
        }
        this.setState({
          totalProgress
        });
        this.emit("progress", totalProgress);
      }
      updateOnlineStatus() {
        const online = typeof window.navigator.onLine !== "undefined" ? window.navigator.onLine : true;
        if (!online) {
          this.emit("is-offline");
          this.info(this.i18n("noInternetConnection"), "error", 0);
          this.wasOffline = true;
        } else {
          this.emit("is-online");
          if (this.wasOffline) {
            this.emit("back-online");
            this.info(this.i18n("connectedToInternet"), "success", 3e3);
            this.wasOffline = false;
          }
        }
      }
      getID() {
        return this.opts.id;
      }
      use(Plugin, opts) {
        if (typeof Plugin !== "function") {
          const msg = `Expected a plugin class, but got ${Plugin === null ? "null" : typeof Plugin}. Please verify that the plugin was imported and spelled correctly.`;
          throw new TypeError(msg);
        }
        const plugin = new Plugin(this, opts);
        const pluginId = plugin.id;
        if (!pluginId) {
          throw new Error("Your plugin must have an id");
        }
        if (!plugin.type) {
          throw new Error("Your plugin must have a type");
        }
        const existsPluginAlready = this.getPlugin(pluginId);
        if (existsPluginAlready) {
          const msg = `Already found a plugin named '${existsPluginAlready.id}'. Tried to use: '${pluginId}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;
          throw new Error(msg);
        }
        if (Plugin.VERSION) {
          this.log(`Using ${pluginId} v${Plugin.VERSION}`);
        }
        if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) {
          _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin);
        } else {
          _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [plugin];
        }
        plugin.install();
        return this;
      }
      getPlugin(id2) {
        for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {
          const foundPlugin = plugins.find((plugin) => plugin.id === id2);
          if (foundPlugin != null)
            return foundPlugin;
        }
        return void 0;
      }
      [_Symbol$for](type) {
        return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];
      }
      iteratePlugins(method) {
        Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);
      }
      removePlugin(instance) {
        this.log(`Removing plugin ${instance.id}`);
        this.emit("plugin-remove", instance);
        if (instance.uninstall) {
          instance.uninstall();
        }
        const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type];
        const index = list.findIndex((item) => item.id === instance.id);
        if (index !== -1) {
          list.splice(index, 1);
        }
        const state = this.getState();
        const updatedState = {
          plugins: {
            ...state.plugins,
            [instance.id]: void 0
          }
        };
        this.setState(updatedState);
      }
      close(_temp2) {
        let {
          reason
        } = _temp2 === void 0 ? {} : _temp2;
        this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
        this.cancelAll({
          reason
        });
        _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();
        this.iteratePlugins((plugin) => {
          this.removePlugin(plugin);
        });
        if (typeof window !== "undefined" && window.removeEventListener) {
          window.removeEventListener("online", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
          window.removeEventListener("offline", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
        }
      }
      hideInfo() {
        const {
          info
        } = this.getState();
        this.setState({
          info: info.slice(1)
        });
        this.emit("info-hidden");
      }
      info(message, type, duration) {
        if (type === void 0) {
          type = "info";
        }
        if (duration === void 0) {
          duration = 3e3;
        }
        const isComplexMessage = typeof message === "object";
        this.setState({
          info: [...this.getState().info, {
            type,
            message: isComplexMessage ? message.message : message,
            details: isComplexMessage ? message.details : null
          }]
        });
        setTimeout(() => this.hideInfo(), duration);
        this.emit("info-visible");
      }
      log(message, type) {
        const {
          logger
        } = this.opts;
        switch (type) {
          case "error":
            logger.error(message);
            break;
          case "warning":
            logger.warn(message);
            break;
          default:
            logger.debug(message);
            break;
        }
      }
      restore(uploadID) {
        this.log(`Core: attempting to restore upload "${uploadID}"`);
        if (!this.getState().currentUploads[uploadID]) {
          _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
          return Promise.reject(new Error("Nonexistent upload"));
        }
        return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
      }
      [_Symbol$for2]() {
        return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...arguments);
      }
      addResultData(uploadID, data) {
        if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {
          this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
          return;
        }
        const {
          currentUploads
        } = this.getState();
        const currentUpload = {
          ...currentUploads[uploadID],
          result: {
            ...currentUploads[uploadID].result,
            ...data
          }
        };
        this.setState({
          currentUploads: {
            ...currentUploads,
            [uploadID]: currentUpload
          }
        });
      }
      upload() {
        var _classPrivateFieldLoo;
        if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins].uploader) != null && _classPrivateFieldLoo.length)) {
          this.log("No uploader type plugins are used", "warning");
        }
        let {
          files
        } = this.getState();
        const onBeforeUploadResult = this.opts.onBeforeUpload(files);
        if (onBeforeUploadResult === false) {
          return Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false"));
        }
        if (onBeforeUploadResult && typeof onBeforeUploadResult === "object") {
          files = onBeforeUploadResult;
          this.setState({
            files
          });
        }
        return Promise.resolve().then(() => _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateMinNumberOfFiles(files)).catch((err) => {
          _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](err);
          throw err;
        }).then(() => {
          if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) {
            throw new _Restricter.RestrictionError(this.i18n("missingRequiredMetaField"));
          }
        }).catch((err) => {
          throw err;
        }).then(() => {
          const {
            currentUploads
          } = this.getState();
          const currentlyUploadingFiles = Object.values(currentUploads).flatMap((curr) => curr.fileIDs);
          const waitingFileIDs = [];
          Object.keys(files).forEach((fileID) => {
            const file = this.getFile(fileID);
            if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
              waitingFileIDs.push(file.id);
            }
          });
          const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);
          return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
        }).catch((err) => {
          this.emit("error", err);
          this.log(err, "error");
          throw err;
        });
      }
    };
    function _informAndEmit2(error, file) {
      const {
        message,
        details = ""
      } = error;
      if (error.isRestriction) {
        this.emit("restriction-failed", file, error);
      } else {
        this.emit("error", error);
      }
      this.info({
        message,
        details
      }, "error", this.opts.infoTimeout);
      this.log(`${message} ${details}`.trim(), "error");
    }
    function _checkRequiredMetaFieldsOnFile2(file) {
      const {
        missingFields,
        error
      } = _classPrivateFieldLooseBase(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);
      if (missingFields.length > 0) {
        this.setFileState(file.id, {
          missingRequiredMetaFields: missingFields
        });
        this.log(error.message);
        this.emit("restriction-failed", file, error);
        return false;
      }
      return true;
    }
    function _checkRequiredMetaFields2(files) {
      let success = true;
      for (const file of Object.values(files)) {
        if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) {
          success = false;
        }
      }
      return success;
    }
    function _assertNewUploadAllowed2(file) {
      const {
        allowNewUpload
      } = this.getState();
      if (allowNewUpload === false) {
        const error = new _Restricter.RestrictionError(this.i18n("noMoreFilesAllowed"));
        _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error, file);
        throw error;
      }
    }
    function _checkAndCreateFileStateObject2(files, fileDescriptor) {
      const fileType = getFileType(fileDescriptor);
      const fileName = getFileName(fileType, fileDescriptor);
      const fileExtension = getFileNameAndExtension(fileName).extension;
      const isRemote = Boolean(fileDescriptor.isRemote);
      const fileID = generateFileID({
        ...fileDescriptor,
        type: fileType
      });
      if (this.checkIfFileAlreadyExists(fileID)) {
        const error = new _Restricter.RestrictionError(this.i18n("noDuplicates", {
          fileName
        }));
        _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error, fileDescriptor);
        throw error;
      }
      const meta = fileDescriptor.meta || {};
      meta.name = fileName;
      meta.type = fileType;
      const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
      let newFile = {
        source: fileDescriptor.source || "",
        id: fileID,
        name: fileName,
        extension: fileExtension || "",
        meta: {
          ...this.getState().meta,
          ...meta
        },
        type: fileType,
        data: fileDescriptor.data,
        progress: {
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: size,
          uploadComplete: false,
          uploadStarted: null
        },
        size,
        isRemote,
        remote: fileDescriptor.remote || "",
        preview: fileDescriptor.preview
      };
      const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);
      if (onBeforeFileAddedResult === false) {
        const error = new _Restricter.RestrictionError("Cannot add the file because onBeforeFileAdded returned false.");
        this.emit("restriction-failed", fileDescriptor, error);
        throw error;
      } else if (typeof onBeforeFileAddedResult === "object" && onBeforeFileAddedResult !== null) {
        newFile = onBeforeFileAddedResult;
      }
      try {
        const filesArray = Object.keys(files).map((i2) => files[i2]);
        _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(newFile, filesArray);
      } catch (err) {
        _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](err, newFile);
        throw err;
      }
      return newFile;
    }
    function _startIfAutoProceed2() {
      if (this.opts.autoProceed && !this.scheduledAutoProceed) {
        this.scheduledAutoProceed = setTimeout(() => {
          this.scheduledAutoProceed = null;
          this.upload().catch((err) => {
            if (!err.isRestriction) {
              this.log(err.stack || err.message || err);
            }
          });
        }, 4);
      }
    }
    function _addListeners2() {
      const errorHandler = (error, file, response) => {
        let errorMsg = error.message || "Unknown error";
        if (error.details) {
          errorMsg += ` ${error.details}`;
        }
        this.setState({
          error: errorMsg
        });
        if (file != null && file.id in this.getState().files) {
          this.setFileState(file.id, {
            error: errorMsg,
            response
          });
        }
      };
      this.on("error", errorHandler);
      this.on("upload-error", (file, error, response) => {
        errorHandler(error, file, response);
        if (typeof error === "object" && error.message) {
          const newError = new Error(error.message);
          newError.details = error.message;
          if (error.details) {
            newError.details += ` ${error.details}`;
          }
          newError.message = this.i18n("failedToUpload", {
            file: file == null ? void 0 : file.name
          });
          _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](newError);
        } else {
          _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error);
        }
      });
      this.on("upload", () => {
        this.setState({
          error: null
        });
      });
      this.on("upload-started", (file) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        this.setFileState(file.id, {
          progress: {
            uploadStarted: Date.now(),
            uploadComplete: false,
            percentage: 0,
            bytesUploaded: 0,
            bytesTotal: file.size
          }
        });
      });
      this.on("upload-progress", this.calculateProgress);
      this.on("upload-success", (file, uploadResp) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        const currentProgress = this.getFile(file.id).progress;
        this.setFileState(file.id, {
          progress: {
            ...currentProgress,
            postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {
              mode: "indeterminate"
            } : null,
            uploadComplete: true,
            percentage: 100,
            bytesUploaded: currentProgress.bytesTotal
          },
          response: uploadResp,
          uploadURL: uploadResp.uploadURL,
          isPaused: false
        });
        if (file.size == null) {
          this.setFileState(file.id, {
            size: uploadResp.bytesUploaded || currentProgress.bytesTotal
          });
        }
        this.calculateTotalProgress();
      });
      this.on("preprocess-progress", (file, progress) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        this.setFileState(file.id, {
          progress: {
            ...this.getFile(file.id).progress,
            preprocess: progress
          }
        });
      });
      this.on("preprocess-complete", (file) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        const files = {
          ...this.getState().files
        };
        files[file.id] = {
          ...files[file.id],
          progress: {
            ...files[file.id].progress
          }
        };
        delete files[file.id].progress.preprocess;
        this.setState({
          files
        });
      });
      this.on("postprocess-progress", (file, progress) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        this.setFileState(file.id, {
          progress: {
            ...this.getState().files[file.id].progress,
            postprocess: progress
          }
        });
      });
      this.on("postprocess-complete", (file) => {
        if (file == null || !this.getFile(file.id)) {
          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
          return;
        }
        const files = {
          ...this.getState().files
        };
        files[file.id] = {
          ...files[file.id],
          progress: {
            ...files[file.id].progress
          }
        };
        delete files[file.id].progress.postprocess;
        this.setState({
          files
        });
      });
      this.on("restored", () => {
        this.calculateTotalProgress();
      });
      this.on("dashboard:file-edit-complete", (file) => {
        if (file) {
          _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
        }
      });
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("online", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
        window.addEventListener("offline", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
        setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3);
      }
    }
    function _createUpload2(fileIDs, opts) {
      if (opts === void 0) {
        opts = {};
      }
      const {
        forceAllowNewUpload = false
      } = opts;
      const {
        allowNewUpload,
        currentUploads
      } = this.getState();
      if (!allowNewUpload && !forceAllowNewUpload) {
        throw new Error("Cannot create a new upload: already uploading.");
      }
      const uploadID = (0, _nonSecure.nanoid)();
      this.emit("upload", {
        id: uploadID,
        fileIDs
      });
      this.setState({
        allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,
        currentUploads: {
          ...currentUploads,
          [uploadID]: {
            fileIDs,
            step: 0,
            result: {}
          }
        }
      });
      return uploadID;
    }
    function _getUpload2(uploadID) {
      const {
        currentUploads
      } = this.getState();
      return currentUploads[uploadID];
    }
    function _removeUpload2(uploadID) {
      const currentUploads = {
        ...this.getState().currentUploads
      };
      delete currentUploads[uploadID];
      this.setState({
        currentUploads
      });
    }
    async function _runUpload2(uploadID) {
      let {
        currentUploads
      } = this.getState();
      let currentUpload = currentUploads[uploadID];
      const restoreStep = currentUpload.step || 0;
      const steps = [..._classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors]];
      try {
        for (let step = restoreStep; step < steps.length; step++) {
          if (!currentUpload) {
            break;
          }
          const fn = steps[step];
          const updatedUpload = {
            ...currentUpload,
            step
          };
          this.setState({
            currentUploads: {
              ...currentUploads,
              [uploadID]: updatedUpload
            }
          });
          await fn(updatedUpload.fileIDs, uploadID);
          currentUploads = this.getState().currentUploads;
          currentUpload = currentUploads[uploadID];
        }
      } catch (err) {
        _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
        throw err;
      }
      if (currentUpload) {
        currentUpload.fileIDs.forEach((fileID) => {
          const file = this.getFile(fileID);
          if (file && file.progress.postprocess) {
            this.emit("postprocess-complete", file);
          }
        });
        const files = currentUpload.fileIDs.map((fileID) => this.getFile(fileID));
        const successful = files.filter((file) => !file.error);
        const failed = files.filter((file) => file.error);
        await this.addResultData(uploadID, {
          successful,
          failed,
          uploadID
        });
        currentUploads = this.getState().currentUploads;
        currentUpload = currentUploads[uploadID];
      }
      let result;
      if (currentUpload) {
        result = currentUpload.result;
        this.emit("complete", result);
        _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
      }
      if (result == null) {
        this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
      }
      return result;
    }
    Uppy2.VERSION = packageJson.version;
    module.exports = Uppy2;
  }
});

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => b,
  Fragment: () => g,
  cloneElement: () => B,
  createContext: () => E,
  createElement: () => y,
  createRef: () => _3,
  h: () => y,
  hydrate: () => q,
  isValidElement: () => t,
  options: () => l,
  render: () => N,
  toChildArray: () => $2
});
function v(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function p(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function y(l2, u2, t2) {
  var i2, o2, r2, f2 = {};
  for (r2 in u2)
    "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = u2[r2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps)
    for (r2 in l2.defaultProps)
      void 0 === f2[r2] && (f2[r2] = l2.defaultProps[r2]);
  return d(l2, f2, i2, o2, null);
}
function d(n2, t2, i2, o2, r2) {
  var f2 = { type: n2, props: t2, key: i2, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++u : r2, __i: -1, __u: 0 };
  return null == r2 && null != l.vnode && l.vnode(f2), f2;
}
function _3() {
  return { current: null };
}
function g(n2) {
  return n2.children;
}
function b(n2, l2) {
  this.props = n2, this.context = l2;
}
function m(n2, l2) {
  if (null == l2)
    return n2.__ ? m(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if (null != (u2 = n2.__k[l2]) && null != u2.__e)
      return u2.__e;
  return "function" == typeof n2.type ? m(n2) : null;
}
function w(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return w(n2);
  }
}
function k(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
}
function x() {
  var n2, u2, t2, o2, r2, e2, c2, s2, a2;
  for (i.sort(f); n2 = i.shift(); )
    n2.__d && (u2 = i.length, o2 = void 0, e2 = (r2 = (t2 = n2).__v).__e, s2 = [], a2 = [], (c2 = t2.__P) && ((o2 = v({}, r2)).__v = r2.__v + 1, l.vnode && l.vnode(o2), F(c2, o2, r2, t2.__n, void 0 !== c2.ownerSVGElement, 32 & r2.__u ? [e2] : null, s2, null == e2 ? m(r2) : e2, !!(32 & r2.__u), a2), o2.__v = r2.__v, o2.__.__k[o2.__i] = o2, L(s2, o2, a2), o2.__e != e2 && w(o2)), i.length > u2 && i.sort(f));
  x.__r = 0;
}
function C(n2, l2, u2, t2, i2, o2, r2, f2, e2, a2, h2) {
  var v2, p2, y2, d2, _5, g2 = t2 && t2.__k || s, b2 = l2.length;
  for (u2.__d = e2, P(u2, l2, g2), e2 = u2.__d, v2 = 0; v2 < b2; v2++)
    null != (y2 = u2.__k[v2]) && "boolean" != typeof y2 && "function" != typeof y2 && (p2 = -1 === y2.__i ? c : g2[y2.__i] || c, y2.__i = v2, F(n2, y2, p2, i2, o2, r2, f2, e2, a2, h2), d2 = y2.__e, y2.ref && p2.ref != y2.ref && (p2.ref && O(p2.ref, null, y2), h2.push(y2.ref, y2.__c || d2, y2)), null == _5 && null != d2 && (_5 = d2), 65536 & y2.__u || p2.__k === y2.__k ? (d2 || p2.__e != e2 || (e2 = m(p2)), e2 = S(y2, e2, n2)) : "function" == typeof y2.type && void 0 !== y2.__d ? e2 = y2.__d : d2 && (e2 = d2.nextSibling), y2.__d = void 0, y2.__u &= -196609);
  u2.__d = e2, u2.__e = _5;
}
function P(n2, l2, u2) {
  var t2, i2, o2, r2, f2, e2 = l2.length, c2 = u2.length, s2 = c2, a2 = 0;
  for (n2.__k = [], t2 = 0; t2 < e2; t2++)
    r2 = t2 + a2, null != (i2 = n2.__k[t2] = null == (i2 = l2[t2]) || "boolean" == typeof i2 || "function" == typeof i2 ? null : "string" == typeof i2 || "number" == typeof i2 || "bigint" == typeof i2 || i2.constructor == String ? d(null, i2, null, null, null) : h(i2) ? d(g, { children: i2 }, null, null, null) : void 0 === i2.constructor && i2.__b > 0 ? d(i2.type, i2.props, i2.key, i2.ref ? i2.ref : null, i2.__v) : i2) ? (i2.__ = n2, i2.__b = n2.__b + 1, f2 = I(i2, u2, r2, s2), i2.__i = f2, o2 = null, -1 !== f2 && (s2--, (o2 = u2[f2]) && (o2.__u |= 131072)), null == o2 || null === o2.__v ? (-1 == f2 && a2--, "function" != typeof i2.type && (i2.__u |= 65536)) : f2 !== r2 && (f2 === r2 + 1 ? a2++ : f2 > r2 ? s2 > e2 - r2 ? a2 += f2 - r2 : a2-- : f2 < r2 ? f2 == r2 - 1 && (a2 = f2 - r2) : a2 = 0, f2 !== t2 + a2 && (i2.__u |= 65536))) : (o2 = u2[r2]) && null == o2.key && o2.__e && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m(o2)), j(o2, o2, false), u2[r2] = null, s2--);
  if (s2)
    for (t2 = 0; t2 < c2; t2++)
      null != (o2 = u2[t2]) && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m(o2)), j(o2, o2));
}
function S(n2, l2, u2) {
  var t2, i2;
  if ("function" == typeof n2.type) {
    for (t2 = n2.__k, i2 = 0; t2 && i2 < t2.length; i2++)
      t2[i2] && (t2[i2].__ = n2, l2 = S(t2[i2], l2, u2));
    return l2;
  }
  n2.__e != l2 && (u2.insertBefore(n2.__e, l2 || null), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 === l2.nodeType);
  return l2;
}
function $2(n2, l2) {
  return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (h(n2) ? n2.some(function(n3) {
    $2(n3, l2);
  }) : l2.push(n2)), l2;
}
function I(n2, l2, u2, t2) {
  var i2 = n2.key, o2 = n2.type, r2 = u2 - 1, f2 = u2 + 1, e2 = l2[u2];
  if (null === e2 || e2 && i2 == e2.key && o2 === e2.type && 0 == (131072 & e2.__u))
    return u2;
  if (t2 > (null != e2 && 0 == (131072 & e2.__u) ? 1 : 0))
    for (; r2 >= 0 || f2 < l2.length; ) {
      if (r2 >= 0) {
        if ((e2 = l2[r2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
          return r2;
        r2--;
      }
      if (f2 < l2.length) {
        if ((e2 = l2[f2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
          return f2;
        f2++;
      }
    }
  return -1;
}
function H(n2, l2, u2) {
  "-" === l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || a.test(l2) ? u2 : u2 + "px";
}
function T(n2, l2, u2, t2, i2) {
  var o2;
  n:
    if ("style" === l2)
      if ("string" == typeof u2)
        n2.style.cssText = u2;
      else {
        if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2)
          for (l2 in t2)
            u2 && l2 in u2 || H(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            t2 && u2[l2] === t2[l2] || H(n2.style, l2, u2[l2]);
      }
    else if ("o" === l2[0] && "n" === l2[1])
      o2 = l2 !== (l2 = l2.replace(/(PointerCapture)$|Capture$/i, "$1")), l2 = l2.toLowerCase() in n2 || "onFocusOut" === l2 || "onFocusIn" === l2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = Date.now(), n2.addEventListener(l2, o2 ? D : A, o2)) : n2.removeEventListener(l2, o2 ? D : A, o2);
    else {
      if (i2)
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l2 && "height" !== l2 && "href" !== l2 && "list" !== l2 && "form" !== l2 && "tabIndex" !== l2 && "download" !== l2 && "rowSpan" !== l2 && "colSpan" !== l2 && "role" !== l2 && l2 in n2)
        try {
          n2[l2] = null == u2 ? "" : u2;
          break n;
        } catch (n3) {
        }
      "function" == typeof u2 || (null == u2 || false === u2 && "-" !== l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
    }
}
function A(n2) {
  if (this.l) {
    var u2 = this.l[n2.type + false];
    if (n2.t) {
      if (n2.t <= u2.u)
        return;
    } else
      n2.t = Date.now();
    return u2(l.event ? l.event(n2) : n2);
  }
}
function D(n2) {
  if (this.l)
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function F(n2, u2, t2, i2, o2, r2, f2, e2, c2, s2) {
  var a2, p2, y2, d2, _5, m2, w2, k2, x2, P2, S2, $3, I2, H2, T2, A2 = u2.type;
  if (void 0 !== u2.constructor)
    return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), r2 = [e2 = u2.__e = t2.__e]), (a2 = l.__b) && a2(u2);
  n:
    if ("function" == typeof A2)
      try {
        if (k2 = u2.props, x2 = (a2 = A2.contextType) && i2[a2.__c], P2 = a2 ? x2 ? x2.props.value : a2.__ : i2, t2.__c ? w2 = (p2 = u2.__c = t2.__c).__ = p2.__E : ("prototype" in A2 && A2.prototype.render ? u2.__c = p2 = new A2(k2, P2) : (u2.__c = p2 = new b(k2, P2), p2.constructor = A2, p2.render = z), x2 && x2.sub(p2), p2.props = k2, p2.state || (p2.state = {}), p2.context = P2, p2.__n = i2, y2 = p2.__d = true, p2.__h = [], p2._sb = []), null == p2.__s && (p2.__s = p2.state), null != A2.getDerivedStateFromProps && (p2.__s == p2.state && (p2.__s = v({}, p2.__s)), v(p2.__s, A2.getDerivedStateFromProps(k2, p2.__s))), d2 = p2.props, _5 = p2.state, p2.__v = u2, y2)
          null == A2.getDerivedStateFromProps && null != p2.componentWillMount && p2.componentWillMount(), null != p2.componentDidMount && p2.__h.push(p2.componentDidMount);
        else {
          if (null == A2.getDerivedStateFromProps && k2 !== d2 && null != p2.componentWillReceiveProps && p2.componentWillReceiveProps(k2, P2), !p2.__e && (null != p2.shouldComponentUpdate && false === p2.shouldComponentUpdate(k2, p2.__s, P2) || u2.__v === t2.__v)) {
            for (u2.__v !== t2.__v && (p2.props = k2, p2.state = p2.__s, p2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), S2 = 0; S2 < p2._sb.length; S2++)
              p2.__h.push(p2._sb[S2]);
            p2._sb = [], p2.__h.length && f2.push(p2);
            break n;
          }
          null != p2.componentWillUpdate && p2.componentWillUpdate(k2, p2.__s, P2), null != p2.componentDidUpdate && p2.__h.push(function() {
            p2.componentDidUpdate(d2, _5, m2);
          });
        }
        if (p2.context = P2, p2.props = k2, p2.__P = n2, p2.__e = false, $3 = l.__r, I2 = 0, "prototype" in A2 && A2.prototype.render) {
          for (p2.state = p2.__s, p2.__d = false, $3 && $3(u2), a2 = p2.render(p2.props, p2.state, p2.context), H2 = 0; H2 < p2._sb.length; H2++)
            p2.__h.push(p2._sb[H2]);
          p2._sb = [];
        } else
          do {
            p2.__d = false, $3 && $3(u2), a2 = p2.render(p2.props, p2.state, p2.context), p2.state = p2.__s;
          } while (p2.__d && ++I2 < 25);
        p2.state = p2.__s, null != p2.getChildContext && (i2 = v(v({}, i2), p2.getChildContext())), y2 || null == p2.getSnapshotBeforeUpdate || (m2 = p2.getSnapshotBeforeUpdate(d2, _5)), C(n2, h(T2 = null != a2 && a2.type === g && null == a2.key ? a2.props.children : a2) ? T2 : [T2], u2, t2, i2, o2, r2, f2, e2, c2, s2), p2.base = u2.__e, u2.__u &= -161, p2.__h.length && f2.push(p2), w2 && (p2.__E = p2.__ = null);
      } catch (n3) {
        u2.__v = null, c2 || null != r2 ? (u2.__e = e2, u2.__u |= c2 ? 160 : 32, r2[r2.indexOf(e2)] = null) : (u2.__e = t2.__e, u2.__k = t2.__k), l.__e(n3, u2, t2);
      }
    else
      null == r2 && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = M(t2.__e, u2, t2, i2, o2, r2, f2, c2, s2);
  (a2 = l.diffed) && a2(u2);
}
function L(n2, u2, t2) {
  u2.__d = void 0;
  for (var i2 = 0; i2 < t2.length; i2++)
    O(t2[i2], t2[++i2], t2[++i2]);
  l.__c && l.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l.__e(n3, u3.__v);
    }
  });
}
function M(l2, u2, t2, i2, o2, r2, f2, e2, s2) {
  var a2, v2, y2, d2, _5, g2, b2, w2 = t2.props, k2 = u2.props, x2 = u2.type;
  if ("svg" === x2 && (o2 = true), null != r2) {
    for (a2 = 0; a2 < r2.length; a2++)
      if ((_5 = r2[a2]) && "setAttribute" in _5 == !!x2 && (x2 ? _5.localName === x2 : 3 === _5.nodeType)) {
        l2 = _5, r2[a2] = null;
        break;
      }
  }
  if (null == l2) {
    if (null === x2)
      return document.createTextNode(k2);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", x2) : document.createElement(x2, k2.is && k2), r2 = null, e2 = false;
  }
  if (null === x2)
    w2 === k2 || e2 && l2.data === k2 || (l2.data = k2);
  else {
    if (r2 = r2 && n.call(l2.childNodes), w2 = t2.props || c, !e2 && null != r2)
      for (w2 = {}, a2 = 0; a2 < l2.attributes.length; a2++)
        w2[(_5 = l2.attributes[a2]).name] = _5.value;
    for (a2 in w2)
      _5 = w2[a2], "children" == a2 || ("dangerouslySetInnerHTML" == a2 ? y2 = _5 : "key" === a2 || a2 in k2 || T(l2, a2, null, _5, o2));
    for (a2 in k2)
      _5 = k2[a2], "children" == a2 ? d2 = _5 : "dangerouslySetInnerHTML" == a2 ? v2 = _5 : "value" == a2 ? g2 = _5 : "checked" == a2 ? b2 = _5 : "key" === a2 || e2 && "function" != typeof _5 || w2[a2] === _5 || T(l2, a2, _5, w2[a2], o2);
    if (v2)
      e2 || y2 && (v2.__html === y2.__html || v2.__html === l2.innerHTML) || (l2.innerHTML = v2.__html), u2.__k = [];
    else if (y2 && (l2.innerHTML = ""), C(l2, h(d2) ? d2 : [d2], u2, t2, i2, o2 && "foreignObject" !== x2, r2, f2, r2 ? r2[0] : t2.__k && m(t2, 0), e2, s2), null != r2)
      for (a2 = r2.length; a2--; )
        null != r2[a2] && p(r2[a2]);
    e2 || (a2 = "value", void 0 !== g2 && (g2 !== l2[a2] || "progress" === x2 && !g2 || "option" === x2 && g2 !== w2[a2]) && T(l2, a2, g2, w2[a2], false), a2 = "checked", void 0 !== b2 && b2 !== l2[a2] && T(l2, a2, b2, w2[a2], false));
  }
  return l2;
}
function O(n2, u2, t2) {
  try {
    "function" == typeof n2 ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l.__e(n3, t2);
  }
}
function j(n2, u2, t2) {
  var i2, o2;
  if (l.unmount && l.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current !== n2.__e || O(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount)
      try {
        i2.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u2);
      }
    i2.base = i2.__P = null, n2.__c = void 0;
  }
  if (i2 = n2.__k)
    for (o2 = 0; o2 < i2.length; o2++)
      i2[o2] && j(i2[o2], u2, t2 || "function" != typeof n2.type);
  t2 || null == n2.__e || p(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function z(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function N(u2, t2, i2) {
  var o2, r2, f2, e2;
  l.__ && l.__(u2, t2), r2 = (o2 = "function" == typeof i2) ? null : i2 && i2.__k || t2.__k, f2 = [], e2 = [], F(t2, u2 = (!o2 && i2 || t2).__k = y(g, null, [u2]), r2 || c, c, void 0 !== t2.ownerSVGElement, !o2 && i2 ? [i2] : r2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, f2, !o2 && i2 ? i2 : r2 ? r2.__e : t2.firstChild, o2, e2), L(f2, u2, e2);
}
function q(n2, l2) {
  N(n2, l2, q);
}
function B(l2, u2, t2) {
  var i2, o2, r2, f2, e2 = v({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (f2 = l2.type.defaultProps), u2)
    "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e2[r2] = void 0 === u2[r2] && void 0 !== f2 ? f2[r2] : u2[r2];
  return arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), d(l2.type, e2, i2 || l2.key, o2 || l2.ref, null);
}
function E(n2, l2) {
  var u2 = { __c: l2 = "__cC" + e++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var u3, t2;
    return this.getChildContext || (u3 = [], (t2 = {})[l2] = this, this.getChildContext = function() {
      return t2;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u3.some(function(n5) {
        n5.__e = true, k(n5);
      });
    }, this.sub = function(n4) {
      u3.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
var n, l, u, t, i, o, r, f, e, c, s, a, h;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    c = {};
    s = [];
    a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    h = Array.isArray;
    n = s.slice, l = { __e: function(n2, l2, u2, t2) {
      for (var i2, o2, r2; l2 = l2.__; )
        if ((i2 = l2.__c) && !i2.__)
          try {
            if ((o2 = i2.constructor) && null != o2.getDerivedStateFromError && (i2.setState(o2.getDerivedStateFromError(n2)), r2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), r2 = i2.__d), r2)
              return i2.__E = i2;
          } catch (l3) {
            n2 = l3;
          }
      throw n2;
    } }, u = 0, t = function(n2) {
      return null != n2 && null == n2.constructor;
    }, b.prototype.setState = function(n2, l2) {
      var u2;
      u2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n2 && (n2 = n2(v({}, u2), this.props)), n2 && v(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), k(this));
    }, b.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), k(this));
    }, b.prototype.render = g, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n2, l2) {
      return n2.__v.__b - l2.__v.__b;
    }, x.__r = 0, e = 0;
  }
});

// node_modules/@uppy/utils/lib/isDOMElement.js
var require_isDOMElement = __commonJS({
  "node_modules/@uppy/utils/lib/isDOMElement.js"(exports, module) {
    "use strict";
    function isDOMElement(obj) {
      return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
    }
    module.exports = isDOMElement;
  }
});

// node_modules/@uppy/utils/lib/findDOMElement.js
var require_findDOMElement = __commonJS({
  "node_modules/@uppy/utils/lib/findDOMElement.js"(exports, module) {
    "use strict";
    var isDOMElement = require_isDOMElement();
    function findDOMElement(element, context) {
      if (context === void 0) {
        context = document;
      }
      if (typeof element === "string") {
        return context.querySelector(element);
      }
      if (isDOMElement(element)) {
        return element;
      }
      return null;
    }
    module.exports = findDOMElement;
  }
});

// node_modules/@uppy/utils/lib/getTextDirection.js
var require_getTextDirection = __commonJS({
  "node_modules/@uppy/utils/lib/getTextDirection.js"(exports, module) {
    "use strict";
    function getTextDirection(element) {
      var _element;
      while (element && !element.dir) {
        element = element.parentNode;
      }
      return (_element = element) == null ? void 0 : _element.dir;
    }
    module.exports = getTextDirection;
  }
});

// node_modules/@uppy/core/lib/BasePlugin.js
var require_BasePlugin = __commonJS({
  "node_modules/@uppy/core/lib/BasePlugin.js"(exports, module) {
    "use strict";
    var Translator = require_Translator();
    var BasePlugin2 = class {
      constructor(uppy2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        this.uppy = uppy2;
        this.opts = opts;
      }
      getPluginState() {
        const {
          plugins
        } = this.uppy.getState();
        return plugins[this.id] || {};
      }
      setPluginState(update) {
        const {
          plugins
        } = this.uppy.getState();
        this.uppy.setState({
          plugins: {
            ...plugins,
            [this.id]: {
              ...plugins[this.id],
              ...update
            }
          }
        });
      }
      setOptions(newOpts) {
        this.opts = {
          ...this.opts,
          ...newOpts
        };
        this.setPluginState();
        this.i18nInit();
      }
      i18nInit() {
        const translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
        this.i18n = translator.translate.bind(translator);
        this.i18nArray = translator.translateArray.bind(translator);
        this.setPluginState();
      }
      addTarget() {
        throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
      }
      install() {
      }
      uninstall() {
      }
      render() {
        throw new Error("Extend the render method to add your plugin to a DOM element");
      }
      update() {
      }
      afterUpdate() {
      }
    };
    module.exports = BasePlugin2;
  }
});

// node_modules/@uppy/core/lib/UIPlugin.js
var require_UIPlugin = __commonJS({
  "node_modules/@uppy/core/lib/UIPlugin.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var findDOMElement = require_findDOMElement();
    var getTextDirection = require_getTextDirection();
    var BasePlugin2 = require_BasePlugin();
    function debounce(fn) {
      let calling = null;
      let latestArgs = null;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        latestArgs = args;
        if (!calling) {
          calling = Promise.resolve().then(() => {
            calling = null;
            return fn(...latestArgs);
          });
        }
        return calling;
      };
    }
    var _updateUI = /* @__PURE__ */ _classPrivateFieldLooseKey("updateUI");
    var UIPlugin = class extends BasePlugin2 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, _updateUI, {
          writable: true,
          value: void 0
        });
      }
      mount(target, plugin) {
        const callerPluginName = plugin.id;
        const targetElement = findDOMElement(target);
        if (targetElement) {
          this.isTargetDOMEl = true;
          const uppyRootElement = document.createElement("div");
          uppyRootElement.classList.add("uppy-Root");
          _classPrivateFieldLooseBase(this, _updateUI)[_updateUI] = debounce((state) => {
            if (!this.uppy.getPlugin(this.id))
              return;
            (0, _preact.render)(this.render(state), uppyRootElement);
            this.afterUpdate();
          });
          this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);
          if (this.opts.replaceTargetContent) {
            targetElement.innerHTML = "";
          }
          (0, _preact.render)(this.render(this.uppy.getState()), uppyRootElement);
          this.el = uppyRootElement;
          targetElement.appendChild(uppyRootElement);
          uppyRootElement.dir = this.opts.direction || getTextDirection(uppyRootElement) || "ltr";
          this.onMount();
          return this.el;
        }
        let targetPlugin;
        if (typeof target === "object" && target instanceof UIPlugin) {
          targetPlugin = target;
        } else if (typeof target === "function") {
          const Target = target;
          this.uppy.iteratePlugins((p2) => {
            if (p2 instanceof Target) {
              targetPlugin = p2;
            }
          });
        }
        if (targetPlugin) {
          this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
          this.parent = targetPlugin;
          this.el = targetPlugin.addTarget(plugin);
          this.onMount();
          return this.el;
        }
        this.uppy.log(`Not installing ${callerPluginName}`);
        let message = `Invalid target option given to ${callerPluginName}.`;
        if (typeof target === "function") {
          message += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.";
        } else {
          message += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.";
        }
        throw new Error(message);
      }
      update(state) {
        if (this.el != null) {
          var _classPrivateFieldLoo, _classPrivateFieldLoo2;
          (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _updateUI))[_updateUI]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
        }
      }
      unmount() {
        if (this.isTargetDOMEl) {
          var _this$el;
          (_this$el = this.el) == null ? void 0 : _this$el.remove();
        }
        this.onUnmount();
      }
      onMount() {
      }
      onUnmount() {
      }
    };
    module.exports = UIPlugin;
  }
});

// node_modules/@uppy/core/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@uppy/core/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uppy = exports.UIPlugin = exports.BasePlugin = void 0;
    Object.defineProperty(exports, "debugLogger", {
      enumerable: true,
      get: function() {
        return _loggers.debugLogger;
      }
    });
    var _loggers = require_loggers();
    module.exports = require_Uppy();
    var _0 = require_UIPlugin();
    exports.UIPlugin = _0;
    var _1 = require_BasePlugin();
    exports.BasePlugin = _1;
    var Uppy2 = require_Uppy();
    exports.Uppy = Uppy2;
    var UIPlugin = require_UIPlugin();
    var BasePlugin2 = require_BasePlugin();
    Uppy2.Uppy = Uppy2;
    Uppy2.UIPlugin = UIPlugin;
    Uppy2.BasePlugin = BasePlugin2;
    Uppy2.debugLogger = _loggers.debugLogger;
  }
});

// node_modules/@uppy/utils/lib/toArray.js
var require_toArray = __commonJS({
  "node_modules/@uppy/utils/lib/toArray.js"(exports, module) {
    "use strict";
    module.exports = Array.from;
  }
});

// node_modules/@uppy/utils/lib/FOCUSABLE_ELEMENTS.js
var require_FOCUSABLE_ELEMENTS = __commonJS({
  "node_modules/@uppy/utils/lib/FOCUSABLE_ELEMENTS.js"(exports, module) {
    "use strict";
    module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];
  }
});

// node_modules/@uppy/dashboard/lib/utils/getActiveOverlayEl.js
var require_getActiveOverlayEl = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/getActiveOverlayEl.js"(exports, module) {
    "use strict";
    function getActiveOverlayEl(dashboardEl, activeOverlayType) {
      if (activeOverlayType) {
        const overlayEl = dashboardEl.querySelector(`[data-uppy-paneltype="${activeOverlayType}"]`);
        if (overlayEl)
          return overlayEl;
      }
      return dashboardEl;
    }
    module.exports = getActiveOverlayEl;
  }
});

// node_modules/@uppy/dashboard/lib/utils/trapFocus.js
var require_trapFocus = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/trapFocus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forInline = forInline;
    exports.forModal = trapFocus;
    var toArray = require_toArray();
    var FOCUSABLE_ELEMENTS = require_FOCUSABLE_ELEMENTS();
    var getActiveOverlayEl = require_getActiveOverlayEl();
    function focusOnFirstNode(event2, nodes) {
      const node = nodes[0];
      if (node) {
        node.focus();
        event2.preventDefault();
      }
    }
    function focusOnLastNode(event2, nodes) {
      const node = nodes[nodes.length - 1];
      if (node) {
        node.focus();
        event2.preventDefault();
      }
    }
    function isFocusInOverlay(activeOverlayEl) {
      return activeOverlayEl.contains(document.activeElement);
    }
    function trapFocus(event2, activeOverlayType, dashboardEl) {
      const activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
      const focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
      const focusedItemIndex = focusableNodes.indexOf(document.activeElement);
      if (!isFocusInOverlay(activeOverlayEl)) {
        focusOnFirstNode(event2, focusableNodes);
      } else if (event2.shiftKey && focusedItemIndex === 0) {
        focusOnLastNode(event2, focusableNodes);
      } else if (!event2.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
        focusOnFirstNode(event2, focusableNodes);
      }
    }
    function forInline(event2, activeOverlayType, dashboardEl) {
      if (activeOverlayType === null) {
      } else {
        trapFocus(event2, activeOverlayType, dashboardEl);
      }
    }
  }
});

// node_modules/@uppy/utils/lib/getSpeed.js
var require_getSpeed = __commonJS({
  "node_modules/@uppy/utils/lib/getSpeed.js"(exports, module) {
    "use strict";
    function getSpeed(fileProgress) {
      if (!fileProgress.bytesUploaded)
        return 0;
      const timeElapsed = Date.now() - fileProgress.uploadStarted;
      const uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1e3);
      return uploadSpeed;
    }
    module.exports = getSpeed;
  }
});

// node_modules/@uppy/utils/lib/getBytesRemaining.js
var require_getBytesRemaining = __commonJS({
  "node_modules/@uppy/utils/lib/getBytesRemaining.js"(exports, module) {
    "use strict";
    function getBytesRemaining(fileProgress) {
      return fileProgress.bytesTotal - fileProgress.bytesUploaded;
    }
    module.exports = getBytesRemaining;
  }
});

// node_modules/@uppy/status-bar/lib/StatusBarStates.js
var require_StatusBarStates = __commonJS({
  "node_modules/@uppy/status-bar/lib/StatusBarStates.js"(exports, module) {
    "use strict";
    module.exports = {
      STATE_ERROR: "error",
      STATE_WAITING: "waiting",
      STATE_PREPROCESSING: "preprocessing",
      STATE_UPLOADING: "uploading",
      STATE_POSTPROCESSING: "postprocessing",
      STATE_COMPLETE: "complete"
    };
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/@uppy/utils/lib/secondsToTime.js
var require_secondsToTime = __commonJS({
  "node_modules/@uppy/utils/lib/secondsToTime.js"(exports, module) {
    "use strict";
    function secondsToTime(rawSeconds) {
      const hours = Math.floor(rawSeconds / 3600) % 24;
      const minutes = Math.floor(rawSeconds / 60) % 60;
      const seconds = Math.floor(rawSeconds % 60);
      return {
        hours,
        minutes,
        seconds
      };
    }
    module.exports = secondsToTime;
  }
});

// node_modules/@uppy/utils/lib/prettyETA.js
var require_prettyETA = __commonJS({
  "node_modules/@uppy/utils/lib/prettyETA.js"(exports, module) {
    "use strict";
    var secondsToTime = require_secondsToTime();
    function prettyETA(seconds) {
      const time = secondsToTime(seconds);
      const hoursStr = time.hours === 0 ? "" : `${time.hours}h`;
      const minutesStr = time.minutes === 0 ? "" : `${time.hours === 0 ? time.minutes : ` ${time.minutes.toString(10).padStart(2, "0")}`}m`;
      const secondsStr = time.hours !== 0 ? "" : `${time.minutes === 0 ? time.seconds : ` ${time.seconds.toString(10).padStart(2, "0")}`}s`;
      return `${hoursStr}${minutesStr}${secondsStr}`;
    }
    module.exports = prettyETA;
  }
});

// node_modules/@uppy/status-bar/lib/Components.js
var require_Components = __commonJS({
  "node_modules/@uppy/status-bar/lib/Components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CancelBtn = CancelBtn;
    exports.DoneBtn = DoneBtn;
    exports.LoadingSpinner = LoadingSpinner;
    exports.PauseResumeButton = PauseResumeButton;
    exports.ProgressBarComplete = ProgressBarComplete;
    exports.ProgressBarError = ProgressBarError;
    exports.ProgressBarProcessing = ProgressBarProcessing;
    exports.ProgressBarUploading = ProgressBarUploading;
    exports.ProgressDetails = ProgressDetails;
    exports.RetryBtn = RetryBtn;
    exports.UploadBtn = UploadBtn;
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    var throttle = require_lodash2();
    var prettierBytes = require_prettierBytes();
    var prettyETA = require_prettyETA();
    var statusBarStates = require_StatusBarStates();
    var DOT = `\xB7`;
    var renderDot = () => ` ${DOT} `;
    function UploadBtn(props) {
      const {
        newFiles,
        isUploadStarted,
        recoveredState,
        i18n,
        uploadState,
        isSomeGhost,
        startUpload
      } = props;
      const uploadBtnClassNames = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", {
        "uppy-c-btn-primary": uploadState === statusBarStates.STATE_WAITING
      }, {
        "uppy-StatusBar-actionBtn--disabled": isSomeGhost
      });
      const uploadBtnText = newFiles && isUploadStarted && !recoveredState ? i18n("uploadXNewFiles", {
        smart_count: newFiles
      }) : i18n("uploadXFiles", {
        smart_count: newFiles
      });
      return (0, _preact.h)("button", {
        type: "button",
        className: uploadBtnClassNames,
        "aria-label": i18n("uploadXFiles", {
          smart_count: newFiles
        }),
        onClick: startUpload,
        disabled: isSomeGhost,
        "data-uppy-super-focusable": true
      }, uploadBtnText);
    }
    function RetryBtn(props) {
      const {
        i18n,
        uppy: uppy2
      } = props;
      return (0, _preact.h)("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
        "aria-label": i18n("retryUpload"),
        onClick: () => uppy2.retryAll(),
        "data-uppy-super-focusable": true
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "8",
        height: "10",
        viewBox: "0 0 8 10"
      }, (0, _preact.h)("path", {
        d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
      })), i18n("retry"));
    }
    function CancelBtn(props) {
      const {
        i18n,
        uppy: uppy2
      } = props;
      return (0, _preact.h)("button", {
        type: "button",
        className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
        title: i18n("cancel"),
        "aria-label": i18n("cancel"),
        onClick: () => uppy2.cancelAll(),
        "data-cy": "cancel",
        "data-uppy-super-focusable": true
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16"
      }, (0, _preact.h)("g", {
        fill: "none",
        fillRule: "evenodd"
      }, (0, _preact.h)("circle", {
        fill: "#888",
        cx: "8",
        cy: "8",
        r: "8"
      }), (0, _preact.h)("path", {
        fill: "#FFF",
        d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
      }))));
    }
    function PauseResumeButton(props) {
      const {
        isAllPaused,
        i18n,
        isAllComplete,
        resumableUploads,
        uppy: uppy2
      } = props;
      const title = isAllPaused ? i18n("resume") : i18n("pause");
      function togglePauseResume() {
        if (isAllComplete)
          return null;
        if (!resumableUploads) {
          return uppy2.cancelAll();
        }
        if (isAllPaused) {
          return uppy2.resumeAll();
        }
        return uppy2.pauseAll();
      }
      return (0, _preact.h)("button", {
        title,
        "aria-label": title,
        className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
        type: "button",
        onClick: togglePauseResume,
        "data-uppy-super-focusable": true
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16"
      }, (0, _preact.h)("g", {
        fill: "none",
        fillRule: "evenodd"
      }, (0, _preact.h)("circle", {
        fill: "#888",
        cx: "8",
        cy: "8",
        r: "8"
      }), (0, _preact.h)("path", {
        fill: "#FFF",
        d: isAllPaused ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z"
      }))));
    }
    function DoneBtn(props) {
      const {
        i18n,
        doneButtonHandler
      } = props;
      return (0, _preact.h)("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
        onClick: doneButtonHandler,
        "data-uppy-super-focusable": true
      }, i18n("done"));
    }
    function LoadingSpinner() {
      return (0, _preact.h)("svg", {
        className: "uppy-StatusBar-spinner",
        "aria-hidden": "true",
        focusable: "false",
        width: "14",
        height: "14"
      }, (0, _preact.h)("path", {
        d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
        fillRule: "evenodd"
      }));
    }
    function ProgressBarProcessing(props) {
      const {
        progress
      } = props;
      const {
        value,
        mode,
        message
      } = progress;
      const roundedValue = Math.round(value * 100);
      const dot = `\xB7`;
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-content"
      }, (0, _preact.h)(LoadingSpinner, null), mode === "determinate" ? `${roundedValue}% ${dot} ` : "", message);
    }
    function ProgressDetails(props) {
      const {
        numUploads,
        complete,
        totalUploadedSize,
        totalSize,
        totalETA,
        i18n
      } = props;
      const ifShowFilesUploadedOfTotal = numUploads > 1;
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusSecondary"
      }, ifShowFilesUploadedOfTotal && i18n("filesUploadedOfTotal", {
        complete,
        smart_count: numUploads
      }), (0, _preact.h)("span", {
        className: "uppy-StatusBar-additionalInfo"
      }, ifShowFilesUploadedOfTotal && renderDot(), i18n("dataUploadedOfTotal", {
        complete: prettierBytes(totalUploadedSize),
        total: prettierBytes(totalSize)
      }), renderDot(), i18n("xTimeLeft", {
        time: prettyETA(totalETA)
      })));
    }
    function FileUploadCount(props) {
      const {
        i18n,
        complete,
        numUploads
      } = props;
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusSecondary"
      }, i18n("filesUploadedOfTotal", {
        complete,
        smart_count: numUploads
      }));
    }
    function UploadNewlyAddedFiles(props) {
      const {
        i18n,
        newFiles,
        startUpload
      } = props;
      const uploadBtnClassNames = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded");
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusSecondary"
      }, (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusSecondaryHint"
      }, i18n("xMoreFilesAdded", {
        smart_count: newFiles
      })), (0, _preact.h)("button", {
        type: "button",
        className: uploadBtnClassNames,
        "aria-label": i18n("uploadXFiles", {
          smart_count: newFiles
        }),
        onClick: startUpload
      }, i18n("upload")));
    }
    var ThrottledProgressDetails = throttle(ProgressDetails, 500, {
      leading: true,
      trailing: true
    });
    function ProgressBarUploading(props) {
      const {
        i18n,
        supportsUploadProgress,
        totalProgress,
        showProgressDetails,
        isUploadStarted,
        isAllComplete,
        isAllPaused,
        newFiles,
        numUploads,
        complete,
        totalUploadedSize,
        totalSize,
        totalETA,
        startUpload
      } = props;
      const showUploadNewlyAddedFiles = newFiles && isUploadStarted;
      if (!isUploadStarted || isAllComplete) {
        return null;
      }
      const title = isAllPaused ? i18n("paused") : i18n("uploading");
      function renderProgressDetails() {
        if (!isAllPaused && !showUploadNewlyAddedFiles && showProgressDetails) {
          if (supportsUploadProgress) {
            return (0, _preact.h)(ThrottledProgressDetails, {
              numUploads,
              complete,
              totalUploadedSize,
              totalSize,
              totalETA,
              i18n
            });
          }
          return (0, _preact.h)(FileUploadCount, {
            i18n,
            complete,
            numUploads
          });
        }
        return null;
      }
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-content",
        "aria-label": title,
        title
      }, !isAllPaused ? (0, _preact.h)(LoadingSpinner, null) : null, (0, _preact.h)("div", {
        className: "uppy-StatusBar-status"
      }, (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusPrimary"
      }, supportsUploadProgress ? `${title}: ${totalProgress}%` : title), renderProgressDetails(), showUploadNewlyAddedFiles ? (0, _preact.h)(UploadNewlyAddedFiles, {
        i18n,
        newFiles,
        startUpload
      }) : null));
    }
    function ProgressBarComplete(props) {
      const {
        i18n
      } = props;
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-content",
        role: "status",
        title: i18n("complete")
      }, (0, _preact.h)("div", {
        className: "uppy-StatusBar-status"
      }, (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusPrimary"
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-StatusBar-statusIndicator uppy-c-icon",
        width: "15",
        height: "11",
        viewBox: "0 0 15 11"
      }, (0, _preact.h)("path", {
        d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
      })), i18n("complete"))));
    }
    function ProgressBarError(props) {
      const {
        error,
        i18n,
        complete,
        numUploads
      } = props;
      function displayErrorAlert() {
        const errorMessage = `${i18n("uploadFailed")} 

 ${error}`;
        alert(errorMessage);
      }
      return (0, _preact.h)("div", {
        className: "uppy-StatusBar-content",
        title: i18n("uploadFailed")
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-StatusBar-statusIndicator uppy-c-icon",
        width: "11",
        height: "11",
        viewBox: "0 0 11 11"
      }, (0, _preact.h)("path", {
        d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
      })), (0, _preact.h)("div", {
        className: "uppy-StatusBar-status"
      }, (0, _preact.h)("div", {
        className: "uppy-StatusBar-statusPrimary"
      }, i18n("uploadFailed"), (0, _preact.h)("button", {
        className: "uppy-u-reset uppy-StatusBar-details",
        "aria-label": i18n("showErrorDetails"),
        "data-microtip-position": "top-right",
        "data-microtip-size": "medium",
        onClick: displayErrorAlert,
        type: "button"
      }, "?")), (0, _preact.h)(FileUploadCount, {
        i18n,
        complete,
        numUploads
      })));
    }
  }
});

// node_modules/@uppy/status-bar/lib/calculateProcessingProgress.js
var require_calculateProcessingProgress = __commonJS({
  "node_modules/@uppy/status-bar/lib/calculateProcessingProgress.js"(exports, module) {
    "use strict";
    function calculateProcessingProgress(files) {
      const values = [];
      let mode;
      let message;
      for (const {
        progress
      } of Object.values(files)) {
        const {
          preprocess,
          postprocess
        } = progress;
        if (message == null && (preprocess || postprocess)) {
          ({
            mode,
            message
          } = preprocess || postprocess);
        }
        if ((preprocess == null ? void 0 : preprocess.mode) === "determinate")
          values.push(preprocess.value);
        if ((postprocess == null ? void 0 : postprocess.mode) === "determinate")
          values.push(postprocess.value);
      }
      const value = values.reduce((total, progressValue) => {
        return total + progressValue / values.length;
      }, 0);
      return {
        mode,
        message,
        value
      };
    }
    module.exports = calculateProcessingProgress;
  }
});

// node_modules/@uppy/status-bar/lib/StatusBar.js
var require_StatusBar = __commonJS({
  "node_modules/@uppy/status-bar/lib/StatusBar.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var _Components = require_Components();
    var classNames = require_classnames();
    var statusBarStates = require_StatusBarStates();
    var calculateProcessingProgress = require_calculateProcessingProgress();
    var {
      STATE_ERROR,
      STATE_WAITING,
      STATE_PREPROCESSING,
      STATE_UPLOADING,
      STATE_POSTPROCESSING,
      STATE_COMPLETE
    } = statusBarStates;
    function StatusBar(props) {
      const {
        newFiles,
        allowNewUpload,
        isUploadInProgress,
        isAllPaused,
        resumableUploads,
        error,
        hideUploadButton,
        hidePauseResumeButton,
        hideCancelButton,
        hideRetryButton,
        recoveredState,
        uploadState,
        totalProgress,
        files,
        supportsUploadProgress,
        hideAfterFinish,
        isSomeGhost,
        doneButtonHandler,
        isUploadStarted,
        i18n,
        startUpload,
        uppy: uppy2,
        isAllComplete,
        showProgressDetails,
        numUploads,
        complete,
        totalSize,
        totalETA,
        totalUploadedSize
      } = props;
      function getProgressValue() {
        switch (uploadState) {
          case STATE_POSTPROCESSING:
          case STATE_PREPROCESSING: {
            const progress = calculateProcessingProgress(files);
            if (progress.mode === "determinate") {
              return progress.value * 100;
            }
            return totalProgress;
          }
          case STATE_ERROR: {
            return null;
          }
          case STATE_UPLOADING: {
            if (!supportsUploadProgress) {
              return null;
            }
            return totalProgress;
          }
          default:
            return totalProgress;
        }
      }
      function getIsIndeterminate() {
        switch (uploadState) {
          case STATE_POSTPROCESSING:
          case STATE_PREPROCESSING: {
            const {
              mode
            } = calculateProcessingProgress(files);
            return mode === "indeterminate";
          }
          case STATE_UPLOADING: {
            if (!supportsUploadProgress) {
              return true;
            }
            return false;
          }
          default:
            return false;
        }
      }
      function getIsHidden() {
        if (recoveredState) {
          return false;
        }
        switch (uploadState) {
          case STATE_WAITING:
            return hideUploadButton || newFiles === 0;
          case STATE_COMPLETE:
            return hideAfterFinish;
          default:
            return false;
        }
      }
      const progressValue = getProgressValue();
      const isHidden = getIsHidden();
      const width = progressValue != null ? progressValue : 100;
      const showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;
      const showCancelBtn = !hideCancelButton && uploadState !== STATE_WAITING && uploadState !== STATE_COMPLETE;
      const showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === STATE_UPLOADING;
      const showRetryBtn = error && !isAllComplete && !hideRetryButton;
      const showDoneBtn = doneButtonHandler && uploadState === STATE_COMPLETE;
      const progressClassNames = classNames("uppy-StatusBar-progress", {
        "is-indeterminate": getIsIndeterminate()
      });
      const statusBarClassNames = classNames("uppy-StatusBar", `is-${uploadState}`, {
        "has-ghosts": isSomeGhost
      });
      return (0, _preact.h)("div", {
        className: statusBarClassNames,
        "aria-hidden": isHidden
      }, (0, _preact.h)("div", {
        className: progressClassNames,
        style: {
          width: `${width}%`
        },
        role: "progressbar",
        "aria-label": `${width}%`,
        "aria-valuetext": `${width}%`,
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        "aria-valuenow": progressValue
      }), (() => {
        switch (uploadState) {
          case STATE_PREPROCESSING:
          case STATE_POSTPROCESSING:
            return (0, _preact.h)(_Components.ProgressBarProcessing, {
              progress: calculateProcessingProgress(files)
            });
          case STATE_COMPLETE:
            return (0, _preact.h)(_Components.ProgressBarComplete, {
              i18n
            });
          case STATE_ERROR:
            return (0, _preact.h)(_Components.ProgressBarError, {
              error,
              i18n,
              numUploads,
              complete
            });
          case STATE_UPLOADING:
            return (0, _preact.h)(_Components.ProgressBarUploading, {
              i18n,
              supportsUploadProgress,
              totalProgress,
              showProgressDetails,
              isUploadStarted,
              isAllComplete,
              isAllPaused,
              newFiles,
              numUploads,
              complete,
              totalUploadedSize,
              totalSize,
              totalETA,
              startUpload
            });
          default:
            return null;
        }
      })(), (0, _preact.h)("div", {
        className: "uppy-StatusBar-actions"
      }, recoveredState || showUploadBtn ? (0, _preact.h)(_Components.UploadBtn, {
        newFiles,
        isUploadStarted,
        recoveredState,
        i18n,
        isSomeGhost,
        startUpload,
        uploadState
      }) : null, showRetryBtn ? (0, _preact.h)(_Components.RetryBtn, {
        i18n,
        uppy: uppy2
      }) : null, showPauseResumeBtn ? (0, _preact.h)(_Components.PauseResumeButton, {
        isAllPaused,
        i18n,
        isAllComplete,
        resumableUploads,
        uppy: uppy2
      }) : null, showCancelBtn ? (0, _preact.h)(_Components.CancelBtn, {
        i18n,
        uppy: uppy2
      }) : null, showDoneBtn ? (0, _preact.h)(_Components.DoneBtn, {
        i18n,
        doneButtonHandler
      }) : null));
    }
    module.exports = StatusBar;
  }
});

// node_modules/@uppy/status-bar/lib/locale.js
var require_locale2 = __commonJS({
  "node_modules/@uppy/status-bar/lib/locale.js"(exports, module) {
    "use strict";
    module.exports = {
      strings: {
        uploading: "Uploading",
        complete: "Complete",
        uploadFailed: "Upload failed",
        paused: "Paused",
        retry: "Retry",
        cancel: "Cancel",
        pause: "Pause",
        resume: "Resume",
        done: "Done",
        filesUploadedOfTotal: {
          0: "%{complete} of %{smart_count} file uploaded",
          1: "%{complete} of %{smart_count} files uploaded"
        },
        dataUploadedOfTotal: "%{complete} of %{total}",
        xTimeLeft: "%{time} left",
        uploadXFiles: {
          0: "Upload %{smart_count} file",
          1: "Upload %{smart_count} files"
        },
        uploadXNewFiles: {
          0: "Upload +%{smart_count} file",
          1: "Upload +%{smart_count} files"
        },
        upload: "Upload",
        retryUpload: "Retry upload",
        xMoreFilesAdded: {
          0: "%{smart_count} more file added",
          1: "%{smart_count} more files added"
        },
        showErrorDetails: "Show error details"
      }
    };
  }
});

// node_modules/@uppy/status-bar/lib/_StatusBar.js
var require_StatusBar2 = __commonJS({
  "node_modules/@uppy/status-bar/lib/_StatusBar.js"(exports, module) {
    "use strict";
    var _core = require_lib2();
    var getSpeed = require_getSpeed();
    var getBytesRemaining = require_getBytesRemaining();
    var getTextDirection = require_getTextDirection();
    var statusBarStates = require_StatusBarStates();
    var StatusBarUI = require_StatusBar();
    var packageJson = {
      "version": "2.2.2"
    };
    var locale = require_locale2();
    function getTotalSpeed(files) {
      let totalSpeed = 0;
      files.forEach((file) => {
        totalSpeed += getSpeed(file.progress);
      });
      return totalSpeed;
    }
    function getTotalETA(files) {
      const totalSpeed = getTotalSpeed(files);
      if (totalSpeed === 0) {
        return 0;
      }
      const totalBytesRemaining = files.reduce((total, file) => {
        return total + getBytesRemaining(file.progress);
      }, 0);
      return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
    }
    function getUploadingState(error, isAllComplete, recoveredState, files) {
      if (error && !isAllComplete) {
        return statusBarStates.STATE_ERROR;
      }
      if (isAllComplete) {
        return statusBarStates.STATE_COMPLETE;
      }
      if (recoveredState) {
        return statusBarStates.STATE_WAITING;
      }
      let state = statusBarStates.STATE_WAITING;
      const fileIDs = Object.keys(files);
      for (let i2 = 0; i2 < fileIDs.length; i2++) {
        const {
          progress
        } = files[fileIDs[i2]];
        if (progress.uploadStarted && !progress.uploadComplete) {
          return statusBarStates.STATE_UPLOADING;
        }
        if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
          state = statusBarStates.STATE_PREPROCESSING;
        }
        if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
          state = statusBarStates.STATE_POSTPROCESSING;
        }
      }
      return state;
    }
    var StatusBar = class extends _core.UIPlugin {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.startUpload = () => {
          const {
            recoveredState
          } = this.uppy.getState();
          if (recoveredState) {
            this.uppy.emit("restore-confirmed");
            return void 0;
          }
          return this.uppy.upload().catch(() => {
          });
        };
        this.id = this.opts.id || "StatusBar";
        this.title = "StatusBar";
        this.type = "progressindicator";
        this.defaultLocale = locale;
        const defaultOptions = {
          target: "body",
          hideUploadButton: false,
          hideRetryButton: false,
          hidePauseResumeButton: false,
          hideCancelButton: false,
          showProgressDetails: false,
          hideAfterFinish: true,
          doneButtonHandler: null
        };
        this.opts = {
          ...defaultOptions,
          ...opts
        };
        this.i18nInit();
        this.render = this.render.bind(this);
        this.install = this.install.bind(this);
      }
      render(state) {
        const {
          capabilities,
          files,
          allowNewUpload,
          totalProgress,
          error,
          recoveredState
        } = state;
        const {
          newFiles,
          startedFiles,
          completeFiles,
          inProgressNotPausedFiles,
          isUploadStarted,
          isAllComplete,
          isAllErrored,
          isAllPaused,
          isUploadInProgress,
          isSomeGhost
        } = this.uppy.getObjectOfFilesPerState();
        const newFilesOrRecovered = recoveredState ? Object.values(files) : newFiles;
        const totalETA = getTotalETA(inProgressNotPausedFiles);
        const resumableUploads = !!capabilities.resumableUploads;
        const supportsUploadProgress = capabilities.uploadProgress !== false;
        let totalSize = 0;
        let totalUploadedSize = 0;
        startedFiles.forEach((file) => {
          totalSize += file.progress.bytesTotal || 0;
          totalUploadedSize += file.progress.bytesUploaded || 0;
        });
        return StatusBarUI({
          error,
          uploadState: getUploadingState(error, isAllComplete, recoveredState, state.files || {}),
          allowNewUpload,
          totalProgress,
          totalSize,
          totalUploadedSize,
          isAllComplete: false,
          isAllPaused,
          isAllErrored,
          isUploadStarted,
          isUploadInProgress,
          isSomeGhost,
          recoveredState,
          complete: completeFiles.length,
          newFiles: newFilesOrRecovered.length,
          numUploads: startedFiles.length,
          totalETA,
          files,
          i18n: this.i18n,
          uppy: this.uppy,
          startUpload: this.startUpload,
          doneButtonHandler: this.opts.doneButtonHandler,
          resumableUploads,
          supportsUploadProgress,
          showProgressDetails: this.opts.showProgressDetails,
          hideUploadButton: this.opts.hideUploadButton,
          hideRetryButton: this.opts.hideRetryButton,
          hidePauseResumeButton: this.opts.hidePauseResumeButton,
          hideCancelButton: this.opts.hideCancelButton,
          hideAfterFinish: this.opts.hideAfterFinish,
          isTargetDOMEl: this.isTargetDOMEl
        });
      }
      onMount() {
        const element = this.el;
        const direction = getTextDirection(element);
        if (!direction) {
          element.dir = "ltr";
        }
      }
      install() {
        const {
          target
        } = this.opts;
        if (target) {
          this.mount(target, this);
        }
      }
      uninstall() {
        this.unmount();
      }
    };
    StatusBar.VERSION = packageJson.version;
    module.exports = StatusBar;
  }
});

// node_modules/@uppy/status-bar/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@uppy/status-bar/lib/index.js"(exports, module) {
    "use strict";
    module.exports = require_StatusBar2();
  }
});

// node_modules/@uppy/informer/lib/FadeIn.js
var require_FadeIn = __commonJS({
  "node_modules/@uppy/informer/lib/FadeIn.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var TRANSITION_MS = 300;
    var FadeIn = class extends _preact.Component {
      constructor() {
        super(...arguments);
        this.ref = (0, _preact.createRef)();
      }
      componentWillEnter(callback) {
        this.ref.current.style.opacity = "1";
        this.ref.current.style.transform = "none";
        setTimeout(callback, TRANSITION_MS);
      }
      componentWillLeave(callback) {
        this.ref.current.style.opacity = "0";
        this.ref.current.style.transform = "translateY(350%)";
        setTimeout(callback, TRANSITION_MS);
      }
      render() {
        const {
          children
        } = this.props;
        return (0, _preact.h)("div", {
          className: "uppy-Informer-animated",
          ref: this.ref
        }, children);
      }
    };
    module.exports = FadeIn;
  }
});

// node_modules/@uppy/informer/lib/TransitionGroup.js
var require_TransitionGroup = __commonJS({
  "node_modules/@uppy/informer/lib/TransitionGroup.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function assign(obj, props) {
      return Object.assign(obj, props);
    }
    function getKey(vnode, fallback) {
      var _vnode$key;
      return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;
    }
    function linkRef(component, name) {
      const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
      return cache[name] || (cache[name] = (c2) => {
        component.refs[name] = c2;
      });
    }
    function getChildMapping(children) {
      const out = {};
      for (let i2 = 0; i2 < children.length; i2++) {
        if (children[i2] != null) {
          const key = getKey(children[i2], i2.toString(36));
          out[key] = children[i2];
        }
      }
      return out;
    }
    function mergeChildMappings(prev, next) {
      prev = prev || {};
      next = next || {};
      const getValueForKey = (key) => next.hasOwnProperty(key) ? next[key] : prev[key];
      const nextKeysPending = {};
      let pendingKeys = [];
      for (const prevKey in prev) {
        if (next.hasOwnProperty(prevKey)) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      const childMapping = {};
      for (const nextKey in next) {
        if (nextKeysPending.hasOwnProperty(nextKey)) {
          for (let i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
            const pendingNextKey = nextKeysPending[nextKey][i2];
            childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (let i2 = 0; i2 < pendingKeys.length; i2++) {
        childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
      }
      return childMapping;
    }
    var identity = (i2) => i2;
    var TransitionGroup = class extends _preact.Component {
      constructor(props, context) {
        super(props, context);
        this.refs = {};
        this.state = {
          children: getChildMapping((0, _preact.toChildArray)((0, _preact.toChildArray)(this.props.children)) || [])
        };
        this.performAppear = this.performAppear.bind(this);
        this.performEnter = this.performEnter.bind(this);
        this.performLeave = this.performLeave.bind(this);
      }
      componentWillMount() {
        this.currentlyTransitioningKeys = {};
        this.keysToAbortLeave = [];
        this.keysToEnter = [];
        this.keysToLeave = [];
      }
      componentDidMount() {
        const initialChildMapping = this.state.children;
        for (const key in initialChildMapping) {
          if (initialChildMapping[key]) {
            this.performAppear(key);
          }
        }
      }
      componentWillReceiveProps(nextProps) {
        const nextChildMapping = getChildMapping((0, _preact.toChildArray)(nextProps.children) || []);
        const prevChildMapping = this.state.children;
        this.setState((prevState) => ({
          children: mergeChildMappings(prevState.children, nextChildMapping)
        }));
        let key;
        for (key in nextChildMapping) {
          if (nextChildMapping.hasOwnProperty(key)) {
            const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
            if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
              this.keysToEnter.push(key);
              this.keysToAbortLeave.push(key);
            } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
              this.keysToEnter.push(key);
            }
          }
        }
        for (key in prevChildMapping) {
          if (prevChildMapping.hasOwnProperty(key)) {
            const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
            if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
              this.keysToLeave.push(key);
            }
          }
        }
      }
      componentDidUpdate() {
        const {
          keysToEnter
        } = this;
        this.keysToEnter = [];
        keysToEnter.forEach(this.performEnter);
        const {
          keysToLeave
        } = this;
        this.keysToLeave = [];
        keysToLeave.forEach(this.performLeave);
      }
      _finishAbort(key) {
        const idx = this.keysToAbortLeave.indexOf(key);
        if (idx !== -1) {
          this.keysToAbortLeave.splice(idx, 1);
        }
      }
      performAppear(key) {
        this.currentlyTransitioningKeys[key] = true;
        const component = this.refs[key];
        if (component.componentWillAppear) {
          component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
        } else {
          this._handleDoneAppearing(key);
        }
      }
      _handleDoneAppearing(key) {
        const component = this.refs[key];
        if (component.componentDidAppear) {
          component.componentDidAppear();
        }
        delete this.currentlyTransitioningKeys[key];
        this._finishAbort(key);
        const currentChildMapping = getChildMapping((0, _preact.toChildArray)(this.props.children) || []);
        if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
          this.performLeave(key);
        }
      }
      performEnter(key) {
        this.currentlyTransitioningKeys[key] = true;
        const component = this.refs[key];
        if (component.componentWillEnter) {
          component.componentWillEnter(this._handleDoneEntering.bind(this, key));
        } else {
          this._handleDoneEntering(key);
        }
      }
      _handleDoneEntering(key) {
        const component = this.refs[key];
        if (component.componentDidEnter) {
          component.componentDidEnter();
        }
        delete this.currentlyTransitioningKeys[key];
        this._finishAbort(key);
        const currentChildMapping = getChildMapping((0, _preact.toChildArray)(this.props.children) || []);
        if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
          this.performLeave(key);
        }
      }
      performLeave(key) {
        const idx = this.keysToAbortLeave.indexOf(key);
        if (idx !== -1) {
          return;
        }
        this.currentlyTransitioningKeys[key] = true;
        const component = this.refs[key];
        if (component.componentWillLeave) {
          component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
        } else {
          this._handleDoneLeaving(key);
        }
      }
      _handleDoneLeaving(key) {
        const idx = this.keysToAbortLeave.indexOf(key);
        if (idx !== -1) {
          return;
        }
        const component = this.refs[key];
        if (component.componentDidLeave) {
          component.componentDidLeave();
        }
        delete this.currentlyTransitioningKeys[key];
        const currentChildMapping = getChildMapping((0, _preact.toChildArray)(this.props.children) || []);
        if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
          this.performEnter(key);
        } else {
          const children = assign({}, this.state.children);
          delete children[key];
          this.setState({
            children
          });
        }
      }
      render(_ref, _ref2) {
        let {
          childFactory,
          transitionLeave,
          transitionName,
          transitionAppear,
          transitionEnter,
          transitionLeaveTimeout,
          transitionEnterTimeout,
          transitionAppearTimeout,
          component,
          ...props
        } = _ref;
        let {
          children
        } = _ref2;
        const childrenToRender = [];
        for (const key in children) {
          if (children.hasOwnProperty(key)) {
            const child = children[key];
            if (child) {
              const ref = linkRef(this, key), el = (0, _preact.cloneElement)(childFactory(child), {
                ref,
                key
              });
              childrenToRender.push(el);
            }
          }
        }
        return (0, _preact.h)(component, props, childrenToRender);
      }
    };
    TransitionGroup.defaultProps = {
      component: "span",
      childFactory: identity
    };
    module.exports = TransitionGroup;
  }
});

// node_modules/@uppy/informer/lib/Informer.js
var require_Informer = __commonJS({
  "node_modules/@uppy/informer/lib/Informer.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var _core = require_lib2();
    var FadeIn = require_FadeIn();
    var TransitionGroup = require_TransitionGroup();
    var packageJson = {
      "version": "2.1.1"
    };
    var Informer = class extends _core.UIPlugin {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.render = (state) => {
          return (0, _preact.h)("div", {
            className: "uppy uppy-Informer"
          }, (0, _preact.h)(TransitionGroup, null, state.info.map((info) => (0, _preact.h)(FadeIn, {
            key: info.message
          }, (0, _preact.h)("p", {
            role: "alert"
          }, info.message, " ", info.details && (0, _preact.h)("span", {
            "aria-label": info.details,
            "data-microtip-position": "top-left",
            "data-microtip-size": "medium",
            role: "tooltip",
            onClick: () => alert(`${info.message} 

 ${info.details}`)
          }, "?"))))));
        };
        this.type = "progressindicator";
        this.id = this.opts.id || "Informer";
        this.title = "Informer";
        const defaultOptions = {};
        this.opts = {
          ...defaultOptions,
          ...opts
        };
      }
      install() {
        const {
          target
        } = this.opts;
        if (target) {
          this.mount(target, this);
        }
      }
    };
    Informer.VERSION = packageJson.version;
    module.exports = Informer;
  }
});

// node_modules/@uppy/informer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@uppy/informer/lib/index.js"(exports, module) {
    "use strict";
    module.exports = require_Informer();
  }
});

// node_modules/exifr/dist/mini.umd.js
var require_mini_umd = __commonJS({
  "node_modules/exifr/dist/mini.umd.js"(exports, module) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module ? t2(exports) : "function" == typeof define && define.amd ? define("exifr", ["exports"], t2) : t2((e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).exifr = {});
    }(exports, function(e2) {
      "use strict";
      function t2(e3, t3, s3) {
        return t3 in e3 ? Object.defineProperty(e3, t3, { value: s3, enumerable: true, configurable: true, writable: true }) : e3[t3] = s3, e3;
      }
      var s2 = "undefined" != typeof self ? self : global;
      const i2 = "undefined" != typeof navigator, n2 = i2 && "undefined" == typeof HTMLImageElement, r2 = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node), a2 = s2.Buffer, h2 = !!a2, f2 = (e3) => void 0 !== e3;
      function l2(e3) {
        return void 0 === e3 || (e3 instanceof Map ? 0 === e3.size : 0 === Object.values(e3).filter(f2).length);
      }
      function o2(e3) {
        let t3 = new Error(e3);
        throw delete t3.stack, t3;
      }
      function u2(e3) {
        let t3 = function(e4) {
          let t4 = 0;
          return e4.ifd0.enabled && (t4 += 1024), e4.exif.enabled && (t4 += 2048), e4.makerNote && (t4 += 2048), e4.userComment && (t4 += 1024), e4.gps.enabled && (t4 += 512), e4.interop.enabled && (t4 += 100), e4.ifd1.enabled && (t4 += 1024), t4 + 2048;
        }(e3);
        return e3.jfif.enabled && (t3 += 50), e3.xmp.enabled && (t3 += 2e4), e3.iptc.enabled && (t3 += 14e3), e3.icc.enabled && (t3 += 6e3), t3;
      }
      const d2 = (e3) => String.fromCharCode.apply(null, e3), c2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
      class p2 {
        static from(e3, t3) {
          return e3 instanceof this && e3.le === t3 ? e3 : new p2(e3, void 0, void 0, t3);
        }
        constructor(e3, t3 = 0, s3, i3) {
          if ("boolean" == typeof i3 && (this.le = i3), Array.isArray(e3) && (e3 = new Uint8Array(e3)), 0 === e3)
            this.byteOffset = 0, this.byteLength = 0;
          else if (e3 instanceof ArrayBuffer) {
            void 0 === s3 && (s3 = e3.byteLength - t3);
            let i4 = new DataView(e3, t3, s3);
            this._swapDataView(i4);
          } else if (e3 instanceof Uint8Array || e3 instanceof DataView || e3 instanceof p2) {
            void 0 === s3 && (s3 = e3.byteLength - t3), (t3 += e3.byteOffset) + s3 > e3.byteOffset + e3.byteLength && o2("Creating view outside of available memory in ArrayBuffer");
            let i4 = new DataView(e3.buffer, t3, s3);
            this._swapDataView(i4);
          } else if ("number" == typeof e3) {
            let t4 = new DataView(new ArrayBuffer(e3));
            this._swapDataView(t4);
          } else
            o2("Invalid input argument for BufferView: " + e3);
        }
        _swapArrayBuffer(e3) {
          this._swapDataView(new DataView(e3));
        }
        _swapBuffer(e3) {
          this._swapDataView(new DataView(e3.buffer, e3.byteOffset, e3.byteLength));
        }
        _swapDataView(e3) {
          this.dataView = e3, this.buffer = e3.buffer, this.byteOffset = e3.byteOffset, this.byteLength = e3.byteLength;
        }
        _lengthToEnd(e3) {
          return this.byteLength - e3;
        }
        set(e3, t3, s3 = p2) {
          return e3 instanceof DataView || e3 instanceof p2 ? e3 = new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), e3 instanceof Uint8Array || o2("BufferView.set(): Invalid data argument."), this.toUint8().set(e3, t3), new s3(this, t3, e3.byteLength);
        }
        subarray(e3, t3) {
          return t3 = t3 || this._lengthToEnd(e3), new p2(this, e3, t3);
        }
        toUint8() {
          return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
        }
        getUint8Array(e3, t3) {
          return new Uint8Array(this.buffer, this.byteOffset + e3, t3);
        }
        getString(e3 = 0, t3 = this.byteLength) {
          let s3 = this.getUint8Array(e3, t3);
          return i3 = s3, c2 ? c2.decode(i3) : h2 ? Buffer.from(i3).toString("utf8") : decodeURIComponent(escape(d2(i3)));
          var i3;
        }
        getLatin1String(e3 = 0, t3 = this.byteLength) {
          let s3 = this.getUint8Array(e3, t3);
          return d2(s3);
        }
        getUnicodeString(e3 = 0, t3 = this.byteLength) {
          const s3 = [];
          for (let i3 = 0; i3 < t3 && e3 + i3 < this.byteLength; i3 += 2)
            s3.push(this.getUint16(e3 + i3));
          return d2(s3);
        }
        getInt8(e3) {
          return this.dataView.getInt8(e3);
        }
        getUint8(e3) {
          return this.dataView.getUint8(e3);
        }
        getInt16(e3, t3 = this.le) {
          return this.dataView.getInt16(e3, t3);
        }
        getInt32(e3, t3 = this.le) {
          return this.dataView.getInt32(e3, t3);
        }
        getUint16(e3, t3 = this.le) {
          return this.dataView.getUint16(e3, t3);
        }
        getUint32(e3, t3 = this.le) {
          return this.dataView.getUint32(e3, t3);
        }
        getFloat32(e3, t3 = this.le) {
          return this.dataView.getFloat32(e3, t3);
        }
        getFloat64(e3, t3 = this.le) {
          return this.dataView.getFloat64(e3, t3);
        }
        getFloat(e3, t3 = this.le) {
          return this.dataView.getFloat32(e3, t3);
        }
        getDouble(e3, t3 = this.le) {
          return this.dataView.getFloat64(e3, t3);
        }
        getUintBytes(e3, t3, s3) {
          switch (t3) {
            case 1:
              return this.getUint8(e3, s3);
            case 2:
              return this.getUint16(e3, s3);
            case 4:
              return this.getUint32(e3, s3);
            case 8:
              return this.getUint64 && this.getUint64(e3, s3);
          }
        }
        getUint(e3, t3, s3) {
          switch (t3) {
            case 8:
              return this.getUint8(e3, s3);
            case 16:
              return this.getUint16(e3, s3);
            case 32:
              return this.getUint32(e3, s3);
            case 64:
              return this.getUint64 && this.getUint64(e3, s3);
          }
        }
        toString(e3) {
          return this.dataView.toString(e3, this.constructor.name);
        }
        ensureChunk() {
        }
      }
      function g2(e3, t3) {
        o2(`${e3} '${t3}' was not loaded, try using full build of exifr.`);
      }
      class m2 extends Map {
        constructor(e3) {
          super(), this.kind = e3;
        }
        get(e3, t3) {
          return this.has(e3) || g2(this.kind, e3), t3 && (e3 in t3 || function(e4, t4) {
            o2(`Unknown ${e4} '${t4}'.`);
          }(this.kind, e3), t3[e3].enabled || g2(this.kind, e3)), super.get(e3);
        }
        keyList() {
          return Array.from(this.keys());
        }
      }
      var y2 = new m2("file parser"), b2 = new m2("segment parser"), w2 = new m2("file reader");
      let k2 = s2.fetch;
      const O2 = "Invalid input argument";
      function v2(e3, t3) {
        return (s3 = e3).startsWith("data:") || s3.length > 1e4 ? A2(e3, t3, "base64") : r2 && e3.includes("://") ? S2(e3, t3, "url", U) : r2 ? A2(e3, t3, "fs") : i2 ? S2(e3, t3, "url", U) : void o2(O2);
        var s3;
      }
      async function S2(e3, t3, s3, i3) {
        return w2.has(s3) ? A2(e3, t3, s3) : i3 ? async function(e4, t4) {
          let s4 = await t4(e4);
          return new p2(s4);
        }(e3, i3) : void o2(`Parser ${s3} is not loaded`);
      }
      async function A2(e3, t3, s3) {
        let i3 = new (w2.get(s3))(e3, t3);
        return await i3.read(), i3;
      }
      const U = (e3) => k2(e3).then((e4) => e4.arrayBuffer()), x2 = (e3) => new Promise((t3, s3) => {
        let i3 = new FileReader();
        i3.onloadend = () => t3(i3.result || new ArrayBuffer()), i3.onerror = s3, i3.readAsArrayBuffer(e3);
      });
      class C2 extends Map {
        get tagKeys() {
          return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
        }
        get tagValues() {
          return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
        }
      }
      function B2(e3, t3, s3) {
        let i3 = new C2();
        for (let [e4, t4] of s3)
          i3.set(e4, t4);
        if (Array.isArray(t3))
          for (let s4 of t3)
            e3.set(s4, i3);
        else
          e3.set(t3, i3);
        return i3;
      }
      function V(e3, t3, s3) {
        let i3, n3 = e3.get(t3);
        for (i3 of s3)
          n3.set(i3[0], i3[1]);
      }
      const I2 = /* @__PURE__ */ new Map(), L2 = /* @__PURE__ */ new Map(), T2 = /* @__PURE__ */ new Map(), P2 = 37500, z2 = 37510, F2 = 33723, j2 = 34675, E2 = 34665, _5 = 34853, D2 = 40965, M2 = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], N2 = ["jfif", "xmp", "icc", "iptc", "ihdr"], R = ["tiff", ...N2], $3 = ["ifd0", "ifd1", "exif", "gps", "interop"], K = [...R, ...$3], W = ["makerNote", "userComment"], X = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], H2 = [...X, "sanitize", "mergeOutput", "silentErrors"];
      class Y {
        get translate() {
          return this.translateKeys || this.translateValues || this.reviveValues;
        }
      }
      class G extends Y {
        get needed() {
          return this.enabled || this.deps.size > 0;
        }
        constructor(e3, s3, i3, n3) {
          if (super(), t2(this, "enabled", false), t2(this, "skip", /* @__PURE__ */ new Set()), t2(this, "pick", /* @__PURE__ */ new Set()), t2(this, "deps", /* @__PURE__ */ new Set()), t2(this, "translateKeys", false), t2(this, "translateValues", false), t2(this, "reviveValues", false), this.key = e3, this.enabled = s3, this.parse = this.enabled, this.applyInheritables(n3), this.canBeFiltered = $3.includes(e3), this.canBeFiltered && (this.dict = I2.get(e3)), void 0 !== i3)
            if (Array.isArray(i3))
              this.parse = this.enabled = true, this.canBeFiltered && i3.length > 0 && this.translateTagSet(i3, this.pick);
            else if ("object" == typeof i3) {
              if (this.enabled = true, this.parse = false !== i3.parse, this.canBeFiltered) {
                let { pick: e4, skip: t3 } = i3;
                e4 && e4.length > 0 && this.translateTagSet(e4, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
              }
              this.applyInheritables(i3);
            } else
              true === i3 || false === i3 ? this.parse = this.enabled = i3 : o2(`Invalid options argument: ${i3}`);
        }
        applyInheritables(e3) {
          let t3, s3;
          for (t3 of X)
            s3 = e3[t3], void 0 !== s3 && (this[t3] = s3);
        }
        translateTagSet(e3, t3) {
          if (this.dict) {
            let s3, i3, { tagKeys: n3, tagValues: r3 } = this.dict;
            for (s3 of e3)
              "string" == typeof s3 ? (i3 = r3.indexOf(s3), -1 === i3 && (i3 = n3.indexOf(Number(s3))), -1 !== i3 && t3.add(Number(n3[i3]))) : t3.add(s3);
          } else
            for (let s3 of e3)
              t3.add(s3);
        }
        finalizeFilters() {
          !this.enabled && this.deps.size > 0 ? (this.enabled = true, te(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && te(this.pick, this.deps);
        }
      }
      var J = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, q2 = /* @__PURE__ */ new Map();
      class Q extends Y {
        static useCached(e3) {
          let t3 = q2.get(e3);
          return void 0 !== t3 || (t3 = new this(e3), q2.set(e3, t3)), t3;
        }
        constructor(e3) {
          super(), true === e3 ? this.setupFromTrue() : void 0 === e3 ? this.setupFromUndefined() : Array.isArray(e3) ? this.setupFromArray(e3) : "object" == typeof e3 ? this.setupFromObject(e3) : o2(`Invalid options argument ${e3}`), void 0 === this.firstChunkSize && (this.firstChunkSize = i2 ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
        }
        setupFromUndefined() {
          let e3;
          for (e3 of M2)
            this[e3] = J[e3];
          for (e3 of H2)
            this[e3] = J[e3];
          for (e3 of W)
            this[e3] = J[e3];
          for (e3 of K)
            this[e3] = new G(e3, J[e3], void 0, this);
        }
        setupFromTrue() {
          let e3;
          for (e3 of M2)
            this[e3] = J[e3];
          for (e3 of H2)
            this[e3] = J[e3];
          for (e3 of W)
            this[e3] = true;
          for (e3 of K)
            this[e3] = new G(e3, true, void 0, this);
        }
        setupFromArray(e3) {
          let t3;
          for (t3 of M2)
            this[t3] = J[t3];
          for (t3 of H2)
            this[t3] = J[t3];
          for (t3 of W)
            this[t3] = J[t3];
          for (t3 of K)
            this[t3] = new G(t3, false, void 0, this);
          this.setupGlobalFilters(e3, void 0, $3);
        }
        setupFromObject(e3) {
          let t3;
          for (t3 of ($3.ifd0 = $3.ifd0 || $3.image, $3.ifd1 = $3.ifd1 || $3.thumbnail, Object.assign(this, e3), M2))
            this[t3] = ee(e3[t3], J[t3]);
          for (t3 of H2)
            this[t3] = ee(e3[t3], J[t3]);
          for (t3 of W)
            this[t3] = ee(e3[t3], J[t3]);
          for (t3 of R)
            this[t3] = new G(t3, J[t3], e3[t3], this);
          for (t3 of $3)
            this[t3] = new G(t3, J[t3], e3[t3], this.tiff);
          this.setupGlobalFilters(e3.pick, e3.skip, $3, K), true === e3.tiff ? this.batchEnableWithBool($3, true) : false === e3.tiff ? this.batchEnableWithUserValue($3, e3) : Array.isArray(e3.tiff) ? this.setupGlobalFilters(e3.tiff, void 0, $3) : "object" == typeof e3.tiff && this.setupGlobalFilters(e3.tiff.pick, e3.tiff.skip, $3);
        }
        batchEnableWithBool(e3, t3) {
          for (let s3 of e3)
            this[s3].enabled = t3;
        }
        batchEnableWithUserValue(e3, t3) {
          for (let s3 of e3) {
            let e4 = t3[s3];
            this[s3].enabled = false !== e4 && void 0 !== e4;
          }
        }
        setupGlobalFilters(e3, t3, s3, i3 = s3) {
          if (e3 && e3.length) {
            for (let e4 of i3)
              this[e4].enabled = false;
            let t4 = Z(e3, s3);
            for (let [e4, s4] of t4)
              te(this[e4].pick, s4), this[e4].enabled = true;
          } else if (t3 && t3.length) {
            let e4 = Z(t3, s3);
            for (let [t4, s4] of e4)
              te(this[t4].skip, s4);
          }
        }
        filterNestedSegmentTags() {
          let { ifd0: e3, exif: t3, xmp: s3, iptc: i3, icc: n3 } = this;
          this.makerNote ? t3.deps.add(P2) : t3.skip.add(P2), this.userComment ? t3.deps.add(z2) : t3.skip.add(z2), s3.enabled || e3.skip.add(700), i3.enabled || e3.skip.add(F2), n3.enabled || e3.skip.add(j2);
        }
        traverseTiffDependencyTree() {
          let { ifd0: e3, exif: t3, gps: s3, interop: i3 } = this;
          i3.needed && (t3.deps.add(D2), e3.deps.add(D2)), t3.needed && e3.deps.add(E2), s3.needed && e3.deps.add(_5), this.tiff.enabled = $3.some((e4) => true === this[e4].enabled) || this.makerNote || this.userComment;
          for (let e4 of $3)
            this[e4].finalizeFilters();
        }
        get onlyTiff() {
          return !N2.map((e3) => this[e3].enabled).some((e3) => true === e3) && this.tiff.enabled;
        }
        checkLoadedPlugins() {
          for (let e3 of R)
            this[e3].enabled && !b2.has(e3) && g2("segment parser", e3);
        }
      }
      function Z(e3, t3) {
        let s3, i3, n3, r3, a3 = [];
        for (n3 of t3) {
          for (r3 of (s3 = I2.get(n3), i3 = [], s3))
            (e3.includes(r3[0]) || e3.includes(r3[1])) && i3.push(r3[0]);
          i3.length && a3.push([n3, i3]);
        }
        return a3;
      }
      function ee(e3, t3) {
        return void 0 !== e3 ? e3 : void 0 !== t3 ? t3 : void 0;
      }
      function te(e3, t3) {
        for (let s3 of t3)
          e3.add(s3);
      }
      t2(Q, "default", J);
      class se {
        constructor(e3) {
          t2(this, "parsers", {}), t2(this, "output", {}), t2(this, "errors", []), t2(this, "pushToErrors", (e4) => this.errors.push(e4)), this.options = Q.useCached(e3);
        }
        async read(e3) {
          this.file = await function(e4, t3) {
            return "string" == typeof e4 ? v2(e4, t3) : i2 && !n2 && e4 instanceof HTMLImageElement ? v2(e4.src, t3) : e4 instanceof Uint8Array || e4 instanceof ArrayBuffer || e4 instanceof DataView ? new p2(e4) : i2 && e4 instanceof Blob ? S2(e4, t3, "blob", x2) : void o2(O2);
          }(e3, this.options);
        }
        setup() {
          if (this.fileParser)
            return;
          let { file: e3 } = this, t3 = e3.getUint16(0);
          for (let [s3, i3] of y2)
            if (i3.canHandle(e3, t3))
              return this.fileParser = new i3(this.options, this.file, this.parsers), e3[s3] = true;
          this.file.close && this.file.close(), o2("Unknown file format");
        }
        async parse() {
          let { output: e3, errors: t3 } = this;
          return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t3.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t3.length > 0 && (e3.errors = t3), l2(s3 = e3) ? void 0 : s3;
          var s3;
        }
        async executeParsers() {
          let { output: e3 } = this;
          await this.fileParser.parse();
          let t3 = Object.values(this.parsers).map(async (t4) => {
            let s3 = await t4.parse();
            t4.assignToOutput(e3, s3);
          });
          this.options.silentErrors && (t3 = t3.map((e4) => e4.catch(this.pushToErrors))), await Promise.all(t3);
        }
        async extractThumbnail() {
          this.setup();
          let { options: e3, file: t3 } = this, s3 = b2.get("tiff", e3);
          var i3;
          if (t3.tiff ? i3 = { start: 0, type: "tiff" } : t3.jpeg && (i3 = await this.fileParser.getOrFindSegment("tiff")), void 0 === i3)
            return;
          let n3 = await this.fileParser.ensureSegmentChunk(i3), r3 = this.parsers.tiff = new s3(n3, e3, t3), a3 = await r3.extractThumbnail();
          return t3.close && t3.close(), a3;
        }
      }
      async function ie(e3, t3) {
        let s3 = new se(t3);
        return await s3.read(e3), s3.parse();
      }
      var ne = Object.freeze({ __proto__: null, parse: ie, Exifr: se, fileParsers: y2, segmentParsers: b2, fileReaders: w2, tagKeys: I2, tagValues: L2, tagRevivers: T2, createDictionary: B2, extendDictionary: V, fetchUrlAsArrayBuffer: U, readBlobAsArrayBuffer: x2, chunkedProps: M2, otherSegments: N2, segments: R, tiffBlocks: $3, segmentsAndBlocks: K, tiffExtractables: W, inheritables: X, allFormatters: H2, Options: Q });
      class re {
        static findPosition(e3, t3) {
          let s3 = e3.getUint16(t3 + 2) + 2, i3 = "function" == typeof this.headerLength ? this.headerLength(e3, t3, s3) : this.headerLength, n3 = t3 + i3, r3 = s3 - i3;
          return { offset: t3, length: s3, headerLength: i3, start: n3, size: r3, end: n3 + r3 };
        }
        static parse(e3, t3 = {}) {
          return new this(e3, new Q({ [this.type]: t3 }), e3).parse();
        }
        normalizeInput(e3) {
          return e3 instanceof p2 ? e3 : new p2(e3);
        }
        constructor(e3, s3 = {}, i3) {
          t2(this, "errors", []), t2(this, "raw", /* @__PURE__ */ new Map()), t2(this, "handleError", (e4) => {
            if (!this.options.silentErrors)
              throw e4;
            this.errors.push(e4.message);
          }), this.chunk = this.normalizeInput(e3), this.file = i3, this.type = this.constructor.type, this.globalOptions = this.options = s3, this.localOptions = s3[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
        }
        translate() {
          this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
        }
        get output() {
          return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
        }
        translateBlock(e3, t3) {
          let s3 = T2.get(t3), i3 = L2.get(t3), n3 = I2.get(t3), r3 = this.options[t3], a3 = r3.reviveValues && !!s3, h3 = r3.translateValues && !!i3, f3 = r3.translateKeys && !!n3, l3 = {};
          for (let [t4, r4] of e3)
            a3 && s3.has(t4) ? r4 = s3.get(t4)(r4) : h3 && i3.has(t4) && (r4 = this.translateValue(r4, i3.get(t4))), f3 && n3.has(t4) && (t4 = n3.get(t4) || t4), l3[t4] = r4;
          return l3;
        }
        translateValue(e3, t3) {
          return t3[e3] || t3.DEFAULT || e3;
        }
        assignToOutput(e3, t3) {
          this.assignObjectToOutput(e3, this.constructor.type, t3);
        }
        assignObjectToOutput(e3, t3, s3) {
          if (this.globalOptions.mergeOutput)
            return Object.assign(e3, s3);
          e3[t3] ? Object.assign(e3[t3], s3) : e3[t3] = s3;
        }
      }
      t2(re, "headerLength", 4), t2(re, "type", void 0), t2(re, "multiSegment", false), t2(re, "canHandle", () => false);
      function ae(e3) {
        return 192 === e3 || 194 === e3 || 196 === e3 || 219 === e3 || 221 === e3 || 218 === e3 || 254 === e3;
      }
      function he(e3) {
        return e3 >= 224 && e3 <= 239;
      }
      function fe(e3, t3, s3) {
        for (let [i3, n3] of b2)
          if (n3.canHandle(e3, t3, s3))
            return i3;
      }
      class le extends class {
        constructor(e3, s3, i3) {
          t2(this, "errors", []), t2(this, "ensureSegmentChunk", async (e4) => {
            let t3 = e4.start, s4 = e4.size || 65536;
            if (this.file.chunked)
              if (this.file.available(t3, s4))
                e4.chunk = this.file.subarray(t3, s4);
              else
                try {
                  e4.chunk = await this.file.readChunk(t3, s4);
                } catch (t4) {
                  o2(`Couldn't read segment: ${JSON.stringify(e4)}. ${t4.message}`);
                }
            else
              this.file.byteLength > t3 + s4 ? e4.chunk = this.file.subarray(t3, s4) : void 0 === e4.size ? e4.chunk = this.file.subarray(t3) : o2("Segment unreachable: " + JSON.stringify(e4));
            return e4.chunk;
          }), this.extendOptions && this.extendOptions(e3), this.options = e3, this.file = s3, this.parsers = i3;
        }
        injectSegment(e3, t3) {
          this.options[e3].enabled && this.createParser(e3, t3);
        }
        createParser(e3, t3) {
          let s3 = new (b2.get(e3))(t3, this.options, this.file);
          return this.parsers[e3] = s3;
        }
        createParsers(e3) {
          for (let t3 of e3) {
            let { type: e4, chunk: s3 } = t3, i3 = this.options[e4];
            if (i3 && i3.enabled) {
              let t4 = this.parsers[e4];
              t4 && t4.append || t4 || this.createParser(e4, s3);
            }
          }
        }
        async readSegments(e3) {
          let t3 = e3.map(this.ensureSegmentChunk);
          await Promise.all(t3);
        }
      } {
        constructor(...e3) {
          super(...e3), t2(this, "appSegments", []), t2(this, "jpegSegments", []), t2(this, "unknownSegments", []);
        }
        static canHandle(e3, t3) {
          return 65496 === t3;
        }
        async parse() {
          await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
        }
        setupSegmentFinderArgs(e3) {
          true === e3 ? (this.findAll = true, this.wanted = new Set(b2.keyList())) : (e3 = void 0 === e3 ? b2.keyList().filter((e4) => this.options[e4].enabled) : e3.filter((e4) => this.options[e4].enabled && b2.has(e4)), this.findAll = false, this.remaining = new Set(e3), this.wanted = new Set(e3)), this.unfinishedMultiSegment = false;
        }
        async findAppSegments(e3 = 0, t3) {
          this.setupSegmentFinderArgs(t3);
          let { file: s3, findAll: i3, wanted: n3, remaining: r3 } = this;
          if (!i3 && this.file.chunked && (i3 = Array.from(n3).some((e4) => {
            let t4 = b2.get(e4), s4 = this.options[e4];
            return t4.multiSegment && s4.multiSegment;
          }), i3 && await this.file.readWhole()), e3 = this.findAppSegmentsInRange(e3, s3.byteLength), !this.options.onlyTiff && s3.chunked) {
            let t4 = false;
            for (; r3.size > 0 && !t4 && (s3.canReadNextChunk || this.unfinishedMultiSegment); ) {
              let { nextChunkOffset: i4 } = s3, n4 = this.appSegments.some((e4) => !this.file.available(e4.offset || e4.start, e4.length || e4.size));
              if (t4 = e3 > i4 && !n4 ? !await s3.readNextChunk(e3) : !await s3.readNextChunk(i4), void 0 === (e3 = this.findAppSegmentsInRange(e3, s3.byteLength)))
                return;
            }
          }
        }
        findAppSegmentsInRange(e3, t3) {
          t3 -= 2;
          let s3, i3, n3, r3, a3, h3, { file: f3, findAll: l3, wanted: o3, remaining: u3, options: d3 } = this;
          for (; e3 < t3; e3++)
            if (255 === f3.getUint8(e3)) {
              if (s3 = f3.getUint8(e3 + 1), he(s3)) {
                if (i3 = f3.getUint16(e3 + 2), n3 = fe(f3, e3, i3), n3 && o3.has(n3) && (r3 = b2.get(n3), a3 = r3.findPosition(f3, e3), h3 = d3[n3], a3.type = n3, this.appSegments.push(a3), !l3 && (r3.multiSegment && h3.multiSegment ? (this.unfinishedMultiSegment = a3.chunkNumber < a3.chunkCount, this.unfinishedMultiSegment || u3.delete(n3)) : u3.delete(n3), 0 === u3.size)))
                  break;
                d3.recordUnknownSegments && (a3 = re.findPosition(f3, e3), a3.marker = s3, this.unknownSegments.push(a3)), e3 += i3 + 1;
              } else if (ae(s3)) {
                if (i3 = f3.getUint16(e3 + 2), 218 === s3 && false !== d3.stopAfterSos)
                  return;
                d3.recordJpegSegments && this.jpegSegments.push({ offset: e3, length: i3, marker: s3 }), e3 += i3 + 1;
              }
            }
          return e3;
        }
        mergeMultiSegments() {
          if (!this.appSegments.some((e4) => e4.multiSegment))
            return;
          let e3 = function(e4, t3) {
            let s3, i3, n3, r3 = /* @__PURE__ */ new Map();
            for (let a3 = 0; a3 < e4.length; a3++)
              s3 = e4[a3], i3 = s3[t3], r3.has(i3) ? n3 = r3.get(i3) : r3.set(i3, n3 = []), n3.push(s3);
            return Array.from(r3);
          }(this.appSegments, "type");
          this.mergedAppSegments = e3.map(([e4, t3]) => {
            let s3 = b2.get(e4, this.options);
            if (s3.handleMultiSegments) {
              return { type: e4, chunk: s3.handleMultiSegments(t3) };
            }
            return t3[0];
          });
        }
        getSegment(e3) {
          return this.appSegments.find((t3) => t3.type === e3);
        }
        async getOrFindSegment(e3) {
          let t3 = this.getSegment(e3);
          return void 0 === t3 && (await this.findAppSegments(0, [e3]), t3 = this.getSegment(e3)), t3;
        }
      }
      t2(le, "type", "jpeg"), y2.set("jpeg", le);
      const oe = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
      class ue extends re {
        parseHeader() {
          var e3 = this.chunk.getUint16();
          18761 === e3 ? this.le = true : 19789 === e3 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
        }
        parseTags(e3, t3, s3 = /* @__PURE__ */ new Map()) {
          let { pick: i3, skip: n3 } = this.options[t3];
          i3 = new Set(i3);
          let r3 = i3.size > 0, a3 = 0 === n3.size, h3 = this.chunk.getUint16(e3);
          e3 += 2;
          for (let f3 = 0; f3 < h3; f3++) {
            let h4 = this.chunk.getUint16(e3);
            if (r3) {
              if (i3.has(h4) && (s3.set(h4, this.parseTag(e3, h4, t3)), i3.delete(h4), 0 === i3.size))
                break;
            } else
              !a3 && n3.has(h4) || s3.set(h4, this.parseTag(e3, h4, t3));
            e3 += 12;
          }
          return s3;
        }
        parseTag(e3, t3, s3) {
          let { chunk: i3 } = this, n3 = i3.getUint16(e3 + 2), r3 = i3.getUint32(e3 + 4), a3 = oe[n3];
          if (a3 * r3 <= 4 ? e3 += 8 : e3 = i3.getUint32(e3 + 8), (n3 < 1 || n3 > 13) && o2(`Invalid TIFF value type. block: ${s3.toUpperCase()}, tag: ${t3.toString(16)}, type: ${n3}, offset ${e3}`), e3 > i3.byteLength && o2(`Invalid TIFF value offset. block: ${s3.toUpperCase()}, tag: ${t3.toString(16)}, type: ${n3}, offset ${e3} is outside of chunk size ${i3.byteLength}`), 1 === n3)
            return i3.getUint8Array(e3, r3);
          if (2 === n3)
            return "" === (h3 = function(e4) {
              for (; e4.endsWith("\0"); )
                e4 = e4.slice(0, -1);
              return e4;
            }(h3 = i3.getString(e3, r3)).trim()) ? void 0 : h3;
          var h3;
          if (7 === n3)
            return i3.getUint8Array(e3, r3);
          if (1 === r3)
            return this.parseTagValue(n3, e3);
          {
            let t4 = new (function(e4) {
              switch (e4) {
                case 1:
                  return Uint8Array;
                case 3:
                  return Uint16Array;
                case 4:
                  return Uint32Array;
                case 5:
                  return Array;
                case 6:
                  return Int8Array;
                case 8:
                  return Int16Array;
                case 9:
                  return Int32Array;
                case 10:
                  return Array;
                case 11:
                  return Float32Array;
                case 12:
                  return Float64Array;
                default:
                  return Array;
              }
            }(n3))(r3), s4 = a3;
            for (let i4 = 0; i4 < r3; i4++)
              t4[i4] = this.parseTagValue(n3, e3), e3 += s4;
            return t4;
          }
        }
        parseTagValue(e3, t3) {
          let { chunk: s3 } = this;
          switch (e3) {
            case 1:
              return s3.getUint8(t3);
            case 3:
              return s3.getUint16(t3);
            case 4:
              return s3.getUint32(t3);
            case 5:
              return s3.getUint32(t3) / s3.getUint32(t3 + 4);
            case 6:
              return s3.getInt8(t3);
            case 8:
              return s3.getInt16(t3);
            case 9:
              return s3.getInt32(t3);
            case 10:
              return s3.getInt32(t3) / s3.getInt32(t3 + 4);
            case 11:
              return s3.getFloat(t3);
            case 12:
              return s3.getDouble(t3);
            case 13:
              return s3.getUint32(t3);
            default:
              o2(`Invalid tiff type ${e3}`);
          }
        }
      }
      class de extends ue {
        static canHandle(e3, t3) {
          return 225 === e3.getUint8(t3 + 1) && 1165519206 === e3.getUint32(t3 + 4) && 0 === e3.getUint16(t3 + 8);
        }
        async parse() {
          this.parseHeader();
          let { options: e3 } = this;
          return e3.ifd0.enabled && await this.parseIfd0Block(), e3.exif.enabled && await this.safeParse("parseExifBlock"), e3.gps.enabled && await this.safeParse("parseGpsBlock"), e3.interop.enabled && await this.safeParse("parseInteropBlock"), e3.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
        }
        safeParse(e3) {
          let t3 = this[e3]();
          return void 0 !== t3.catch && (t3 = t3.catch(this.handleError)), t3;
        }
        findIfd0Offset() {
          void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
        }
        findIfd1Offset() {
          if (void 0 === this.ifd1Offset) {
            this.findIfd0Offset();
            let e3 = this.chunk.getUint16(this.ifd0Offset), t3 = this.ifd0Offset + 2 + 12 * e3;
            this.ifd1Offset = this.chunk.getUint32(t3);
          }
        }
        parseBlock(e3, t3) {
          let s3 = /* @__PURE__ */ new Map();
          return this[t3] = s3, this.parseTags(e3, t3, s3), s3;
        }
        async parseIfd0Block() {
          if (this.ifd0)
            return;
          let { file: e3 } = this;
          this.findIfd0Offset(), this.ifd0Offset < 8 && o2("Malformed EXIF data"), !e3.chunked && this.ifd0Offset > e3.byteLength && o2(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e3.byteLength}`), e3.tiff && await e3.ensureChunk(this.ifd0Offset, u2(this.options));
          let t3 = this.parseBlock(this.ifd0Offset, "ifd0");
          return 0 !== t3.size ? (this.exifOffset = t3.get(E2), this.interopOffset = t3.get(D2), this.gpsOffset = t3.get(_5), this.xmp = t3.get(700), this.iptc = t3.get(F2), this.icc = t3.get(j2), this.options.sanitize && (t3.delete(E2), t3.delete(D2), t3.delete(_5), t3.delete(700), t3.delete(F2), t3.delete(j2)), t3) : void 0;
        }
        async parseExifBlock() {
          if (this.exif)
            return;
          if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset)
            return;
          this.file.tiff && await this.file.ensureChunk(this.exifOffset, u2(this.options));
          let e3 = this.parseBlock(this.exifOffset, "exif");
          return this.interopOffset || (this.interopOffset = e3.get(D2)), this.makerNote = e3.get(P2), this.userComment = e3.get(z2), this.options.sanitize && (e3.delete(D2), e3.delete(P2), e3.delete(z2)), this.unpack(e3, 41728), this.unpack(e3, 41729), e3;
        }
        unpack(e3, t3) {
          let s3 = e3.get(t3);
          s3 && 1 === s3.length && e3.set(t3, s3[0]);
        }
        async parseGpsBlock() {
          if (this.gps)
            return;
          if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset)
            return;
          let e3 = this.parseBlock(this.gpsOffset, "gps");
          return e3 && e3.has(2) && e3.has(4) && (e3.set("latitude", ce(...e3.get(2), e3.get(1))), e3.set("longitude", ce(...e3.get(4), e3.get(3)))), e3;
        }
        async parseInteropBlock() {
          if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset))
            return this.parseBlock(this.interopOffset, "interop");
        }
        async parseThumbnailBlock(e3 = false) {
          if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e3))
            return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
        }
        async extractThumbnail() {
          if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1)
            return;
          let e3 = this.ifd1.get(513), t3 = this.ifd1.get(514);
          return this.chunk.getUint8Array(e3, t3);
        }
        get image() {
          return this.ifd0;
        }
        get thumbnail() {
          return this.ifd1;
        }
        createOutput() {
          let e3, t3, s3, i3 = {};
          for (t3 of $3)
            if (e3 = this[t3], !l2(e3))
              if (s3 = this.canTranslate ? this.translateBlock(e3, t3) : Object.fromEntries(e3), this.options.mergeOutput) {
                if ("ifd1" === t3)
                  continue;
                Object.assign(i3, s3);
              } else
                i3[t3] = s3;
          return this.makerNote && (i3.makerNote = this.makerNote), this.userComment && (i3.userComment = this.userComment), i3;
        }
        assignToOutput(e3, t3) {
          if (this.globalOptions.mergeOutput)
            Object.assign(e3, t3);
          else
            for (let [s3, i3] of Object.entries(t3))
              this.assignObjectToOutput(e3, s3, i3);
        }
      }
      function ce(e3, t3, s3, i3) {
        var n3 = e3 + t3 / 60 + s3 / 3600;
        return "S" !== i3 && "W" !== i3 || (n3 *= -1), n3;
      }
      t2(de, "type", "tiff"), t2(de, "headerLength", 10), b2.set("tiff", de);
      var pe = Object.freeze({ __proto__: null, default: ne, Exifr: se, fileParsers: y2, segmentParsers: b2, fileReaders: w2, tagKeys: I2, tagValues: L2, tagRevivers: T2, createDictionary: B2, extendDictionary: V, fetchUrlAsArrayBuffer: U, readBlobAsArrayBuffer: x2, chunkedProps: M2, otherSegments: N2, segments: R, tiffBlocks: $3, segmentsAndBlocks: K, tiffExtractables: W, inheritables: X, allFormatters: H2, Options: Q, parse: ie });
      const ge = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false }, me = Object.assign({}, ge, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
      const ye = Object.assign({}, ge, { tiff: false, ifd1: true, mergeOutput: false });
      const be = Object.assign({}, ge, { firstChunkSize: 4e4, ifd0: [274] });
      async function we(e3) {
        let t3 = new se(be);
        await t3.read(e3);
        let s3 = await t3.parse();
        if (s3 && s3.ifd0)
          return s3.ifd0[274];
      }
      const ke = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
      if (e2.rotateCanvas = true, e2.rotateCss = true, "object" == typeof navigator) {
        let t3 = navigator.userAgent;
        if (t3.includes("iPad") || t3.includes("iPhone")) {
          let s3 = t3.match(/OS (\d+)_(\d+)/);
          if (s3) {
            let [, t4, i3] = s3, n3 = Number(t4) + 0.1 * Number(i3);
            e2.rotateCanvas = n3 < 13.4, e2.rotateCss = false;
          }
        } else if (t3.includes("OS X 10")) {
          let [, s3] = t3.match(/OS X 10[_.](\d+)/);
          e2.rotateCanvas = e2.rotateCss = Number(s3) < 15;
        }
        if (t3.includes("Chrome/")) {
          let [, s3] = t3.match(/Chrome\/(\d+)/);
          e2.rotateCanvas = e2.rotateCss = Number(s3) < 81;
        } else if (t3.includes("Firefox/")) {
          let [, s3] = t3.match(/Firefox\/(\d+)/);
          e2.rotateCanvas = e2.rotateCss = Number(s3) < 77;
        }
      }
      class Oe extends p2 {
        constructor(...e3) {
          super(...e3), t2(this, "ranges", new ve()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
        }
        _tryExtend(e3, t3, s3) {
          if (0 === e3 && 0 === this.byteLength && s3) {
            let e4 = new DataView(s3.buffer || s3, s3.byteOffset, s3.byteLength);
            this._swapDataView(e4);
          } else {
            let s4 = e3 + t3;
            if (s4 > this.byteLength) {
              let { dataView: e4 } = this._extend(s4);
              this._swapDataView(e4);
            }
          }
        }
        _extend(e3) {
          let t3;
          t3 = h2 ? a2.allocUnsafe(e3) : new Uint8Array(e3);
          let s3 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
          return t3.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t3, dataView: s3 };
        }
        subarray(e3, t3, s3 = false) {
          return t3 = t3 || this._lengthToEnd(e3), s3 && this._tryExtend(e3, t3), this.ranges.add(e3, t3), super.subarray(e3, t3);
        }
        set(e3, t3, s3 = false) {
          s3 && this._tryExtend(t3, e3.byteLength, e3);
          let i3 = super.set(e3, t3);
          return this.ranges.add(t3, i3.byteLength), i3;
        }
        async ensureChunk(e3, t3) {
          this.chunked && (this.ranges.available(e3, t3) || await this.readChunk(e3, t3));
        }
        available(e3, t3) {
          return this.ranges.available(e3, t3);
        }
      }
      class ve {
        constructor() {
          t2(this, "list", []);
        }
        get length() {
          return this.list.length;
        }
        add(e3, t3, s3 = 0) {
          let i3 = e3 + t3, n3 = this.list.filter((t4) => Se(e3, t4.offset, i3) || Se(e3, t4.end, i3));
          if (n3.length > 0) {
            e3 = Math.min(e3, ...n3.map((e4) => e4.offset)), i3 = Math.max(i3, ...n3.map((e4) => e4.end)), t3 = i3 - e3;
            let s4 = n3.shift();
            s4.offset = e3, s4.length = t3, s4.end = i3, this.list = this.list.filter((e4) => !n3.includes(e4));
          } else
            this.list.push({ offset: e3, length: t3, end: i3 });
        }
        available(e3, t3) {
          let s3 = e3 + t3;
          return this.list.some((t4) => t4.offset <= e3 && s3 <= t4.end);
        }
      }
      function Se(e3, t3, s3) {
        return e3 <= t3 && t3 <= s3;
      }
      class Ae extends Oe {
        constructor(e3, s3) {
          super(0), t2(this, "chunksRead", 0), this.input = e3, this.options = s3;
        }
        async readWhole() {
          this.chunked = false, await this.readChunk(this.nextChunkOffset);
        }
        async readChunked() {
          this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
        }
        async readNextChunk(e3 = this.nextChunkOffset) {
          if (this.fullyRead)
            return this.chunksRead++, false;
          let t3 = this.options.chunkSize, s3 = await this.readChunk(e3, t3);
          return !!s3 && s3.byteLength === t3;
        }
        async readChunk(e3, t3) {
          if (this.chunksRead++, 0 !== (t3 = this.safeWrapAddress(e3, t3)))
            return this._readChunk(e3, t3);
        }
        safeWrapAddress(e3, t3) {
          return void 0 !== this.size && e3 + t3 > this.size ? Math.max(0, this.size - e3) : t3;
        }
        get nextChunkOffset() {
          if (0 !== this.ranges.list.length)
            return this.ranges.list[0].length;
        }
        get canReadNextChunk() {
          return this.chunksRead < this.options.chunkLimit;
        }
        get fullyRead() {
          return void 0 !== this.size && this.nextChunkOffset === this.size;
        }
        read() {
          return this.options.chunked ? this.readChunked() : this.readWhole();
        }
        close() {
        }
      }
      w2.set("blob", class extends Ae {
        async readWhole() {
          this.chunked = false;
          let e3 = await x2(this.input);
          this._swapArrayBuffer(e3);
        }
        readChunked() {
          return this.chunked = true, this.size = this.input.size, super.readChunked();
        }
        async _readChunk(e3, t3) {
          let s3 = t3 ? e3 + t3 : void 0, i3 = this.input.slice(e3, s3), n3 = await x2(i3);
          return this.set(n3, e3, true);
        }
      }), e2.Exifr = se, e2.Options = Q, e2.allFormatters = H2, e2.chunkedProps = M2, e2.createDictionary = B2, e2.default = pe, e2.extendDictionary = V, e2.fetchUrlAsArrayBuffer = U, e2.fileParsers = y2, e2.fileReaders = w2, e2.gps = async function(e3) {
        let t3 = new se(me);
        await t3.read(e3);
        let s3 = await t3.parse();
        if (s3 && s3.gps) {
          let { latitude: e4, longitude: t4 } = s3.gps;
          return { latitude: e4, longitude: t4 };
        }
      }, e2.gpsOnlyOptions = me, e2.inheritables = X, e2.orientation = we, e2.orientationOnlyOptions = be, e2.otherSegments = N2, e2.parse = ie, e2.readBlobAsArrayBuffer = x2, e2.rotation = async function(t3) {
        let s3 = await we(t3);
        return Object.assign({ canvas: e2.rotateCanvas, css: e2.rotateCss }, ke[s3]);
      }, e2.rotations = ke, e2.segmentParsers = b2, e2.segments = R, e2.segmentsAndBlocks = K, e2.tagKeys = I2, e2.tagRevivers = T2, e2.tagValues = L2, e2.thumbnail = async function(e3) {
        let t3 = new se(ye);
        await t3.read(e3);
        let s3 = await t3.extractThumbnail();
        return s3 && h2 ? a2.from(s3) : s3;
      }, e2.thumbnailOnlyOptions = ye, e2.thumbnailUrl = async function(e3) {
        let t3 = await this.thumbnail(e3);
        if (void 0 !== t3) {
          let e4 = new Blob([t3]);
          return URL.createObjectURL(e4);
        }
      }, e2.tiffBlocks = $3, e2.tiffExtractables = W, Object.defineProperty(e2, "__esModule", { value: true });
    });
  }
});

// node_modules/@uppy/utils/lib/dataURItoBlob.js
var require_dataURItoBlob = __commonJS({
  "node_modules/@uppy/utils/lib/dataURItoBlob.js"(exports, module) {
    "use strict";
    var DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
    function dataURItoBlob(dataURI, opts, toFile) {
      var _ref, _opts$mimeType;
      const dataURIData = DATA_URL_PATTERN.exec(dataURI);
      const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : "plain/text";
      let data;
      if (dataURIData[2] != null) {
        const binary = atob(decodeURIComponent(dataURIData[3]));
        const bytes = new Uint8Array(binary.length);
        for (let i2 = 0; i2 < binary.length; i2++) {
          bytes[i2] = binary.charCodeAt(i2);
        }
        data = [bytes];
      } else {
        data = [decodeURIComponent(dataURIData[3])];
      }
      if (toFile) {
        return new File(data, opts.name || "", {
          type: mimeType
        });
      }
      return new Blob(data, {
        type: mimeType
      });
    }
    module.exports = dataURItoBlob;
  }
});

// node_modules/@uppy/utils/lib/isObjectURL.js
var require_isObjectURL = __commonJS({
  "node_modules/@uppy/utils/lib/isObjectURL.js"(exports, module) {
    "use strict";
    function isObjectURL(url2) {
      return url2.startsWith("blob:");
    }
    module.exports = isObjectURL;
  }
});

// node_modules/@uppy/utils/lib/isPreviewSupported.js
var require_isPreviewSupported = __commonJS({
  "node_modules/@uppy/utils/lib/isPreviewSupported.js"(exports, module) {
    "use strict";
    function isPreviewSupported(fileType) {
      if (!fileType)
        return false;
      return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
    }
    module.exports = isPreviewSupported;
  }
});

// node_modules/@uppy/thumbnail-generator/lib/locale.js
var require_locale3 = __commonJS({
  "node_modules/@uppy/thumbnail-generator/lib/locale.js"(exports, module) {
    "use strict";
    module.exports = {
      strings: {
        generatingThumbnails: "Generating thumbnails..."
      }
    };
  }
});

// node_modules/@uppy/thumbnail-generator/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@uppy/thumbnail-generator/lib/index.js"(exports, module) {
    "use strict";
    var _core = require_lib2();
    var _miniUmd = require_mini_umd();
    var dataURItoBlob = require_dataURItoBlob();
    var isObjectURL = require_isObjectURL();
    var isPreviewSupported = require_isPreviewSupported();
    var locale = require_locale3();
    var packageJson = {
      "version": "2.2.2"
    };
    function canvasToBlob(canvas, type, quality) {
      try {
        canvas.getContext("2d").getImageData(0, 0, 1, 1);
      } catch (err) {
        if (err.code === 18) {
          return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
        }
      }
      if (canvas.toBlob) {
        return new Promise((resolve) => {
          canvas.toBlob(resolve, type, quality);
        }).then((blob) => {
          if (blob === null) {
            throw new Error("cannot read image, probably an svg with external resources");
          }
          return blob;
        });
      }
      return Promise.resolve().then(() => {
        return dataURItoBlob(canvas.toDataURL(type, quality), {});
      }).then((blob) => {
        if (blob === null) {
          throw new Error("could not extract blob, probably an old browser");
        }
        return blob;
      });
    }
    function rotateImage(image, translate) {
      let w2 = image.width;
      let h2 = image.height;
      if (translate.deg === 90 || translate.deg === 270) {
        w2 = image.height;
        h2 = image.width;
      }
      const canvas = document.createElement("canvas");
      canvas.width = w2;
      canvas.height = h2;
      const context = canvas.getContext("2d");
      context.translate(w2 / 2, h2 / 2);
      if (translate.canvas) {
        context.rotate(translate.rad);
        context.scale(translate.scaleX, translate.scaleY);
      }
      context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
      return canvas;
    }
    function protect(image) {
      const ratio = image.width / image.height;
      const maxSquare = 5e6;
      const maxSize = 4096;
      let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
      let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));
      if (maxW > maxSize) {
        maxW = maxSize;
        maxH = Math.round(maxW / ratio);
      }
      if (maxH > maxSize) {
        maxH = maxSize;
        maxW = Math.round(ratio * maxH);
      }
      if (image.width > maxW) {
        const canvas = document.createElement("canvas");
        canvas.width = maxW;
        canvas.height = maxH;
        canvas.getContext("2d").drawImage(image, 0, 0, maxW, maxH);
        return canvas;
      }
      return image;
    }
    var ThumbnailGenerator = class extends _core.UIPlugin {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.onFileAdded = (file) => {
          if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
            this.addToQueue(file.id);
          }
        };
        this.onCancelRequest = (file) => {
          const index = this.queue.indexOf(file.id);
          if (index !== -1) {
            this.queue.splice(index, 1);
          }
        };
        this.onFileRemoved = (file) => {
          const index = this.queue.indexOf(file.id);
          if (index !== -1) {
            this.queue.splice(index, 1);
          }
          if (file.preview && isObjectURL(file.preview)) {
            URL.revokeObjectURL(file.preview);
          }
        };
        this.onRestored = () => {
          const restoredFiles = this.uppy.getFiles().filter((file) => file.isRestored);
          restoredFiles.forEach((file) => {
            if (!file.preview || isObjectURL(file.preview)) {
              this.addToQueue(file.id);
            }
          });
        };
        this.onAllFilesRemoved = () => {
          this.queue = [];
        };
        this.waitUntilAllProcessed = (fileIDs) => {
          fileIDs.forEach((fileID) => {
            const file = this.uppy.getFile(fileID);
            this.uppy.emit("preprocess-progress", file, {
              mode: "indeterminate",
              message: this.i18n("generatingThumbnails")
            });
          });
          const emitPreprocessCompleteForAll = () => {
            fileIDs.forEach((fileID) => {
              const file = this.uppy.getFile(fileID);
              this.uppy.emit("preprocess-complete", file);
            });
          };
          return new Promise((resolve) => {
            if (this.queueProcessing) {
              this.uppy.once("thumbnail:all-generated", () => {
                emitPreprocessCompleteForAll();
                resolve();
              });
            } else {
              emitPreprocessCompleteForAll();
              resolve();
            }
          });
        };
        this.type = "modifier";
        this.id = this.opts.id || "ThumbnailGenerator";
        this.title = "Thumbnail Generator";
        this.queue = [];
        this.queueProcessing = false;
        this.defaultThumbnailDimension = 200;
        this.thumbnailType = this.opts.thumbnailType || "image/jpeg";
        this.defaultLocale = locale;
        const defaultOptions = {
          thumbnailWidth: null,
          thumbnailHeight: null,
          waitForThumbnailsBeforeUpload: false,
          lazy: false
        };
        this.opts = {
          ...defaultOptions,
          ...opts
        };
        this.i18nInit();
        if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) {
          throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
        }
      }
      createThumbnail(file, targetWidth, targetHeight) {
        const originalUrl = URL.createObjectURL(file.data);
        const onload = new Promise((resolve, reject) => {
          const image = new Image();
          image.src = originalUrl;
          image.addEventListener("load", () => {
            URL.revokeObjectURL(originalUrl);
            resolve(image);
          });
          image.addEventListener("error", (event2) => {
            URL.revokeObjectURL(originalUrl);
            reject(event2.error || new Error("Could not create thumbnail"));
          });
        });
        const orientationPromise = (0, _miniUmd.rotation)(file.data).catch(() => 1);
        return Promise.all([onload, orientationPromise]).then((_ref) => {
          let [image, orientation] = _ref;
          const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
          const rotatedImage = this.rotateImage(image, orientation);
          const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
          return this.canvasToBlob(resizedImage, this.thumbnailType, 80);
        }).then((blob) => {
          return URL.createObjectURL(blob);
        });
      }
      getProportionalDimensions(img, width, height, rotation) {
        let aspect = img.width / img.height;
        if (rotation === 90 || rotation === 270) {
          aspect = img.height / img.width;
        }
        if (width != null) {
          return {
            width,
            height: Math.round(width / aspect)
          };
        }
        if (height != null) {
          return {
            width: Math.round(height * aspect),
            height
          };
        }
        return {
          width: this.defaultThumbnailDimension,
          height: Math.round(this.defaultThumbnailDimension / aspect)
        };
      }
      resizeImage(image, targetWidth, targetHeight) {
        let img = this.protect(image);
        let steps = Math.ceil(Math.log2(img.width / targetWidth));
        if (steps < 1) {
          steps = 1;
        }
        let sW = targetWidth * 2 ** (steps - 1);
        let sH = targetHeight * 2 ** (steps - 1);
        const x2 = 2;
        while (steps--) {
          const canvas = document.createElement("canvas");
          canvas.width = sW;
          canvas.height = sH;
          canvas.getContext("2d").drawImage(img, 0, 0, sW, sH);
          img = canvas;
          sW = Math.round(sW / x2);
          sH = Math.round(sH / x2);
        }
        return img;
      }
      setPreviewURL(fileID, preview) {
        this.uppy.setFileState(fileID, {
          preview
        });
      }
      addToQueue(item) {
        this.queue.push(item);
        if (this.queueProcessing === false) {
          this.processQueue();
        }
      }
      processQueue() {
        this.queueProcessing = true;
        if (this.queue.length > 0) {
          const current = this.uppy.getFile(this.queue.shift());
          if (!current) {
            this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error");
            return Promise.resolve();
          }
          return this.requestThumbnail(current).catch(() => {
          }).then(() => this.processQueue());
        }
        this.queueProcessing = false;
        this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue");
        this.uppy.emit("thumbnail:all-generated");
        return Promise.resolve();
      }
      requestThumbnail(file) {
        if (isPreviewSupported(file.type) && !file.isRemote) {
          return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((preview) => {
            this.setPreviewURL(file.id, preview);
            this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
            this.uppy.emit("thumbnail:generated", this.uppy.getFile(file.id), preview);
          }).catch((err) => {
            this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, "warning");
            this.uppy.log(err, "warning");
            this.uppy.emit("thumbnail:error", this.uppy.getFile(file.id), err);
          });
        }
        return Promise.resolve();
      }
      install() {
        this.uppy.on("file-removed", this.onFileRemoved);
        this.uppy.on("cancel-all", this.onAllFilesRemoved);
        if (this.opts.lazy) {
          this.uppy.on("thumbnail:request", this.onFileAdded);
          this.uppy.on("thumbnail:cancel", this.onCancelRequest);
        } else {
          this.uppy.on("file-added", this.onFileAdded);
          this.uppy.on("restored", this.onRestored);
        }
        if (this.opts.waitForThumbnailsBeforeUpload) {
          this.uppy.addPreProcessor(this.waitUntilAllProcessed);
        }
      }
      uninstall() {
        this.uppy.off("file-removed", this.onFileRemoved);
        this.uppy.off("cancel-all", this.onAllFilesRemoved);
        if (this.opts.lazy) {
          this.uppy.off("thumbnail:request", this.onFileAdded);
          this.uppy.off("thumbnail:cancel", this.onCancelRequest);
        } else {
          this.uppy.off("file-added", this.onFileAdded);
          this.uppy.off("restored", this.onRestored);
        }
        if (this.opts.waitForThumbnailsBeforeUpload) {
          this.uppy.removePreProcessor(this.waitUntilAllProcessed);
        }
      }
    };
    ThumbnailGenerator.VERSION = packageJson.version;
    module.exports = ThumbnailGenerator;
    ThumbnailGenerator.prototype.canvasToBlob = canvasToBlob;
    ThumbnailGenerator.prototype.protect = protect;
    ThumbnailGenerator.prototype.rotateImage = rotateImage;
  }
});

// node_modules/@uppy/utils/lib/findAllDOMElements.js
var require_findAllDOMElements = __commonJS({
  "node_modules/@uppy/utils/lib/findAllDOMElements.js"(exports, module) {
    "use strict";
    var isDOMElement = require_isDOMElement();
    function findAllDOMElements(element) {
      if (typeof element === "string") {
        const elements = document.querySelectorAll(element);
        return elements.length === 0 ? null : Array.from(elements);
      }
      if (typeof element === "object" && isDOMElement(element)) {
        return [element];
      }
      return null;
    }
    module.exports = findAllDOMElements;
  }
});

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js
var require_getFilesAndDirectoriesFromDirectory = __commonJS({
  "node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js"(exports, module) {
    "use strict";
    function getFilesAndDirectoriesFromDirectory2(directoryReader, oldEntries, logDropError, _ref) {
      let {
        onSuccess
      } = _ref;
      directoryReader.readEntries(
        (entries) => {
          const newEntries = [...oldEntries, ...entries];
          if (entries.length) {
            queueMicrotask(() => {
              getFilesAndDirectoriesFromDirectory2(directoryReader, newEntries, logDropError, {
                onSuccess
              });
            });
          } else {
            onSuccess(newEntries);
          }
        },
        (error) => {
          logDropError(error);
          onSuccess(oldEntries);
        }
      );
    }
    module.exports = getFilesAndDirectoriesFromDirectory2;
  }
});

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js
var require_webkitGetAsEntryApi = __commonJS({
  "node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js"(exports, module) {
    "use strict";
    var getFilesAndDirectoriesFromDirectory2 = require_getFilesAndDirectoriesFromDirectory();
    function getAsFileSystemHandleFromEntry(entry, logDropError) {
      if (entry == null)
        return entry;
      return {
        kind: entry.isFile ? "file" : entry.isDirectory ? "directory" : void 0,
        name: entry.name,
        getFile() {
          return new Promise((resolve, reject) => entry.file(resolve, reject));
        },
        async *values() {
          const directoryReader = entry.createReader();
          const entries = await new Promise((resolve) => {
            getFilesAndDirectoriesFromDirectory2(directoryReader, [], logDropError, {
              onSuccess: (dirEntries) => resolve(dirEntries.map((file) => getAsFileSystemHandleFromEntry(file, logDropError)))
            });
          });
          yield* entries;
        }
      };
    }
    async function* createPromiseToAddFileOrParseDirectory(entry, relativePath) {
      if (entry.kind === "file") {
        const file = await entry.getFile();
        if (file !== null) {
          file.relativePath = relativePath ? `${relativePath}/${entry.name}` : null;
          yield file;
        }
      } else if (entry.kind === "directory") {
        for await (const handle of entry.values()) {
          yield* createPromiseToAddFileOrParseDirectory(handle, `${relativePath}/${entry.name}`);
        }
      }
    }
    async function* getFilesFromDataTransfer(dataTransfer, logDropError) {
      const entries = await Promise.all(Array.from(dataTransfer.items, async (item) => {
        var _await$item$getAsFile;
        const lastResortFile = item.getAsFile();
        const entry = (_await$item$getAsFile = await (item.getAsFileSystemHandle == null ? void 0 : item.getAsFileSystemHandle())) != null ? _await$item$getAsFile : getAsFileSystemHandleFromEntry(item.webkitGetAsEntry(), logDropError);
        return {
          lastResortFile,
          entry
        };
      }));
      for (const {
        lastResortFile,
        entry
      } of entries) {
        if (entry != null) {
          try {
            yield* createPromiseToAddFileOrParseDirectory(entry, "");
          } catch (err) {
            if (lastResortFile) {
              yield lastResortFile;
            } else {
              logDropError(err);
            }
          }
        }
      }
    }
    module.exports = getFilesFromDataTransfer;
  }
});

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/fallbackApi.js
var require_fallbackApi = __commonJS({
  "node_modules/@uppy/utils/lib/getDroppedFiles/utils/fallbackApi.js"(exports, module) {
    "use strict";
    var toArray = require_toArray();
    function fallbackApi(dataTransfer) {
      const files = toArray(dataTransfer.files);
      return Promise.resolve(files);
    }
    module.exports = fallbackApi;
  }
});

// node_modules/@uppy/utils/lib/getDroppedFiles/index.js
var require_getDroppedFiles = __commonJS({
  "node_modules/@uppy/utils/lib/getDroppedFiles/index.js"(exports, module) {
    "use strict";
    var webkitGetAsEntryApi = require_webkitGetAsEntryApi();
    var fallbackApi = require_fallbackApi();
    async function getDroppedFiles(dataTransfer, _temp) {
      let {
        logDropError = () => {
        }
      } = _temp === void 0 ? {} : _temp;
      try {
        const accumulator = [];
        for await (const file of webkitGetAsEntryApi(dataTransfer, logDropError)) {
          accumulator.push(file);
        }
        return accumulator;
      } catch {
        return fallbackApi(dataTransfer);
      }
    }
    module.exports = getDroppedFiles;
  }
});

// node_modules/memoize-one/dist/memoize-one.cjs.js
var require_memoize_one_cjs = __commonJS({
  "node_modules/memoize-one/dist/memoize-one.cjs.js"(exports, module) {
    "use strict";
    var safeIsNaN = Number.isNaN || function ponyfill(value) {
      return typeof value === "number" && value !== value;
    };
    function isEqual(first, second) {
      if (first === second) {
        return true;
      }
      if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
      }
      return false;
    }
    function areInputsEqual(newInputs, lastInputs) {
      if (newInputs.length !== lastInputs.length) {
        return false;
      }
      for (var i2 = 0; i2 < newInputs.length; i2++) {
        if (!isEqual(newInputs[i2], lastInputs[i2])) {
          return false;
        }
      }
      return true;
    }
    function memoizeOne(resultFn, isEqual2) {
      if (isEqual2 === void 0) {
        isEqual2 = areInputsEqual;
      }
      var lastThis;
      var lastArgs = [];
      var lastResult;
      var calledOnce = false;
      function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
          return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
      }
      return memoized;
    }
    module.exports = memoizeOne;
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce;
  }
});

// node_modules/@uppy/dashboard/lib/utils/createSuperFocus.js
var require_createSuperFocus = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/createSuperFocus.js"(exports, module) {
    "use strict";
    var debounce = require_lodash3();
    var FOCUSABLE_ELEMENTS = require_FOCUSABLE_ELEMENTS();
    var getActiveOverlayEl = require_getActiveOverlayEl();
    function createSuperFocus() {
      let lastFocusWasOnSuperFocusableEl = false;
      const superFocus = (dashboardEl, activeOverlayType) => {
        const overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
        const isFocusInOverlay = overlayEl.contains(document.activeElement);
        if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl)
          return;
        const superFocusableEl = overlayEl.querySelector("[data-uppy-super-focusable]");
        if (isFocusInOverlay && !superFocusableEl)
          return;
        if (superFocusableEl) {
          superFocusableEl.focus({
            preventScroll: true
          });
          lastFocusWasOnSuperFocusableEl = true;
        } else {
          const firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
          firstEl == null ? void 0 : firstEl.focus({
            preventScroll: true
          });
          lastFocusWasOnSuperFocusableEl = false;
        }
      };
      return debounce(superFocus, 260);
    }
    module.exports = createSuperFocus;
  }
});

// node_modules/@uppy/utils/lib/isDragDropSupported.js
var require_isDragDropSupported = __commonJS({
  "node_modules/@uppy/utils/lib/isDragDropSupported.js"(exports, module) {
    "use strict";
    function isDragDropSupported() {
      const div = document.body;
      if (!("draggable" in div) || !("ondragstart" in div && "ondrop" in div)) {
        return false;
      }
      if (!("FormData" in window)) {
        return false;
      }
      if (!("FileReader" in window)) {
        return false;
      }
      return true;
    }
    module.exports = isDragDropSupported;
  }
});

// node_modules/is-shallow-equal/index.js
var require_is_shallow_equal = __commonJS({
  "node_modules/is-shallow-equal/index.js"(exports, module) {
    module.exports = function isShallowEqual(a2, b2) {
      if (a2 === b2)
        return true;
      for (var i2 in a2)
        if (!(i2 in b2))
          return false;
      for (var i2 in b2)
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    };
  }
});

// node_modules/@uppy/dashboard/lib/utils/getFileTypeIcon.js
var require_getFileTypeIcon = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/getFileTypeIcon.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function iconImage() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("g", {
        fill: "#686DE0",
        fillRule: "evenodd"
      }, (0, _preact.h)("path", {
        d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
        fillRule: "nonzero"
      }), (0, _preact.h)("path", {
        d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
        fillRule: "nonzero"
      }), (0, _preact.h)("circle", {
        cx: "7.5",
        cy: "9.5",
        r: "1.5"
      })));
    }
    function iconAudio() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("path", {
        d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
        fill: "#049BCF",
        fillRule: "nonzero"
      }));
    }
    function iconVideo() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("path", {
        d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
        fill: "#19AF67",
        fillRule: "nonzero"
      }));
    }
    function iconPDF() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("path", {
        d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
        fill: "#E2514A",
        fillRule: "nonzero"
      }));
    }
    function iconArchive() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("path", {
        d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
        fill: "#00C469",
        fillRule: "nonzero"
      }));
    }
    function iconFile() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("g", {
        fill: "#A7AFB7",
        fillRule: "nonzero"
      }, (0, _preact.h)("path", {
        d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
      }), (0, _preact.h)("path", {
        d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
      })));
    }
    function iconText() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25"
      }, (0, _preact.h)("path", {
        d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
        fill: "#5A5E69",
        fillRule: "nonzero"
      }));
    }
    function getIconByMime(fileType) {
      const defaultChoice = {
        color: "#838999",
        icon: iconFile()
      };
      if (!fileType)
        return defaultChoice;
      const fileTypeGeneral = fileType.split("/")[0];
      const fileTypeSpecific = fileType.split("/")[1];
      if (fileTypeGeneral === "text") {
        return {
          color: "#5a5e69",
          icon: iconText()
        };
      }
      if (fileTypeGeneral === "image") {
        return {
          color: "#686de0",
          icon: iconImage()
        };
      }
      if (fileTypeGeneral === "audio") {
        return {
          color: "#068dbb",
          icon: iconAudio()
        };
      }
      if (fileTypeGeneral === "video") {
        return {
          color: "#19af67",
          icon: iconVideo()
        };
      }
      if (fileTypeGeneral === "application" && fileTypeSpecific === "pdf") {
        return {
          color: "#e25149",
          icon: iconPDF()
        };
      }
      const archiveTypes = ["zip", "x-7z-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage"];
      if (fileTypeGeneral === "application" && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
        return {
          color: "#00C469",
          icon: iconArchive()
        };
      }
      return defaultChoice;
    }
    module.exports = getIconByMime;
  }
});

// node_modules/@uppy/dashboard/lib/components/FilePreview.js
var require_FilePreview = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FilePreview.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var getFileTypeIcon = require_getFileTypeIcon();
    function FilePreview(props) {
      const {
        file
      } = props;
      if (file.preview) {
        return (0, _preact.h)("img", {
          className: "uppy-Dashboard-Item-previewImg",
          alt: file.name,
          src: file.preview
        });
      }
      const {
        color,
        icon
      } = getFileTypeIcon(file.type);
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-previewIconWrap"
      }, (0, _preact.h)("span", {
        className: "uppy-Dashboard-Item-previewIcon",
        style: {
          color
        }
      }, icon), (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-Dashboard-Item-previewIconBg",
        width: "58",
        height: "76",
        viewBox: "0 0 58 76"
      }, (0, _preact.h)("rect", {
        fill: "#FFF",
        width: "58",
        height: "76",
        rx: "3",
        fillRule: "evenodd"
      })));
    }
    module.exports = FilePreview;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/MetaErrorMessage.js
var require_MetaErrorMessage = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/MetaErrorMessage.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var metaFieldIdToName = (metaFieldId, metaFields) => {
      const field = metaFields.filter((f2) => f2.id === metaFieldId);
      return field[0].name;
    };
    function renderMissingMetaFieldsError(props) {
      const {
        file,
        toggleFileCard,
        i18n,
        metaFields
      } = props;
      const {
        missingRequiredMetaFields
      } = file;
      if (!(missingRequiredMetaFields != null && missingRequiredMetaFields.length)) {
        return null;
      }
      const metaFieldsString = missingRequiredMetaFields.map((missingMetaField) => metaFieldIdToName(missingMetaField, metaFields)).join(", ");
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-errorMessage"
      }, i18n("missingRequiredMetaFields", {
        smart_count: missingRequiredMetaFields.length,
        fields: metaFieldsString
      }), " ", (0, _preact.h)("button", {
        type: "button",
        class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn",
        onClick: () => toggleFileCard(true, file.id)
      }, i18n("editFile")));
    }
    module.exports = renderMissingMetaFieldsError;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/FilePreviewAndLink/index.js
var require_FilePreviewAndLink = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/FilePreviewAndLink/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var FilePreview = require_FilePreview();
    var MetaErrorMessage = require_MetaErrorMessage();
    var getFileTypeIcon = require_getFileTypeIcon();
    function FilePreviewAndLink(props) {
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-previewInnerWrap",
        style: {
          backgroundColor: getFileTypeIcon(props.file.type).color
        }
      }, props.showLinkToFileUploadResult && props.file.uploadURL && (0, _preact.h)("a", {
        className: "uppy-Dashboard-Item-previewLink",
        href: props.file.uploadURL,
        rel: "noreferrer noopener",
        target: "_blank",
        "aria-label": props.file.meta.name
      }, (0, _preact.h)("span", {
        hidden: true
      }, props.file.meta.name)), (0, _preact.h)(FilePreview, {
        file: props.file
      }), (0, _preact.h)(MetaErrorMessage, {
        file: props.file,
        i18n: props.i18n,
        toggleFileCard: props.toggleFileCard,
        metaFields: props.metaFields
      }));
    }
    module.exports = FilePreviewAndLink;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/FileProgress/index.js
var require_FileProgress = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/FileProgress/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function onPauseResumeCancelRetry(props) {
      if (props.isUploaded)
        return;
      if (props.error && !props.hideRetryButton) {
        props.uppy.retryUpload(props.file.id);
        return;
      }
      if (props.resumableUploads && !props.hidePauseResumeButton) {
        props.uppy.pauseResume(props.file.id);
      } else if (props.individualCancellation && !props.hideCancelButton) {
        props.uppy.removeFile(props.file.id);
      }
    }
    function progressIndicatorTitle(props) {
      if (props.isUploaded) {
        return props.i18n("uploadComplete");
      }
      if (props.error) {
        return props.i18n("retryUpload");
      }
      if (props.resumableUploads) {
        if (props.file.isPaused) {
          return props.i18n("resumeUpload");
        }
        return props.i18n("pauseUpload");
      }
      if (props.individualCancellation) {
        return props.i18n("cancelUpload");
      }
      return "";
    }
    function ProgressIndicatorButton(props) {
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-progress"
      }, (0, _preact.h)("button", {
        className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
        type: "button",
        "aria-label": progressIndicatorTitle(props),
        title: progressIndicatorTitle(props),
        onClick: () => onPauseResumeCancelRetry(props)
      }, props.children));
    }
    function ProgressCircleContainer(_ref) {
      let {
        children
      } = _ref;
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "70",
        height: "70",
        viewBox: "0 0 36 36",
        className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
      }, children);
    }
    function ProgressCircle(_ref2) {
      let {
        progress
      } = _ref2;
      const circleLength = 2 * Math.PI * 15;
      return (0, _preact.h)("g", null, (0, _preact.h)("circle", {
        className: "uppy-Dashboard-Item-progressIcon--bg",
        r: "15",
        cx: "18",
        cy: "18",
        "stroke-width": "2",
        fill: "none"
      }), (0, _preact.h)("circle", {
        className: "uppy-Dashboard-Item-progressIcon--progress",
        r: "15",
        cx: "18",
        cy: "18",
        transform: "rotate(-90, 18, 18)",
        fill: "none",
        "stroke-width": "2",
        "stroke-dasharray": circleLength,
        "stroke-dashoffset": circleLength - circleLength / 100 * progress
      }));
    }
    function FileProgress(props) {
      if (!props.file.progress.uploadStarted) {
        return null;
      }
      if (props.isUploaded) {
        return (0, _preact.h)("div", {
          className: "uppy-Dashboard-Item-progress"
        }, (0, _preact.h)("div", {
          className: "uppy-Dashboard-Item-progressIndicator"
        }, (0, _preact.h)(ProgressCircleContainer, null, (0, _preact.h)("circle", {
          r: "15",
          cx: "18",
          cy: "18",
          fill: "#1bb240"
        }), (0, _preact.h)("polygon", {
          className: "uppy-Dashboard-Item-progressIcon--check",
          transform: "translate(2, 3)",
          points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
        }))));
      }
      if (props.recoveredState) {
        return void 0;
      }
      if (props.error && !props.hideRetryButton) {
        return (0, _preact.h)(ProgressIndicatorButton, props, (0, _preact.h)("svg", {
          "aria-hidden": "true",
          focusable: "false",
          className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
          width: "28",
          height: "31",
          viewBox: "0 0 16 19"
        }, (0, _preact.h)("path", {
          d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
        }), (0, _preact.h)("path", {
          d: "M7.9 3H10v2H7.9z"
        }), (0, _preact.h)("path", {
          d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
        }), (0, _preact.h)("path", {
          d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
        })));
      }
      if (props.resumableUploads && !props.hidePauseResumeButton) {
        return (0, _preact.h)(ProgressIndicatorButton, props, (0, _preact.h)(ProgressCircleContainer, null, (0, _preact.h)(ProgressCircle, {
          progress: props.file.progress.percentage
        }), props.file.isPaused ? (0, _preact.h)("polygon", {
          className: "uppy-Dashboard-Item-progressIcon--play",
          transform: "translate(3, 3)",
          points: "12 20 12 10 20 15"
        }) : (0, _preact.h)("g", {
          className: "uppy-Dashboard-Item-progressIcon--pause",
          transform: "translate(14.5, 13)"
        }, (0, _preact.h)("rect", {
          x: "0",
          y: "0",
          width: "2",
          height: "10",
          rx: "0"
        }), (0, _preact.h)("rect", {
          x: "5",
          y: "0",
          width: "2",
          height: "10",
          rx: "0"
        }))));
      }
      if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
        return (0, _preact.h)(ProgressIndicatorButton, props, (0, _preact.h)(ProgressCircleContainer, null, (0, _preact.h)(ProgressCircle, {
          progress: props.file.progress.percentage
        }), (0, _preact.h)("polygon", {
          className: "cancel",
          transform: "translate(2, 2)",
          points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
        })));
      }
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-progress"
      }, (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-progressIndicator"
      }, (0, _preact.h)(ProgressCircleContainer, null, (0, _preact.h)(ProgressCircle, {
        progress: props.file.progress.percentage
      }))));
    }
    module.exports = FileProgress;
  }
});

// node_modules/@uppy/utils/lib/truncateString.js
var require_truncateString = __commonJS({
  "node_modules/@uppy/utils/lib/truncateString.js"(exports, module) {
    "use strict";
    var separator = "...";
    function truncateString(string, maxLength) {
      if (maxLength === 0)
        return "";
      if (string.length <= maxLength)
        return string;
      if (maxLength <= separator.length + 1)
        return `${string.slice(0, maxLength - 1)}\u2026`;
      const charsToShow = maxLength - separator.length;
      const frontChars = Math.ceil(charsToShow / 2);
      const backChars = Math.floor(charsToShow / 2);
      return string.slice(0, frontChars) + separator + string.slice(-backChars);
    }
    module.exports = truncateString;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/FileInfo/index.js
var require_FileInfo = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/FileInfo/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var prettierBytes = require_prettierBytes();
    var truncateString = require_truncateString();
    var MetaErrorMessage = require_MetaErrorMessage();
    var renderFileName = (props) => {
      const {
        author,
        name
      } = props.file.meta;
      function getMaxNameLength() {
        if (props.containerWidth <= 352) {
          return 35;
        }
        if (props.containerWidth <= 576) {
          return 60;
        }
        return author ? 20 : 30;
      }
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-name",
        title: name
      }, truncateString(name, getMaxNameLength()));
    };
    var renderAuthor = (props) => {
      const {
        author
      } = props.file.meta;
      const {
        providerName
      } = props.file.remote;
      const dot = `\xB7`;
      if (!author) {
        return null;
      }
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-author"
      }, (0, _preact.h)("a", {
        href: `${author.url}?utm_source=Companion&utm_medium=referral`,
        target: "_blank",
        rel: "noopener noreferrer"
      }, truncateString(author.name, 13)), providerName ? (0, _preact.h)(_preact.Fragment, null, ` ${dot} `, providerName, ` ${dot} `) : null);
    };
    var renderFileSize = (props) => props.file.size && (0, _preact.h)("div", {
      className: "uppy-Dashboard-Item-statusSize"
    }, prettierBytes(props.file.size));
    var ReSelectButton = (props) => props.file.isGhost && (0, _preact.h)("span", null, " \u2022 ", (0, _preact.h)("button", {
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
      type: "button",
      onClick: props.toggleAddFilesPanel
    }, props.i18n("reSelect")));
    var ErrorButton = (_ref) => {
      let {
        file,
        onClick
      } = _ref;
      if (file.error) {
        return (0, _preact.h)("button", {
          className: "uppy-u-reset uppy-Dashboard-Item-errorDetails",
          "aria-label": file.error,
          "data-microtip-position": "bottom",
          "data-microtip-size": "medium",
          onClick,
          type: "button"
        }, "?");
      }
      return null;
    };
    function FileInfo(props) {
      const {
        file
      } = props;
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-fileInfo",
        "data-uppy-file-source": file.source
      }, (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-fileName"
      }, renderFileName(props), (0, _preact.h)(ErrorButton, {
        file: props.file,
        onClick: () => alert(props.file.error)
      })), (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-status"
      }, renderAuthor(props), renderFileSize(props), ReSelectButton(props)), (0, _preact.h)(MetaErrorMessage, {
        file: props.file,
        i18n: props.i18n,
        toggleFileCard: props.toggleFileCard,
        metaFields: props.metaFields
      }));
    }
    module.exports = FileInfo;
  }
});

// node_modules/@uppy/dashboard/lib/utils/copyToClipboard.js
var require_copyToClipboard = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/copyToClipboard.js"(exports, module) {
    "use strict";
    function copyToClipboard(textToCopy, fallbackString) {
      fallbackString || (fallbackString = "Copy the URL below");
      return new Promise((resolve) => {
        const textArea = document.createElement("textarea");
        textArea.setAttribute("style", {
          position: "fixed",
          top: 0,
          left: 0,
          width: "2em",
          height: "2em",
          padding: 0,
          border: "none",
          outline: "none",
          boxShadow: "none",
          background: "transparent"
        });
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        const magicCopyFailed = () => {
          document.body.removeChild(textArea);
          window.prompt(fallbackString, textToCopy);
          resolve();
        };
        try {
          const successful = document.execCommand("copy");
          if (!successful) {
            return magicCopyFailed("copy command unavailable");
          }
          document.body.removeChild(textArea);
          return resolve();
        } catch (err) {
          document.body.removeChild(textArea);
          return magicCopyFailed(err);
        }
      });
    }
    module.exports = copyToClipboard;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/Buttons/index.js
var require_Buttons = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/Buttons/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var copyToClipboard = require_copyToClipboard();
    function EditButton(_ref) {
      let {
        file,
        uploadInProgressOrComplete,
        metaFields,
        canEditFile,
        i18n,
        onClick
      } = _ref;
      if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
        return (0, _preact.h)("button", {
          className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
          type: "button",
          "aria-label": i18n("editFileWithFilename", {
            file: file.meta.name
          }),
          title: i18n("editFileWithFilename", {
            file: file.meta.name
          }),
          onClick: () => onClick()
        }, (0, _preact.h)("svg", {
          "aria-hidden": "true",
          focusable: "false",
          className: "uppy-c-icon",
          width: "14",
          height: "14",
          viewBox: "0 0 14 14"
        }, (0, _preact.h)("g", {
          fillRule: "evenodd"
        }, (0, _preact.h)("path", {
          d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
          fillRule: "nonzero"
        }), (0, _preact.h)("rect", {
          x: "1",
          y: "12.293",
          width: "11",
          height: "1",
          rx: ".5"
        }), (0, _preact.h)("path", {
          fillRule: "nonzero",
          d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
        }))));
      }
      return null;
    }
    function RemoveButton(_ref2) {
      let {
        i18n,
        onClick,
        file
      } = _ref2;
      return (0, _preact.h)("button", {
        className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
        type: "button",
        "aria-label": i18n("removeFile", {
          file: file.meta.name
        }),
        title: i18n("removeFile", {
          file: file.meta.name
        }),
        onClick: () => onClick()
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "18",
        height: "18",
        viewBox: "0 0 18 18"
      }, (0, _preact.h)("path", {
        d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
      }), (0, _preact.h)("path", {
        fill: "#FFF",
        d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
      })));
    }
    var copyLinkToClipboard = (event2, props) => {
      copyToClipboard(props.file.uploadURL, props.i18n("copyLinkToClipboardFallback")).then(() => {
        props.uppy.log("Link copied to clipboard.");
        props.uppy.info(props.i18n("copyLinkToClipboardSuccess"), "info", 3e3);
      }).catch(props.uppy.log).then(() => event2.target.focus({
        preventScroll: true
      }));
    };
    function CopyLinkButton(props) {
      const {
        i18n
      } = props;
      return (0, _preact.h)("button", {
        className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
        type: "button",
        "aria-label": i18n("copyLink"),
        title: i18n("copyLink"),
        onClick: (event2) => copyLinkToClipboard(event2, props)
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "14",
        height: "14",
        viewBox: "0 0 14 12"
      }, (0, _preact.h)("path", {
        d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
      })));
    }
    function Buttons(props) {
      const {
        uppy: uppy2,
        file,
        uploadInProgressOrComplete,
        canEditFile,
        metaFields,
        showLinkToFileUploadResult,
        showRemoveButton,
        i18n,
        toggleFileCard,
        openFileEditor
      } = props;
      const editAction = () => {
        if (metaFields && metaFields.length > 0) {
          toggleFileCard(true, file.id);
        } else {
          openFileEditor(file);
        }
      };
      return (0, _preact.h)("div", {
        className: "uppy-Dashboard-Item-actionWrapper"
      }, (0, _preact.h)(EditButton, {
        i18n,
        file,
        uploadInProgressOrComplete,
        canEditFile,
        metaFields,
        onClick: editAction
      }), showLinkToFileUploadResult && file.uploadURL ? (0, _preact.h)(CopyLinkButton, {
        file,
        uppy: uppy2,
        i18n
      }) : null, showRemoveButton ? (0, _preact.h)(RemoveButton, {
        i18n,
        file,
        uppy: uppy2,
        onClick: () => props.uppy.removeFile(file.id, "removed-by-user")
      }) : null);
    }
    module.exports = Buttons;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileItem/index.js
var require_FileItem = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileItem/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    var shallowEqual = require_is_shallow_equal();
    var FilePreviewAndLink = require_FilePreviewAndLink();
    var FileProgress = require_FileProgress();
    var FileInfo = require_FileInfo();
    var Buttons = require_Buttons();
    var FileItem = class extends _preact.Component {
      componentDidMount() {
        const {
          file
        } = this.props;
        if (!file.preview) {
          this.props.handleRequestThumbnail(file);
        }
      }
      shouldComponentUpdate(nextProps) {
        return !shallowEqual(this.props, nextProps);
      }
      componentDidUpdate() {
        const {
          file
        } = this.props;
        if (!file.preview) {
          this.props.handleRequestThumbnail(file);
        }
      }
      componentWillUnmount() {
        const {
          file
        } = this.props;
        if (!file.preview) {
          this.props.handleCancelThumbnail(file);
        }
      }
      render() {
        const {
          file
        } = this.props;
        const isProcessing = file.progress.preprocess || file.progress.postprocess;
        const isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
        const uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
        const uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
        const error = file.error || false;
        const {
          isGhost
        } = file;
        let showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;
        if (isUploaded && this.props.showRemoveButtonAfterComplete) {
          showRemoveButton = true;
        }
        const dashboardItemClass = classNames({
          "uppy-Dashboard-Item": true,
          "is-inprogress": uploadInProgress && !this.props.recoveredState,
          "is-processing": isProcessing,
          "is-complete": isUploaded,
          "is-error": !!error,
          "is-resumable": this.props.resumableUploads,
          "is-noIndividualCancellation": !this.props.individualCancellation,
          "is-ghost": isGhost
        });
        return (0, _preact.h)("div", {
          className: dashboardItemClass,
          id: `uppy_${file.id}`,
          role: this.props.role
        }, (0, _preact.h)("div", {
          className: "uppy-Dashboard-Item-preview"
        }, (0, _preact.h)(FilePreviewAndLink, {
          file,
          showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
          i18n: this.props.i18n,
          toggleFileCard: this.props.toggleFileCard,
          metaFields: this.props.metaFields
        }), (0, _preact.h)(FileProgress, {
          uppy: this.props.uppy,
          file,
          error,
          isUploaded,
          hideRetryButton: this.props.hideRetryButton,
          hideCancelButton: this.props.hideCancelButton,
          hidePauseResumeButton: this.props.hidePauseResumeButton,
          recoveredState: this.props.recoveredState,
          showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
          resumableUploads: this.props.resumableUploads,
          individualCancellation: this.props.individualCancellation,
          i18n: this.props.i18n
        })), (0, _preact.h)("div", {
          className: "uppy-Dashboard-Item-fileInfoAndButtons"
        }, (0, _preact.h)(FileInfo, {
          file,
          id: this.props.id,
          acquirers: this.props.acquirers,
          containerWidth: this.props.containerWidth,
          i18n: this.props.i18n,
          toggleAddFilesPanel: this.props.toggleAddFilesPanel,
          toggleFileCard: this.props.toggleFileCard,
          metaFields: this.props.metaFields
        }), (0, _preact.h)(Buttons, {
          file,
          metaFields: this.props.metaFields,
          showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
          showRemoveButton,
          canEditFile: this.props.canEditFile,
          uploadInProgressOrComplete,
          toggleFileCard: this.props.toggleFileCard,
          openFileEditor: this.props.openFileEditor,
          uppy: this.props.uppy,
          i18n: this.props.i18n
        })));
      }
    };
    module.exports = FileItem;
  }
});

// node_modules/@uppy/dashboard/lib/components/VirtualList.js
var require_VirtualList = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/VirtualList.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var STYLE_INNER = {
      position: "relative",
      width: "100%",
      minHeight: "100%"
    };
    var STYLE_CONTENT = {
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      overflow: "visible"
    };
    var VirtualList = class extends _preact.Component {
      constructor(props) {
        super(props);
        this.handleScroll = () => {
          this.setState({
            offset: this.base.scrollTop
          });
        };
        this.handleResize = () => {
          this.resize();
        };
        this.focusElement = null;
        this.state = {
          offset: 0,
          height: 0
        };
      }
      componentDidMount() {
        this.resize();
        window.addEventListener("resize", this.handleResize);
      }
      componentWillUpdate() {
        if (this.base.contains(document.activeElement)) {
          this.focusElement = document.activeElement;
        }
      }
      componentDidUpdate() {
        if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
          this.focusElement.focus();
        }
        this.focusElement = null;
        this.resize();
      }
      componentWillUnmount() {
        window.removeEventListener("resize", this.handleResize);
      }
      resize() {
        const {
          height
        } = this.state;
        if (height !== this.base.offsetHeight) {
          this.setState({
            height: this.base.offsetHeight
          });
        }
      }
      render(_ref) {
        let {
          data,
          rowHeight,
          renderRow,
          overscanCount = 10,
          ...props
        } = _ref;
        const {
          offset,
          height
        } = this.state;
        let start = Math.floor(offset / rowHeight);
        let visibleRowCount = Math.floor(height / rowHeight);
        if (overscanCount) {
          start = Math.max(0, start - start % overscanCount);
          visibleRowCount += overscanCount;
        }
        const end = start + visibleRowCount + 4;
        const selection = data.slice(start, end);
        const styleInner = {
          ...STYLE_INNER,
          height: data.length * rowHeight
        };
        const styleContent = {
          ...STYLE_CONTENT,
          top: start * rowHeight
        };
        return (0, _preact.h)("div", _extends({
          onScroll: this.handleScroll
        }, props), (0, _preact.h)("div", {
          role: "presentation",
          style: styleInner
        }, (0, _preact.h)("div", {
          role: "presentation",
          style: styleContent
        }, selection.map(renderRow))));
      }
    };
    module.exports = VirtualList;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileList.js
var require_FileList = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileList.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var classNames = require_classnames();
    var FileItem = require_FileItem();
    var VirtualList = require_VirtualList();
    function chunks(list, size) {
      const chunked = [];
      let currentChunk = [];
      list.forEach((item) => {
        if (currentChunk.length < size) {
          currentChunk.push(item);
        } else {
          chunked.push(currentChunk);
          currentChunk = [item];
        }
      });
      if (currentChunk.length)
        chunked.push(currentChunk);
      return chunked;
    }
    module.exports = (props) => {
      const noFiles = props.totalFileCount === 0;
      const dashboardFilesClass = classNames("uppy-Dashboard-files", {
        "uppy-Dashboard-files--noFiles": noFiles
      });
      const rowHeight = props.itemsPerRow === 1 ? 71 : 200;
      const fileProps = {
        id: props.id,
        error: props.error,
        i18n: props.i18n,
        uppy: props.uppy,
        acquirers: props.acquirers,
        resumableUploads: props.resumableUploads,
        individualCancellation: props.individualCancellation,
        hideRetryButton: props.hideRetryButton,
        hidePauseResumeButton: props.hidePauseResumeButton,
        hideCancelButton: props.hideCancelButton,
        showLinkToFileUploadResult: props.showLinkToFileUploadResult,
        showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
        isWide: props.isWide,
        metaFields: props.metaFields,
        recoveredState: props.recoveredState,
        toggleFileCard: props.toggleFileCard,
        handleRequestThumbnail: props.handleRequestThumbnail,
        handleCancelThumbnail: props.handleCancelThumbnail
      };
      const sortByGhostComesFirst = (file1, file2) => {
        return props.files[file2].isGhost - props.files[file1].isGhost;
      };
      const files = Object.keys(props.files);
      if (props.recoveredState)
        files.sort(sortByGhostComesFirst);
      const rows = chunks(files, props.itemsPerRow);
      const renderRow = (row) => (0, _preact.h)("div", {
        role: "presentation",
        key: row[0]
      }, row.map((fileID) => (0, _preact.h)(FileItem, _extends({
        key: fileID,
        uppy: props.uppy
      }, fileProps, {
        role: "listitem",
        openFileEditor: props.openFileEditor,
        canEditFile: props.canEditFile,
        toggleAddFilesPanel: props.toggleAddFilesPanel,
        file: props.files[fileID]
      }))));
      return (0, _preact.h)(VirtualList, {
        class: dashboardFilesClass,
        role: "list",
        data: rows,
        renderRow,
        rowHeight
      });
    };
  }
});

// node_modules/@uppy/dashboard/lib/components/AddFiles.js
var require_AddFiles = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/AddFiles.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var _Symbol$for;
    _Symbol$for = Symbol.for("uppy test: disable unused locale key warning");
    var AddFiles = class extends _preact.Component {
      constructor() {
        super(...arguments);
        this.triggerFileInputClick = () => {
          this.fileInput.click();
        };
        this.triggerFolderInputClick = () => {
          this.folderInput.click();
        };
        this.onFileInputChange = (event2) => {
          this.props.handleInputChange(event2);
          event2.target.value = null;
        };
        this.renderHiddenInput = (isFolder, refCallback) => {
          return (0, _preact.h)("input", {
            className: "uppy-Dashboard-input",
            hidden: true,
            "aria-hidden": "true",
            tabIndex: -1,
            webkitdirectory: isFolder,
            type: "file",
            name: "files[]",
            multiple: this.props.maxNumberOfFiles !== 1,
            onChange: this.onFileInputChange,
            accept: this.props.allowedFileTypes,
            ref: refCallback
          });
        };
        this.renderMyDeviceAcquirer = () => {
          return (0, _preact.h)("div", {
            className: "uppy-DashboardTab",
            role: "presentation",
            "data-uppy-acquirer-id": "MyDevice"
          }, (0, _preact.h)("button", {
            type: "button",
            className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
            role: "tab",
            tabIndex: 0,
            "data-uppy-super-focusable": true,
            onClick: this.triggerFileInputClick
          }, (0, _preact.h)("svg", {
            "aria-hidden": "true",
            focusable: "false",
            width: "32",
            height: "32",
            viewBox: "0 0 32 32"
          }, (0, _preact.h)("g", {
            fill: "none",
            fillRule: "evenodd"
          }, (0, _preact.h)("rect", {
            className: "uppy-ProviderIconBg",
            width: "32",
            height: "32",
            rx: "16",
            fill: "#2275D7"
          }), (0, _preact.h)("path", {
            d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
            fill: "#FFF"
          }))), (0, _preact.h)("div", {
            className: "uppy-DashboardTab-name"
          }, this.props.i18n("myDevice"))));
        };
        this.renderBrowseButton = (text, onClickFn) => {
          const numberOfAcquirers = this.props.acquirers.length;
          return (0, _preact.h)("button", {
            type: "button",
            className: "uppy-u-reset uppy-Dashboard-browse",
            onClick: onClickFn,
            "data-uppy-super-focusable": numberOfAcquirers === 0
          }, text);
        };
        this.renderDropPasteBrowseTagline = () => {
          const numberOfAcquirers = this.props.acquirers.length;
          const browseFiles = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick);
          const browseFolders = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick);
          const lowerFMSelectionType = this.props.fileManagerSelectionType;
          const camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1);
          return (0, _preact.h)(
            "div",
            {
              class: "uppy-Dashboard-AddFiles-title"
            },
            this.props.disableLocalFiles ? this.props.i18n("importFiles") : numberOfAcquirers > 0 ? this.props.i18nArray(`dropPasteImport${camelFMSelectionType}`, {
              browseFiles,
              browseFolders,
              browse: browseFiles
            }) : this.props.i18nArray(`dropPaste${camelFMSelectionType}`, {
              browseFiles,
              browseFolders,
              browse: browseFiles
            })
          );
        };
        this.renderAcquirer = (acquirer) => {
          return (0, _preact.h)("div", {
            className: "uppy-DashboardTab",
            role: "presentation",
            "data-uppy-acquirer-id": acquirer.id
          }, (0, _preact.h)("button", {
            type: "button",
            className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
            role: "tab",
            tabIndex: 0,
            "data-cy": acquirer.id,
            "aria-controls": `uppy-DashboardContent-panel--${acquirer.id}`,
            "aria-selected": this.props.activePickerPanel.id === acquirer.id,
            "data-uppy-super-focusable": true,
            onClick: () => this.props.showPanel(acquirer.id)
          }, acquirer.icon(), (0, _preact.h)("div", {
            className: "uppy-DashboardTab-name"
          }, acquirer.name)));
        };
        this.renderAcquirers = (acquirers, disableLocalFiles) => {
          const acquirersWithoutLastTwo = [...acquirers];
          const lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
          return (0, _preact.h)("div", {
            className: "uppy-Dashboard-AddFiles-list",
            role: "tablist"
          }, !disableLocalFiles && this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map((acquirer) => this.renderAcquirer(acquirer)), (0, _preact.h)("span", {
            role: "presentation",
            style: {
              "white-space": "nowrap"
            }
          }, lastTwoAcquirers.map((acquirer) => this.renderAcquirer(acquirer))));
        };
      }
      [_Symbol$for]() {
        this.props.i18nArray("dropPasteBoth");
        this.props.i18nArray("dropPasteFiles");
        this.props.i18nArray("dropPasteFolders");
        this.props.i18nArray("dropPasteImportBoth");
        this.props.i18nArray("dropPasteImportFiles");
        this.props.i18nArray("dropPasteImportFolders");
      }
      renderPoweredByUppy() {
        const {
          i18nArray
        } = this.props;
        const uppyBranding = (0, _preact.h)("span", null, (0, _preact.h)("svg", {
          "aria-hidden": "true",
          focusable: "false",
          className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
          width: "11",
          height: "11",
          viewBox: "0 0 11 11"
        }, (0, _preact.h)("path", {
          d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
          fillRule: "evenodd"
        })), (0, _preact.h)("span", {
          className: "uppy-Dashboard-poweredByUppy"
        }, "Uppy"));
        const linkText = i18nArray("poweredBy", {
          uppy: uppyBranding
        });
        return (0, _preact.h)("a", {
          tabIndex: "-1",
          href: "https://uppy.io",
          rel: "noreferrer noopener",
          target: "_blank",
          className: "uppy-Dashboard-poweredBy"
        }, linkText);
      }
      render() {
        return (0, _preact.h)("div", {
          className: "uppy-Dashboard-AddFiles"
        }, this.renderHiddenInput(false, (ref) => {
          this.fileInput = ref;
        }), this.renderHiddenInput(true, (ref) => {
          this.folderInput = ref;
        }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), (0, _preact.h)("div", {
          className: "uppy-Dashboard-AddFiles-info"
        }, this.props.note && (0, _preact.h)("div", {
          className: "uppy-Dashboard-note"
        }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
      }
    };
    module.exports = AddFiles;
  }
});

// node_modules/@uppy/dashboard/lib/components/AddFilesPanel.js
var require_AddFilesPanel = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/AddFilesPanel.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    var AddFiles = require_AddFiles();
    var AddFilesPanel = (props) => {
      return (0, _preact.h)("div", {
        className: classNames("uppy-Dashboard-AddFilesPanel", props.className),
        "data-uppy-panelType": "AddFiles",
        "aria-hidden": props.showAddFilesPanel
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-bar"
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-title",
        role: "heading",
        "aria-level": "1"
      }, props.i18n("addingMoreFiles")), (0, _preact.h)("button", {
        className: "uppy-DashboardContent-back",
        type: "button",
        onClick: () => props.toggleAddFilesPanel(false)
      }, props.i18n("back"))), (0, _preact.h)(AddFiles, props));
    };
    module.exports = AddFilesPanel;
  }
});

// node_modules/@uppy/dashboard/lib/utils/ignoreEvent.js
var require_ignoreEvent = __commonJS({
  "node_modules/@uppy/dashboard/lib/utils/ignoreEvent.js"(exports, module) {
    "use strict";
    function ignoreEvent(ev) {
      const {
        tagName
      } = ev.target;
      if (tagName === "INPUT" || tagName === "TEXTAREA") {
        ev.stopPropagation();
        return;
      }
      ev.preventDefault();
      ev.stopPropagation();
    }
    module.exports = ignoreEvent;
  }
});

// node_modules/@uppy/dashboard/lib/components/PickerPanelContent.js
var require_PickerPanelContent = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/PickerPanelContent.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    var ignoreEvent = require_ignoreEvent();
    function PickerPanelContent(_ref) {
      let {
        activePickerPanel,
        className,
        hideAllPanels,
        i18n,
        state,
        uppy: uppy2
      } = _ref;
      return (0, _preact.h)("div", {
        className: classNames("uppy-DashboardContent-panel", className),
        role: "tabpanel",
        "data-uppy-panelType": "PickerPanel",
        id: `uppy-DashboardContent-panel--${activePickerPanel.id}`,
        onDragOver: ignoreEvent,
        onDragLeave: ignoreEvent,
        onDrop: ignoreEvent,
        onPaste: ignoreEvent
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-bar"
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-title",
        role: "heading",
        "aria-level": "1"
      }, i18n("importFrom", {
        name: activePickerPanel.name
      })), (0, _preact.h)("button", {
        className: "uppy-DashboardContent-back",
        type: "button",
        onClick: hideAllPanels
      }, i18n("cancel"))), (0, _preact.h)("div", {
        className: "uppy-DashboardContent-panelBody"
      }, uppy2.getPlugin(activePickerPanel.id).render(state)));
    }
    module.exports = PickerPanelContent;
  }
});

// node_modules/@uppy/dashboard/lib/components/EditorPanel.js
var require_EditorPanel = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/EditorPanel.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    function EditorPanel(props) {
      const file = props.files[props.fileCardFor];
      return (0, _preact.h)("div", {
        className: classNames("uppy-DashboardContent-panel", props.className),
        role: "tabpanel",
        "data-uppy-panelType": "FileEditor",
        id: "uppy-DashboardContent-panel--editor"
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-bar"
      }, (0, _preact.h)("div", {
        className: "uppy-DashboardContent-title",
        role: "heading",
        "aria-level": "1"
      }, props.i18nArray("editing", {
        file: (0, _preact.h)("span", {
          className: "uppy-DashboardContent-titleFile"
        }, file.meta ? file.meta.name : file.name)
      })), (0, _preact.h)("button", {
        className: "uppy-DashboardContent-back",
        type: "button",
        onClick: props.hideAllPanels
      }, props.i18n("cancel")), (0, _preact.h)("button", {
        className: "uppy-DashboardContent-save",
        type: "button",
        onClick: props.saveFileEditor
      }, props.i18n("save"))), (0, _preact.h)("div", {
        className: "uppy-DashboardContent-panelBody"
      }, props.editors.map((target) => {
        return props.uppy.getPlugin(target.id).render(props.state);
      })));
    }
    module.exports = EditorPanel;
  }
});

// node_modules/@uppy/dashboard/lib/components/PickerPanelTopBar.js
var require_PickerPanelTopBar = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/PickerPanelTopBar.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var uploadStates = {
      STATE_ERROR: "error",
      STATE_WAITING: "waiting",
      STATE_PREPROCESSING: "preprocessing",
      STATE_UPLOADING: "uploading",
      STATE_POSTPROCESSING: "postprocessing",
      STATE_COMPLETE: "complete",
      STATE_PAUSED: "paused"
    };
    function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
      if (files === void 0) {
        files = {};
      }
      if (isAllErrored) {
        return uploadStates.STATE_ERROR;
      }
      if (isAllComplete) {
        return uploadStates.STATE_COMPLETE;
      }
      if (isAllPaused) {
        return uploadStates.STATE_PAUSED;
      }
      let state = uploadStates.STATE_WAITING;
      const fileIDs = Object.keys(files);
      for (let i2 = 0; i2 < fileIDs.length; i2++) {
        const {
          progress
        } = files[fileIDs[i2]];
        if (progress.uploadStarted && !progress.uploadComplete) {
          return uploadStates.STATE_UPLOADING;
        }
        if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
          state = uploadStates.STATE_PREPROCESSING;
        }
        if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
          state = uploadStates.STATE_POSTPROCESSING;
        }
      }
      return state;
    }
    function UploadStatus(_ref) {
      let {
        files,
        i18n,
        isAllComplete,
        isAllErrored,
        isAllPaused,
        inProgressNotPausedFiles,
        newFiles,
        processingFiles
      } = _ref;
      const uploadingState = getUploadingState(isAllErrored, isAllComplete, isAllPaused, files);
      switch (uploadingState) {
        case "uploading":
          return i18n("uploadingXFiles", {
            smart_count: inProgressNotPausedFiles.length
          });
        case "preprocessing":
        case "postprocessing":
          return i18n("processingXFiles", {
            smart_count: processingFiles.length
          });
        case "paused":
          return i18n("uploadPaused");
        case "waiting":
          return i18n("xFilesSelected", {
            smart_count: newFiles.length
          });
        case "complete":
          return i18n("uploadComplete");
        default:
      }
    }
    function PanelTopBar(props) {
      const {
        i18n,
        isAllComplete,
        hideCancelButton,
        maxNumberOfFiles,
        toggleAddFilesPanel,
        uppy: uppy2
      } = props;
      let {
        allowNewUpload
      } = props;
      if (allowNewUpload && maxNumberOfFiles) {
        allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
      }
      return (0, _preact.h)("div", {
        className: "uppy-DashboardContent-bar"
      }, !isAllComplete && !hideCancelButton ? (0, _preact.h)("button", {
        className: "uppy-DashboardContent-back",
        type: "button",
        onClick: () => uppy2.cancelAll()
      }, i18n("cancel")) : (0, _preact.h)("div", null), (0, _preact.h)("div", {
        className: "uppy-DashboardContent-title",
        role: "heading",
        "aria-level": "1"
      }, (0, _preact.h)(UploadStatus, props)), allowNewUpload ? (0, _preact.h)("button", {
        className: "uppy-DashboardContent-addMore",
        type: "button",
        "aria-label": i18n("addMoreFiles"),
        title: i18n("addMoreFiles"),
        onClick: () => toggleAddFilesPanel(true)
      }, (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon",
        width: "15",
        height: "15",
        viewBox: "0 0 15 15"
      }, (0, _preact.h)("path", {
        d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
      })), (0, _preact.h)("span", {
        className: "uppy-DashboardContent-addMoreCaption"
      }, i18n("addMore"))) : (0, _preact.h)("div", null));
    }
    module.exports = PanelTopBar;
  }
});

// node_modules/@uppy/dashboard/lib/components/FileCard/index.js
var require_FileCard = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/FileCard/index.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var _nonSecure = require_non_secure();
    var classNames = require_classnames();
    var getFileTypeIcon = require_getFileTypeIcon();
    var ignoreEvent = require_ignoreEvent();
    var FilePreview = require_FilePreview();
    var FileCard = class extends _preact.Component {
      constructor(props) {
        super(props);
        this.form = document.createElement("form");
        this.updateMeta = (newVal, name) => {
          this.setState((_ref) => {
            let {
              formState
            } = _ref;
            return {
              formState: {
                ...formState,
                [name]: newVal
              }
            };
          });
        };
        this.handleSave = (e2) => {
          e2.preventDefault();
          const fileID = this.props.fileCardFor;
          this.props.saveFileCard(this.state.formState, fileID);
        };
        this.handleCancel = () => {
          const file = this.props.files[this.props.fileCardFor];
          this.props.uppy.emit("file-editor:cancel", file);
          this.props.toggleFileCard(false);
        };
        this.saveOnEnter = (ev) => {
          if (ev.keyCode === 13) {
            ev.stopPropagation();
            ev.preventDefault();
            const file = this.props.files[this.props.fileCardFor];
            this.props.saveFileCard(this.state.formState, file.id);
          }
        };
        this.renderMetaFields = () => {
          const metaFields = this.getMetaFields() || [];
          const fieldCSSClasses = {
            text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input"
          };
          return metaFields.map((field) => {
            const id = `uppy-Dashboard-FileCard-input-${field.id}`;
            const required = this.props.requiredMetaFields.includes(field.id);
            return (0, _preact.h)("fieldset", {
              key: field.id,
              className: "uppy-Dashboard-FileCard-fieldset"
            }, (0, _preact.h)("label", {
              className: "uppy-Dashboard-FileCard-label",
              htmlFor: id
            }, field.name), field.render !== void 0 ? field.render({
              value: this.state.formState[field.id],
              onChange: (newVal) => this.updateMeta(newVal, field.id),
              fieldCSSClasses,
              required,
              form: this.form.id
            }, _preact.h) : (0, _preact.h)("input", {
              className: fieldCSSClasses.text,
              id,
              form: this.form.id,
              type: field.type || "text",
              required,
              value: this.state.formState[field.id],
              placeholder: field.placeholder,
              onKeyUp: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
              onKeyDown: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
              onKeyPress: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
              onInput: (ev) => this.updateMeta(ev.target.value, field.id),
              "data-uppy-super-focusable": true
            }));
          });
        };
        const _file = this.props.files[this.props.fileCardFor];
        const _metaFields = this.getMetaFields() || [];
        const storedMetaData = {};
        _metaFields.forEach((field) => {
          storedMetaData[field.id] = _file.meta[field.id] || "";
        });
        this.state = {
          formState: storedMetaData
        };
        this.form.id = (0, _nonSecure.nanoid)();
      }
      componentWillMount() {
        this.form.addEventListener("submit", this.handleSave);
        document.body.appendChild(this.form);
      }
      componentWillUnmount() {
        this.form.removeEventListener("submit", this.handleSave);
        document.body.removeChild(this.form);
      }
      getMetaFields() {
        return typeof this.props.metaFields === "function" ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
      }
      render() {
        const file = this.props.files[this.props.fileCardFor];
        const showEditButton = this.props.canEditFile(file);
        return (0, _preact.h)("div", {
          className: classNames("uppy-Dashboard-FileCard", this.props.className),
          "data-uppy-panelType": "FileCard",
          onDragOver: ignoreEvent,
          onDragLeave: ignoreEvent,
          onDrop: ignoreEvent,
          onPaste: ignoreEvent
        }, (0, _preact.h)("div", {
          className: "uppy-DashboardContent-bar"
        }, (0, _preact.h)("div", {
          className: "uppy-DashboardContent-title",
          role: "heading",
          "aria-level": "1"
        }, this.props.i18nArray("editing", {
          file: (0, _preact.h)("span", {
            className: "uppy-DashboardContent-titleFile"
          }, file.meta ? file.meta.name : file.name)
        })), (0, _preact.h)("button", {
          className: "uppy-DashboardContent-back",
          type: "button",
          form: this.form.id,
          title: this.props.i18n("finishEditingFile"),
          onClick: this.handleCancel
        }, this.props.i18n("cancel"))), (0, _preact.h)("div", {
          className: "uppy-Dashboard-FileCard-inner"
        }, (0, _preact.h)("div", {
          className: "uppy-Dashboard-FileCard-preview",
          style: {
            backgroundColor: getFileTypeIcon(file.type).color
          }
        }, (0, _preact.h)(FilePreview, {
          file
        }), showEditButton && (0, _preact.h)("button", {
          type: "button",
          className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
          onClick: (event2) => {
            this.handleSave(event2);
            this.props.openFileEditor(file);
          },
          form: this.form.id
        }, this.props.i18n("editFile"))), (0, _preact.h)("div", {
          className: "uppy-Dashboard-FileCard-info"
        }, this.renderMetaFields()), (0, _preact.h)("div", {
          className: "uppy-Dashboard-FileCard-actions"
        }, (0, _preact.h)("button", {
          className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
          type: "form" in HTMLButtonElement.prototype ? "submit" : "button",
          onClick: "form" in HTMLButtonElement.prototype ? void 0 : this.handleSave,
          form: this.form.id
        }, this.props.i18n("saveChanges")), (0, _preact.h)("button", {
          className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
          type: "button",
          onClick: this.handleCancel,
          form: this.form.id
        }, this.props.i18n("cancel")))));
      }
    };
    module.exports = FileCard;
  }
});

// node_modules/@uppy/dashboard/lib/components/Slide.js
var require_Slide = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/Slide.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var classNames = require_classnames();
    var transitionName = "uppy-transition-slideDownUp";
    var duration = 250;
    var Slide = class extends _preact.Component {
      constructor(props) {
        super(props);
        this.state = {
          cachedChildren: null,
          className: ""
        };
      }
      componentWillUpdate(nextProps) {
        const {
          cachedChildren
        } = this.state;
        const child = (0, _preact.toChildArray)(nextProps.children)[0];
        if (cachedChildren === child)
          return null;
        const patch = {
          cachedChildren: child
        };
        if (child && !cachedChildren) {
          patch.className = `${transitionName}-enter`;
          cancelAnimationFrame(this.animationFrame);
          clearTimeout(this.leaveTimeout);
          this.leaveTimeout = void 0;
          this.animationFrame = requestAnimationFrame(() => {
            this.setState({
              className: `${transitionName}-enter ${transitionName}-enter-active`
            });
            this.enterTimeout = setTimeout(() => {
              this.setState({
                className: ""
              });
            }, duration);
          });
        }
        if (cachedChildren && !child && this.leaveTimeout === void 0) {
          patch.cachedChildren = cachedChildren;
          patch.className = `${transitionName}-leave`;
          cancelAnimationFrame(this.animationFrame);
          clearTimeout(this.enterTimeout);
          this.enterTimeout = void 0;
          this.animationFrame = requestAnimationFrame(() => {
            this.setState({
              className: `${transitionName}-leave ${transitionName}-leave-active`
            });
            this.leaveTimeout = setTimeout(() => {
              this.setState({
                cachedChildren: null,
                className: ""
              });
            }, duration);
          });
        }
        this.setState(patch);
      }
      render() {
        const {
          cachedChildren,
          className
        } = this.state;
        if (!cachedChildren) {
          return null;
        }
        return (0, _preact.cloneElement)(cachedChildren, {
          className: classNames(className, cachedChildren.props.className)
        });
      }
    };
    module.exports = Slide;
  }
});

// node_modules/@uppy/dashboard/lib/components/Dashboard.js
var require_Dashboard = __commonJS({
  "node_modules/@uppy/dashboard/lib/components/Dashboard.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var classNames = require_classnames();
    var isDragDropSupported = require_isDragDropSupported();
    var FileList = require_FileList();
    var AddFiles = require_AddFiles();
    var AddFilesPanel = require_AddFilesPanel();
    var PickerPanelContent = require_PickerPanelContent();
    var EditorPanel = require_EditorPanel();
    var PanelTopBar = require_PickerPanelTopBar();
    var FileCard = require_FileCard();
    var Slide = require_Slide();
    var WIDTH_XL = 900;
    var WIDTH_LG = 700;
    var WIDTH_MD = 576;
    var HEIGHT_MD = 400;
    function Dashboard2(props) {
      const noFiles = props.totalFileCount === 0;
      const isSizeMD = props.containerWidth > WIDTH_MD;
      const dashboardClassName = classNames({
        "uppy-Dashboard": true,
        "uppy-Dashboard--isDisabled": props.disabled,
        "uppy-Dashboard--animateOpenClose": props.animateOpenClose,
        "uppy-Dashboard--isClosing": props.isClosing,
        "uppy-Dashboard--isDraggingOver": props.isDraggingOver,
        "uppy-Dashboard--modal": !props.inline,
        "uppy-size--md": props.containerWidth > WIDTH_MD,
        "uppy-size--lg": props.containerWidth > WIDTH_LG,
        "uppy-size--xl": props.containerWidth > WIDTH_XL,
        "uppy-size--height-md": props.containerHeight > HEIGHT_MD,
        "uppy-Dashboard--isAddFilesPanelVisible": props.showAddFilesPanel,
        "uppy-Dashboard--isInnerWrapVisible": props.areInsidesReadyToBeVisible
      });
      let itemsPerRow = 1;
      if (props.containerWidth > WIDTH_XL) {
        itemsPerRow = 5;
      } else if (props.containerWidth > WIDTH_LG) {
        itemsPerRow = 4;
      } else if (props.containerWidth > WIDTH_MD) {
        itemsPerRow = 3;
      }
      const showFileList = props.showSelectedFiles && !noFiles;
      const numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
      const numberOfGhosts = props.files ? Object.keys(props.files).filter((fileID) => props.files[fileID].isGhost).length : null;
      const renderRestoredText = () => {
        if (numberOfGhosts > 0) {
          return props.i18n("recoveredXFiles", {
            smart_count: numberOfGhosts
          });
        }
        return props.i18n("recoveredAllFiles");
      };
      const dashboard = (0, _preact.h)("div", {
        className: dashboardClassName,
        "data-uppy-theme": props.theme,
        "data-uppy-num-acquirers": props.acquirers.length,
        "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
        "aria-hidden": props.inline ? "false" : props.isHidden,
        "aria-disabled": props.disabled,
        "aria-label": !props.inline ? props.i18n("dashboardWindowTitle") : props.i18n("dashboardTitle"),
        onPaste: props.handlePaste,
        onDragOver: props.handleDragOver,
        onDragLeave: props.handleDragLeave,
        onDrop: props.handleDrop
      }, (0, _preact.h)("div", {
        "aria-hidden": "true",
        className: "uppy-Dashboard-overlay",
        tabIndex: -1,
        onClick: props.handleClickOutside
      }), (0, _preact.h)("div", {
        className: "uppy-Dashboard-inner",
        "aria-modal": !props.inline && "true",
        role: !props.inline && "dialog",
        style: {
          width: props.inline && props.width ? props.width : "",
          height: props.inline && props.height ? props.height : ""
        }
      }, !props.inline ? (0, _preact.h)("button", {
        className: "uppy-u-reset uppy-Dashboard-close",
        type: "button",
        "aria-label": props.i18n("closeModal"),
        title: props.i18n("closeModal"),
        onClick: props.closeModal
      }, (0, _preact.h)("span", {
        "aria-hidden": "true"
      }, "\xD7")) : null, (0, _preact.h)("div", {
        className: "uppy-Dashboard-innerWrap"
      }, (0, _preact.h)("div", {
        className: "uppy-Dashboard-dropFilesHereHint"
      }, props.i18n("dropHint")), showFileList && (0, _preact.h)(PanelTopBar, props), numberOfFilesForRecovery && (0, _preact.h)("div", {
        className: "uppy-Dashboard-serviceMsg"
      }, (0, _preact.h)("svg", {
        className: "uppy-Dashboard-serviceMsg-icon",
        "aria-hidden": "true",
        focusable: "false",
        width: "21",
        height: "16",
        viewBox: "0 0 24 19"
      }, (0, _preact.h)("g", {
        transform: "translate(0 -1)",
        fill: "none",
        fillRule: "evenodd"
      }, (0, _preact.h)("path", {
        d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
        fill: "#FFD300"
      }), (0, _preact.h)("path", {
        fill: "#000",
        d: "M11 6h2l-.3 8h-1.4z"
      }), (0, _preact.h)("circle", {
        fill: "#000",
        cx: "12",
        cy: "17",
        r: "1"
      }))), (0, _preact.h)("strong", {
        className: "uppy-Dashboard-serviceMsg-title"
      }, props.i18n("sessionRestored")), (0, _preact.h)("div", {
        className: "uppy-Dashboard-serviceMsg-text"
      }, renderRestoredText())), showFileList ? (0, _preact.h)(
        FileList,
        _extends({}, props, {
          itemsPerRow
        })
      ) : (0, _preact.h)(AddFiles, _extends({}, props, {
        isSizeMD
      })), (0, _preact.h)(Slide, null, props.showAddFilesPanel ? (0, _preact.h)(AddFilesPanel, _extends({
        key: "AddFiles"
      }, props, {
        isSizeMD
      })) : null), (0, _preact.h)(Slide, null, props.fileCardFor ? (0, _preact.h)(FileCard, _extends({
        key: "FileCard"
      }, props)) : null), (0, _preact.h)(Slide, null, props.activePickerPanel ? (0, _preact.h)(PickerPanelContent, _extends({
        key: "Picker"
      }, props)) : null), (0, _preact.h)(Slide, null, props.showFileEditor ? (0, _preact.h)(EditorPanel, _extends({
        key: "Editor"
      }, props)) : null), (0, _preact.h)("div", {
        className: "uppy-Dashboard-progressindicators"
      }, props.progressindicators.map((target) => {
        return props.uppy.getPlugin(target.id).render(props.state);
      })))));
      return dashboard;
    }
    module.exports = Dashboard2;
  }
});

// node_modules/@uppy/dashboard/lib/locale.js
var require_locale4 = __commonJS({
  "node_modules/@uppy/dashboard/lib/locale.js"(exports, module) {
    "use strict";
    module.exports = {
      strings: {
        closeModal: "Close Modal",
        addMoreFiles: "Add more files",
        addingMoreFiles: "Adding more files",
        importFrom: "Import from %{name}",
        dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)",
        dashboardTitle: "Uppy Dashboard",
        copyLinkToClipboardSuccess: "Link copied to clipboard.",
        copyLinkToClipboardFallback: "Copy the URL below",
        copyLink: "Copy link",
        back: "Back",
        removeFile: "Remove file",
        editFile: "Edit file",
        editing: "Editing %{file}",
        finishEditingFile: "Finish editing file",
        saveChanges: "Save changes",
        myDevice: "My Device",
        dropHint: "Drop your files here",
        uploadComplete: "Upload complete",
        uploadPaused: "Upload paused",
        resumeUpload: "Resume upload",
        pauseUpload: "Pause upload",
        retryUpload: "Retry upload",
        cancelUpload: "Cancel upload",
        xFilesSelected: {
          0: "%{smart_count} file selected",
          1: "%{smart_count} files selected"
        },
        uploadingXFiles: {
          0: "Uploading %{smart_count} file",
          1: "Uploading %{smart_count} files"
        },
        processingXFiles: {
          0: "Processing %{smart_count} file",
          1: "Processing %{smart_count} files"
        },
        poweredBy: "Powered by %{uppy}",
        addMore: "Add more",
        editFileWithFilename: "Edit file %{file}",
        save: "Save",
        cancel: "Cancel",
        dropPasteFiles: "Drop files here or %{browseFiles}",
        dropPasteFolders: "Drop files here or %{browseFolders}",
        dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}",
        dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:",
        dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:",
        dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:",
        importFiles: "Import files from:",
        browseFiles: "browse files",
        browseFolders: "browse folders",
        recoveredXFiles: {
          0: "We could not fully recover 1 file. Please re-select it and resume the upload.",
          1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload."
        },
        recoveredAllFiles: "We restored all files. You can now resume the upload.",
        sessionRestored: "Session restored",
        reSelect: "Re-select",
        missingRequiredMetaFields: {
          0: "Missing required meta field: %{fields}.",
          1: "Missing required meta fields: %{fields}."
        }
      }
    };
  }
});

// node_modules/@uppy/dashboard/lib/Dashboard.js
var require_Dashboard2 = __commonJS({
  "node_modules/@uppy/dashboard/lib/Dashboard.js"(exports, module) {
    "use strict";
    var _preact = (init_preact_module(), __toCommonJS(preact_module_exports));
    var _core = require_lib2();
    var _nonSecure = require_non_secure();
    var trapFocus = require_trapFocus();
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var StatusBar = require_lib3();
    var Informer = require_lib4();
    var ThumbnailGenerator = require_lib5();
    var findAllDOMElements = require_findAllDOMElements();
    var toArray = require_toArray();
    var getDroppedFiles = require_getDroppedFiles();
    var memoizeOne = require_memoize_one_cjs();
    var FOCUSABLE_ELEMENTS = require_FOCUSABLE_ELEMENTS();
    var createSuperFocus = require_createSuperFocus();
    var DashboardUI = require_Dashboard();
    var packageJson = {
      "version": "2.4.3"
    };
    var locale = require_locale4();
    var memoize = memoizeOne.default || memoizeOne;
    var TAB_KEY = 9;
    var ESC_KEY = 27;
    function createPromise() {
      const o2 = {};
      o2.promise = new Promise((resolve, reject) => {
        o2.resolve = resolve;
        o2.reject = reject;
      });
      return o2;
    }
    function defaultPickerIcon() {
      return (0, _preact.h)("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "30",
        height: "30",
        viewBox: "0 0 30 30"
      }, (0, _preact.h)("path", {
        d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
      }));
    }
    var _openFileEditorWhenFilesAdded = /* @__PURE__ */ _classPrivateFieldLooseKey("openFileEditorWhenFilesAdded");
    var _attachRenderFunctionToTarget = /* @__PURE__ */ _classPrivateFieldLooseKey("attachRenderFunctionToTarget");
    var _isTargetSupported = /* @__PURE__ */ _classPrivateFieldLooseKey("isTargetSupported");
    var _getAcquirers = /* @__PURE__ */ _classPrivateFieldLooseKey("getAcquirers");
    var _getProgressIndicators = /* @__PURE__ */ _classPrivateFieldLooseKey("getProgressIndicators");
    var _getEditors = /* @__PURE__ */ _classPrivateFieldLooseKey("getEditors");
    var Dashboard2 = class extends _core.UIPlugin {
      constructor(uppy2, _opts) {
        var _this;
        super(uppy2, _opts);
        _this = this;
        this.removeTarget = (plugin) => {
          const pluginState = this.getPluginState();
          const newTargets = pluginState.targets.filter((target) => target.id !== plugin.id);
          this.setPluginState({
            targets: newTargets
          });
        };
        this.addTarget = (plugin) => {
          const callerPluginId = plugin.id || plugin.constructor.name;
          const callerPluginName = plugin.title || callerPluginId;
          const callerPluginType = plugin.type;
          if (callerPluginType !== "acquirer" && callerPluginType !== "progressindicator" && callerPluginType !== "editor") {
            const msg = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor";
            this.uppy.log(msg, "error");
            return void 0;
          }
          const target = {
            id: callerPluginId,
            name: callerPluginName,
            type: callerPluginType
          };
          const state = this.getPluginState();
          const newTargets = state.targets.slice();
          newTargets.push(target);
          this.setPluginState({
            targets: newTargets
          });
          return this.el;
        };
        this.hideAllPanels = () => {
          const state = this.getPluginState();
          const update = {
            activePickerPanel: false,
            showAddFilesPanel: false,
            activeOverlayType: null,
            fileCardFor: null,
            showFileEditor: false
          };
          if (state.activePickerPanel === update.activePickerPanel && state.showAddFilesPanel === update.showAddFilesPanel && state.showFileEditor === update.showFileEditor && state.activeOverlayType === update.activeOverlayType) {
            return;
          }
          this.setPluginState(update);
        };
        this.showPanel = (id2) => {
          const {
            targets
          } = this.getPluginState();
          const activePickerPanel = targets.filter((target) => {
            return target.type === "acquirer" && target.id === id2;
          })[0];
          this.setPluginState({
            activePickerPanel,
            activeOverlayType: "PickerPanel"
          });
        };
        this.canEditFile = (file) => {
          const {
            targets
          } = this.getPluginState();
          const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
          return editors.some((target) => this.uppy.getPlugin(target.id).canEditFile(file));
        };
        this.openFileEditor = (file) => {
          const {
            targets
          } = this.getPluginState();
          const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
          this.setPluginState({
            showFileEditor: true,
            fileCardFor: file.id || null,
            activeOverlayType: "FileEditor"
          });
          editors.forEach((editor) => {
            this.uppy.getPlugin(editor.id).selectFile(file);
          });
        };
        this.saveFileEditor = () => {
          const {
            targets
          } = this.getPluginState();
          const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
          editors.forEach((editor) => {
            this.uppy.getPlugin(editor.id).save();
          });
          this.hideAllPanels();
        };
        this.openModal = () => {
          const {
            promise,
            resolve
          } = createPromise();
          this.savedScrollPosition = window.pageYOffset;
          this.savedActiveElement = document.activeElement;
          if (this.opts.disablePageScrollWhenModalOpen) {
            document.body.classList.add("uppy-Dashboard-isFixed");
          }
          if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
            const handler = () => {
              this.setPluginState({
                isHidden: false
              });
              this.el.removeEventListener("animationend", handler, false);
              resolve();
            };
            this.el.addEventListener("animationend", handler, false);
          } else {
            this.setPluginState({
              isHidden: false
            });
            resolve();
          }
          if (this.opts.browserBackButtonClose) {
            this.updateBrowserHistory();
          }
          document.addEventListener("keydown", this.handleKeyDownInModal);
          this.uppy.emit("dashboard:modal-open");
          return promise;
        };
        this.closeModal = function(opts) {
          if (opts === void 0) {
            opts = {};
          }
          const {
            manualClose = true
          } = opts;
          const {
            isHidden,
            isClosing
          } = _this.getPluginState();
          if (isHidden || isClosing) {
            return void 0;
          }
          const {
            promise,
            resolve
          } = createPromise();
          if (_this.opts.disablePageScrollWhenModalOpen) {
            document.body.classList.remove("uppy-Dashboard-isFixed");
          }
          if (_this.opts.animateOpenClose) {
            _this.setPluginState({
              isClosing: true
            });
            const handler = () => {
              _this.setPluginState({
                isHidden: true,
                isClosing: false
              });
              _this.superFocus.cancel();
              _this.savedActiveElement.focus();
              _this.el.removeEventListener("animationend", handler, false);
              resolve();
            };
            _this.el.addEventListener("animationend", handler, false);
          } else {
            _this.setPluginState({
              isHidden: true
            });
            _this.superFocus.cancel();
            _this.savedActiveElement.focus();
            resolve();
          }
          document.removeEventListener("keydown", _this.handleKeyDownInModal);
          if (manualClose) {
            if (_this.opts.browserBackButtonClose) {
              var _history$state;
              if ((_history$state = history.state) != null && _history$state[_this.modalName]) {
                history.back();
              }
            }
          }
          _this.uppy.emit("dashboard:modal-closed");
          return promise;
        };
        this.isModalOpen = () => {
          return !this.getPluginState().isHidden || false;
        };
        this.requestCloseModal = () => {
          if (this.opts.onRequestCloseModal) {
            return this.opts.onRequestCloseModal();
          }
          return this.closeModal();
        };
        this.setDarkModeCapability = (isDarkModeOn) => {
          const {
            capabilities
          } = this.uppy.getState();
          this.uppy.setState({
            capabilities: {
              ...capabilities,
              darkMode: isDarkModeOn
            }
          });
        };
        this.handleSystemDarkModeChange = (event2) => {
          const isDarkModeOnNow = event2.matches;
          this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnNow ? "on" : "off"}`);
          this.setDarkModeCapability(isDarkModeOnNow);
        };
        this.toggleFileCard = (show, fileID) => {
          const file = this.uppy.getFile(fileID);
          if (show) {
            this.uppy.emit("dashboard:file-edit-start", file);
          } else {
            this.uppy.emit("dashboard:file-edit-complete", file);
          }
          this.setPluginState({
            fileCardFor: show ? fileID : null,
            activeOverlayType: show ? "FileCard" : null
          });
        };
        this.toggleAddFilesPanel = (show) => {
          this.setPluginState({
            showAddFilesPanel: show,
            activeOverlayType: show ? "AddFiles" : null
          });
        };
        this.addFiles = (files) => {
          const descriptors = files.map((file) => ({
            source: this.id,
            name: file.name,
            type: file.type,
            data: file,
            meta: {
              relativePath: file.relativePath || file.webkitRelativePath || null
            }
          }));
          try {
            this.uppy.addFiles(descriptors);
          } catch (err) {
            this.uppy.log(err);
          }
        };
        this.startListeningToResize = () => {
          this.resizeObserver = new ResizeObserver((entries) => {
            const uppyDashboardInnerEl = entries[0];
            const {
              width,
              height
            } = uppyDashboardInnerEl.contentRect;
            this.uppy.log(`[Dashboard] resized: ${width} / ${height}`, "debug");
            this.setPluginState({
              containerWidth: width,
              containerHeight: height,
              areInsidesReadyToBeVisible: true
            });
          });
          this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner"));
          this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => {
            const pluginState = this.getPluginState();
            const isModalAndClosed = !this.opts.inline && pluginState.isHidden;
            if (!pluginState.areInsidesReadyToBeVisible && !isModalAndClosed) {
              this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", "debug");
              this.setPluginState({
                areInsidesReadyToBeVisible: true
              });
            }
          }, 1e3);
        };
        this.stopListeningToResize = () => {
          this.resizeObserver.disconnect();
          clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
        };
        this.recordIfFocusedOnUppyRecently = (event2) => {
          if (this.el.contains(event2.target)) {
            this.ifFocusedOnUppyRecently = true;
          } else {
            this.ifFocusedOnUppyRecently = false;
            this.superFocus.cancel();
          }
        };
        this.disableAllFocusableElements = (disable) => {
          const focusableNodes = toArray(this.el.querySelectorAll(FOCUSABLE_ELEMENTS));
          if (disable) {
            focusableNodes.forEach((node) => {
              const currentTabIndex = node.getAttribute("tabindex");
              if (currentTabIndex) {
                node.dataset.inertTabindex = currentTabIndex;
              }
              node.setAttribute("tabindex", "-1");
            });
          } else {
            focusableNodes.forEach((node) => {
              if ("inertTabindex" in node.dataset) {
                node.setAttribute("tabindex", node.dataset.inertTabindex);
              } else {
                node.removeAttribute("tabindex");
              }
            });
          }
          this.dashboardIsDisabled = disable;
        };
        this.updateBrowserHistory = () => {
          var _history$state2;
          if (!((_history$state2 = history.state) != null && _history$state2[this.modalName])) {
            history.pushState({
              ...history.state,
              [this.modalName]: true
            }, "");
          }
          window.addEventListener("popstate", this.handlePopState, false);
        };
        this.handlePopState = (event2) => {
          var _event$state;
          if (this.isModalOpen() && (!event2.state || !event2.state[this.modalName])) {
            this.closeModal({
              manualClose: false
            });
          }
          if (!this.isModalOpen() && (_event$state = event2.state) != null && _event$state[this.modalName]) {
            history.back();
          }
        };
        this.handleKeyDownInModal = (event2) => {
          if (event2.keyCode === ESC_KEY)
            this.requestCloseModal(event2);
          if (event2.keyCode === TAB_KEY)
            trapFocus.forModal(event2, this.getPluginState().activeOverlayType, this.el);
        };
        this.handleClickOutside = () => {
          if (this.opts.closeModalOnClickOutside)
            this.requestCloseModal();
        };
        this.handlePaste = (event2) => {
          this.uppy.iteratePlugins((plugin) => {
            if (plugin.type === "acquirer") {
              plugin.handleRootPaste == null ? void 0 : plugin.handleRootPaste(event2);
            }
          });
          const files = toArray(event2.clipboardData.files);
          if (files.length > 0) {
            this.uppy.log("[Dashboard] Files pasted");
            this.addFiles(files);
          }
        };
        this.handleInputChange = (event2) => {
          event2.preventDefault();
          const files = toArray(event2.target.files);
          if (files.length > 0) {
            this.uppy.log("[Dashboard] Files selected through input");
            this.addFiles(files);
          }
        };
        this.handleDragOver = (event2) => {
          var _this$opts$onDragOver, _this$opts;
          event2.preventDefault();
          event2.stopPropagation();
          const canSomePluginHandleRootDrop = () => {
            let somePluginCanHandleRootDrop2 = true;
            this.uppy.iteratePlugins((plugin) => {
              if (plugin.canHandleRootDrop != null && plugin.canHandleRootDrop(event2)) {
                somePluginCanHandleRootDrop2 = true;
              }
            });
            return somePluginCanHandleRootDrop2;
          };
          const doesEventHaveFiles = () => {
            const {
              types
            } = event2.dataTransfer;
            return types.some((type) => type === "Files");
          };
          const somePluginCanHandleRootDrop = canSomePluginHandleRootDrop(event2);
          const hasFiles = doesEventHaveFiles(event2);
          if (!somePluginCanHandleRootDrop && !hasFiles || this.opts.disabled || this.opts.disableLocalFiles && (hasFiles || !somePluginCanHandleRootDrop) || !this.uppy.getState().allowNewUpload) {
            event2.dataTransfer.dropEffect = "none";
            clearTimeout(this.removeDragOverClassTimeout);
            return;
          }
          event2.dataTransfer.dropEffect = "copy";
          clearTimeout(this.removeDragOverClassTimeout);
          this.setPluginState({
            isDraggingOver: true
          });
          (_this$opts$onDragOver = (_this$opts = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts, event2);
        };
        this.handleDragLeave = (event2) => {
          var _this$opts$onDragLeav, _this$opts2;
          event2.preventDefault();
          event2.stopPropagation();
          clearTimeout(this.removeDragOverClassTimeout);
          this.removeDragOverClassTimeout = setTimeout(() => {
            this.setPluginState({
              isDraggingOver: false
            });
          }, 50);
          (_this$opts$onDragLeav = (_this$opts2 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts2, event2);
        };
        this.handleDrop = async (event2) => {
          var _this$opts$onDrop, _this$opts3;
          event2.preventDefault();
          event2.stopPropagation();
          clearTimeout(this.removeDragOverClassTimeout);
          this.setPluginState({
            isDraggingOver: false
          });
          this.uppy.iteratePlugins((plugin) => {
            if (plugin.type === "acquirer") {
              plugin.handleRootDrop == null ? void 0 : plugin.handleRootDrop(event2);
            }
          });
          let executedDropErrorOnce = false;
          const logDropError = (error) => {
            this.uppy.log(error, "error");
            if (!executedDropErrorOnce) {
              this.uppy.info(error.message, "error");
              executedDropErrorOnce = true;
            }
          };
          const files = await getDroppedFiles(event2.dataTransfer, {
            logDropError
          });
          if (files.length > 0) {
            this.uppy.log("[Dashboard] Files dropped");
            this.addFiles(files);
          }
          (_this$opts$onDrop = (_this$opts3 = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts3, event2);
        };
        this.handleRequestThumbnail = (file) => {
          if (!this.opts.waitForThumbnailsBeforeUpload) {
            this.uppy.emit("thumbnail:request", file);
          }
        };
        this.handleCancelThumbnail = (file) => {
          if (!this.opts.waitForThumbnailsBeforeUpload) {
            this.uppy.emit("thumbnail:cancel", file);
          }
        };
        this.handleKeyDownInInline = (event2) => {
          if (event2.keyCode === TAB_KEY)
            trapFocus.forInline(event2, this.getPluginState().activeOverlayType, this.el);
        };
        this.handlePasteOnBody = (event2) => {
          const isFocusInOverlay = this.el.contains(document.activeElement);
          if (isFocusInOverlay) {
            this.handlePaste(event2);
          }
        };
        this.handleComplete = (_ref) => {
          let {
            failed
          } = _ref;
          if (this.opts.closeAfterFinish && failed.length === 0) {
            this.requestCloseModal();
          }
        };
        this.handleCancelRestore = () => {
          this.uppy.emit("restore-canceled");
        };
        Object.defineProperty(this, _openFileEditorWhenFilesAdded, {
          writable: true,
          value: (files) => {
            const firstFile = files[0];
            if (this.canEditFile(firstFile)) {
              this.openFileEditor(firstFile);
            }
          }
        });
        this.initEvents = () => {
          if (this.opts.trigger && !this.opts.inline) {
            const showModalTrigger = findAllDOMElements(this.opts.trigger);
            if (showModalTrigger) {
              showModalTrigger.forEach((trigger) => trigger.addEventListener("click", this.openModal));
            } else {
              this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning");
            }
          }
          this.startListeningToResize();
          document.addEventListener("paste", this.handlePasteOnBody);
          this.uppy.on("plugin-remove", this.removeTarget);
          this.uppy.on("file-added", this.hideAllPanels);
          this.uppy.on("dashboard:modal-closed", this.hideAllPanels);
          this.uppy.on("file-editor:complete", this.hideAllPanels);
          this.uppy.on("complete", this.handleComplete);
          document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, true);
          document.addEventListener("click", this.recordIfFocusedOnUppyRecently, true);
          if (this.opts.inline) {
            this.el.addEventListener("keydown", this.handleKeyDownInInline);
          }
          if (this.opts.autoOpenFileEditor) {
            this.uppy.on("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
          }
        };
        this.removeEvents = () => {
          const showModalTrigger = findAllDOMElements(this.opts.trigger);
          if (!this.opts.inline && showModalTrigger) {
            showModalTrigger.forEach((trigger) => trigger.removeEventListener("click", this.openModal));
          }
          this.stopListeningToResize();
          document.removeEventListener("paste", this.handlePasteOnBody);
          window.removeEventListener("popstate", this.handlePopState, false);
          this.uppy.off("plugin-remove", this.removeTarget);
          this.uppy.off("file-added", this.hideAllPanels);
          this.uppy.off("dashboard:modal-closed", this.hideAllPanels);
          this.uppy.off("file-editor:complete", this.hideAllPanels);
          this.uppy.off("complete", this.handleComplete);
          document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently);
          document.removeEventListener("click", this.recordIfFocusedOnUppyRecently);
          if (this.opts.inline) {
            this.el.removeEventListener("keydown", this.handleKeyDownInInline);
          }
          if (this.opts.autoOpenFileEditor) {
            this.uppy.off("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
          }
        };
        this.superFocusOnEachUpdate = () => {
          const isFocusInUppy = this.el.contains(document.activeElement);
          const isFocusNowhere = document.activeElement === document.body || document.activeElement === null;
          const isInformerHidden = this.uppy.getState().info.length === 0;
          const isModal = !this.opts.inline;
          if (isInformerHidden && (isModal || isFocusInUppy || isFocusNowhere && this.ifFocusedOnUppyRecently)) {
            this.superFocus(this.el, this.getPluginState().activeOverlayType);
          } else {
            this.superFocus.cancel();
          }
        };
        this.afterUpdate = () => {
          if (this.opts.disabled && !this.dashboardIsDisabled) {
            this.disableAllFocusableElements(true);
            return;
          }
          if (!this.opts.disabled && this.dashboardIsDisabled) {
            this.disableAllFocusableElements(false);
          }
          this.superFocusOnEachUpdate();
        };
        this.saveFileCard = (meta, fileID) => {
          this.uppy.setFileMeta(fileID, meta);
          this.toggleFileCard(false, fileID);
        };
        Object.defineProperty(this, _attachRenderFunctionToTarget, {
          writable: true,
          value: (target) => {
            const plugin = this.uppy.getPlugin(target.id);
            return {
              ...target,
              icon: plugin.icon || this.opts.defaultPickerIcon,
              render: plugin.render
            };
          }
        });
        Object.defineProperty(this, _isTargetSupported, {
          writable: true,
          value: (target) => {
            const plugin = this.uppy.getPlugin(target.id);
            if (typeof plugin.isSupported !== "function") {
              return true;
            }
            return plugin.isSupported();
          }
        });
        Object.defineProperty(this, _getAcquirers, {
          writable: true,
          value: memoize((targets) => {
            return targets.filter((target) => target.type === "acquirer" && _classPrivateFieldLooseBase(this, _isTargetSupported)[_isTargetSupported](target)).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
          })
        });
        Object.defineProperty(this, _getProgressIndicators, {
          writable: true,
          value: memoize((targets) => {
            return targets.filter((target) => target.type === "progressindicator").map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
          })
        });
        Object.defineProperty(this, _getEditors, {
          writable: true,
          value: memoize((targets) => {
            return targets.filter((target) => target.type === "editor").map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
          })
        });
        this.render = (state) => {
          const pluginState = this.getPluginState();
          const {
            files,
            capabilities,
            allowNewUpload
          } = state;
          const {
            newFiles,
            uploadStartedFiles,
            completeFiles,
            erroredFiles,
            inProgressFiles,
            inProgressNotPausedFiles,
            processingFiles,
            isUploadStarted,
            isAllComplete,
            isAllErrored,
            isAllPaused
          } = this.uppy.getObjectOfFilesPerState();
          const acquirers = _classPrivateFieldLooseBase(this, _getAcquirers)[_getAcquirers](pluginState.targets);
          const progressindicators = _classPrivateFieldLooseBase(this, _getProgressIndicators)[_getProgressIndicators](pluginState.targets);
          const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](pluginState.targets);
          let theme;
          if (this.opts.theme === "auto") {
            theme = capabilities.darkMode ? "dark" : "light";
          } else {
            theme = this.opts.theme;
          }
          if (["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0) {
            this.opts.fileManagerSelectionType = "files";
            console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`);
          }
          return DashboardUI({
            state,
            isHidden: pluginState.isHidden,
            files,
            newFiles,
            uploadStartedFiles,
            completeFiles,
            erroredFiles,
            inProgressFiles,
            inProgressNotPausedFiles,
            processingFiles,
            isUploadStarted,
            isAllComplete,
            isAllErrored,
            isAllPaused,
            totalFileCount: Object.keys(files).length,
            totalProgress: state.totalProgress,
            allowNewUpload,
            acquirers,
            theme,
            disabled: this.opts.disabled,
            disableLocalFiles: this.opts.disableLocalFiles,
            direction: this.opts.direction,
            activePickerPanel: pluginState.activePickerPanel,
            showFileEditor: pluginState.showFileEditor,
            saveFileEditor: this.saveFileEditor,
            disableAllFocusableElements: this.disableAllFocusableElements,
            animateOpenClose: this.opts.animateOpenClose,
            isClosing: pluginState.isClosing,
            progressindicators,
            editors,
            autoProceed: this.uppy.opts.autoProceed,
            id: this.id,
            closeModal: this.requestCloseModal,
            handleClickOutside: this.handleClickOutside,
            handleInputChange: this.handleInputChange,
            handlePaste: this.handlePaste,
            inline: this.opts.inline,
            showPanel: this.showPanel,
            hideAllPanels: this.hideAllPanels,
            i18n: this.i18n,
            i18nArray: this.i18nArray,
            uppy: this.uppy,
            note: this.opts.note,
            recoveredState: state.recoveredState,
            metaFields: pluginState.metaFields,
            resumableUploads: capabilities.resumableUploads || false,
            individualCancellation: capabilities.individualCancellation,
            isMobileDevice: capabilities.isMobileDevice,
            fileCardFor: pluginState.fileCardFor,
            toggleFileCard: this.toggleFileCard,
            toggleAddFilesPanel: this.toggleAddFilesPanel,
            showAddFilesPanel: pluginState.showAddFilesPanel,
            saveFileCard: this.saveFileCard,
            openFileEditor: this.openFileEditor,
            canEditFile: this.canEditFile,
            width: this.opts.width,
            height: this.opts.height,
            showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
            fileManagerSelectionType: this.opts.fileManagerSelectionType,
            proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
            hideCancelButton: this.opts.hideCancelButton,
            hideRetryButton: this.opts.hideRetryButton,
            hidePauseResumeButton: this.opts.hidePauseResumeButton,
            showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
            containerWidth: pluginState.containerWidth,
            containerHeight: pluginState.containerHeight,
            areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
            isTargetDOMEl: this.isTargetDOMEl,
            parentElement: this.el,
            allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
            maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
            requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
            showSelectedFiles: this.opts.showSelectedFiles,
            handleCancelRestore: this.handleCancelRestore,
            handleRequestThumbnail: this.handleRequestThumbnail,
            handleCancelThumbnail: this.handleCancelThumbnail,
            isDraggingOver: pluginState.isDraggingOver,
            handleDragOver: this.handleDragOver,
            handleDragLeave: this.handleDragLeave,
            handleDrop: this.handleDrop
          });
        };
        this.discoverProviderPlugins = () => {
          this.uppy.iteratePlugins((plugin) => {
            if (plugin && !plugin.target && plugin.opts && plugin.opts.target === this.constructor) {
              this.addTarget(plugin);
            }
          });
        };
        this.install = () => {
          this.setPluginState({
            isHidden: true,
            fileCardFor: null,
            activeOverlayType: null,
            showAddFilesPanel: false,
            activePickerPanel: false,
            showFileEditor: false,
            metaFields: this.opts.metaFields,
            targets: [],
            areInsidesReadyToBeVisible: false,
            isDraggingOver: false
          });
          const {
            inline,
            closeAfterFinish
          } = this.opts;
          if (inline && closeAfterFinish) {
            throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.");
          }
          const {
            allowMultipleUploads,
            allowMultipleUploadBatches
          } = this.uppy.opts;
          if ((allowMultipleUploads || allowMultipleUploadBatches) && closeAfterFinish) {
            this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning");
          }
          const {
            target
          } = this.opts;
          if (target) {
            this.mount(target, this);
          }
          const plugins = this.opts.plugins || [];
          plugins.forEach((pluginID) => {
            const plugin = this.uppy.getPlugin(pluginID);
            if (plugin) {
              plugin.mount(this, plugin);
            }
          });
          if (!this.opts.disableStatusBar) {
            this.uppy.use(StatusBar, {
              id: `${this.id}:StatusBar`,
              target: this,
              hideUploadButton: this.opts.hideUploadButton,
              hideRetryButton: this.opts.hideRetryButton,
              hidePauseResumeButton: this.opts.hidePauseResumeButton,
              hideCancelButton: this.opts.hideCancelButton,
              showProgressDetails: this.opts.showProgressDetails,
              hideAfterFinish: this.opts.hideProgressAfterFinish,
              locale: this.opts.locale,
              doneButtonHandler: this.opts.doneButtonHandler
            });
          }
          if (!this.opts.disableInformer) {
            this.uppy.use(Informer, {
              id: `${this.id}:Informer`,
              target: this
            });
          }
          if (!this.opts.disableThumbnailGenerator) {
            this.uppy.use(ThumbnailGenerator, {
              id: `${this.id}:ThumbnailGenerator`,
              thumbnailWidth: this.opts.thumbnailWidth,
              thumbnailHeight: this.opts.thumbnailHeight,
              thumbnailType: this.opts.thumbnailType,
              waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload,
              lazy: !this.opts.waitForThumbnailsBeforeUpload
            });
          }
          this.darkModeMediaQuery = typeof window !== "undefined" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
          const isDarkModeOnFromTheStart = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : false;
          this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnFromTheStart ? "on" : "off"}`);
          this.setDarkModeCapability(isDarkModeOnFromTheStart);
          if (this.opts.theme === "auto") {
            this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange);
          }
          this.discoverProviderPlugins();
          this.initEvents();
        };
        this.uninstall = () => {
          if (!this.opts.disableInformer) {
            const informer = this.uppy.getPlugin(`${this.id}:Informer`);
            if (informer)
              this.uppy.removePlugin(informer);
          }
          if (!this.opts.disableStatusBar) {
            const statusBar = this.uppy.getPlugin(`${this.id}:StatusBar`);
            if (statusBar)
              this.uppy.removePlugin(statusBar);
          }
          if (!this.opts.disableThumbnailGenerator) {
            const thumbnail = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
            if (thumbnail)
              this.uppy.removePlugin(thumbnail);
          }
          const plugins = this.opts.plugins || [];
          plugins.forEach((pluginID) => {
            const plugin = this.uppy.getPlugin(pluginID);
            if (plugin)
              plugin.unmount();
          });
          if (this.opts.theme === "auto") {
            this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange);
          }
          this.unmount();
          this.removeEvents();
        };
        this.id = this.opts.id || "Dashboard";
        this.title = "Dashboard";
        this.type = "orchestrator";
        this.modalName = `uppy-Dashboard-${(0, _nonSecure.nanoid)()}`;
        this.defaultLocale = locale;
        const defaultOptions = {
          target: "body",
          metaFields: [],
          trigger: null,
          inline: false,
          width: 750,
          height: 550,
          thumbnailWidth: 280,
          thumbnailType: "image/jpeg",
          waitForThumbnailsBeforeUpload: false,
          defaultPickerIcon,
          showLinkToFileUploadResult: false,
          showProgressDetails: false,
          hideUploadButton: false,
          hideCancelButton: false,
          hideRetryButton: false,
          hidePauseResumeButton: false,
          hideProgressAfterFinish: false,
          doneButtonHandler: () => {
            this.uppy.reset();
            this.requestCloseModal();
          },
          note: null,
          closeModalOnClickOutside: false,
          closeAfterFinish: false,
          disableStatusBar: false,
          disableInformer: false,
          disableThumbnailGenerator: false,
          disablePageScrollWhenModalOpen: true,
          animateOpenClose: true,
          fileManagerSelectionType: "files",
          proudlyDisplayPoweredByUppy: true,
          onRequestCloseModal: () => this.closeModal(),
          showSelectedFiles: true,
          showRemoveButtonAfterComplete: false,
          browserBackButtonClose: false,
          theme: "light",
          autoOpenFileEditor: false,
          disabled: false,
          disableLocalFiles: false
        };
        this.opts = {
          ...defaultOptions,
          ..._opts
        };
        this.i18nInit();
        this.superFocus = createSuperFocus();
        this.ifFocusedOnUppyRecently = false;
        this.makeDashboardInsidesVisibleAnywayTimeout = null;
        this.removeDragOverClassTimeout = null;
      }
    };
    Dashboard2.VERSION = packageJson.version;
    module.exports = Dashboard2;
  }
});

// node_modules/@uppy/dashboard/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@uppy/dashboard/lib/index.js"(exports, module) {
    "use strict";
    module.exports = require_Dashboard2();
  }
});

// node_modules/@uppy/utils/lib/NetworkError.js
var require_NetworkError = __commonJS({
  "node_modules/@uppy/utils/lib/NetworkError.js"(exports, module) {
    "use strict";
    var NetworkError = class extends Error {
      constructor(error, xhr) {
        if (xhr === void 0) {
          xhr = null;
        }
        super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
        this.cause = error;
        this.isNetworkError = true;
        this.request = xhr;
      }
    };
    module.exports = NetworkError;
  }
});

// node_modules/@uppy/utils/lib/fetchWithNetworkError.js
var require_fetchWithNetworkError = __commonJS({
  "node_modules/@uppy/utils/lib/fetchWithNetworkError.js"(exports, module) {
    "use strict";
    var NetworkError = require_NetworkError();
    function fetchWithNetworkError() {
      return fetch(...arguments).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        } else {
          throw new NetworkError(err);
        }
      });
    }
    module.exports = fetchWithNetworkError;
  }
});

// node_modules/@uppy/utils/lib/ErrorWithCause.js
var require_ErrorWithCause = __commonJS({
  "node_modules/@uppy/utils/lib/ErrorWithCause.js"(exports, module) {
    "use strict";
    var hasProperty = require_hasProperty();
    var ErrorWithCause = class extends Error {
      constructor(message, options) {
        if (options === void 0) {
          options = {};
        }
        super(message);
        this.cause = options.cause;
        if (this.cause && hasProperty(this.cause, "isNetworkError")) {
          this.isNetworkError = this.cause.isNetworkError;
        }
      }
    };
    module.exports = ErrorWithCause;
  }
});

// node_modules/@uppy/companion-client/lib/AuthError.js
var require_AuthError = __commonJS({
  "node_modules/@uppy/companion-client/lib/AuthError.js"(exports, module) {
    "use strict";
    var AuthError = class extends Error {
      constructor() {
        super("Authorization required");
        this.name = "AuthError";
        this.isAuthError = true;
      }
    };
    module.exports = AuthError;
  }
});

// node_modules/@uppy/companion-client/lib/RequestClient.js
var require_RequestClient = __commonJS({
  "node_modules/@uppy/companion-client/lib/RequestClient.js"(exports, module) {
    "use strict";
    var _Symbol$for;
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var fetchWithNetworkError = require_fetchWithNetworkError();
    var ErrorWithCause = require_ErrorWithCause();
    var AuthError = require_AuthError();
    var packageJson = {
      "version": "2.2.2"
    };
    function stripSlash(url2) {
      return url2.replace(/\/$/, "");
    }
    async function handleJSONResponse(res) {
      if (res.status === 401) {
        throw new AuthError();
      }
      const jsonPromise = res.json();
      if (res.status < 200 || res.status > 300) {
        let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
        try {
          const errData = await jsonPromise;
          errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
          errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
        } finally {
          throw new Error(errMsg);
        }
      }
      return jsonPromise;
    }
    var _companionHeaders = /* @__PURE__ */ _classPrivateFieldLooseKey("companionHeaders");
    var _getPostResponseFunc = /* @__PURE__ */ _classPrivateFieldLooseKey("getPostResponseFunc");
    var _getUrl = /* @__PURE__ */ _classPrivateFieldLooseKey("getUrl");
    var _errorHandler = /* @__PURE__ */ _classPrivateFieldLooseKey("errorHandler");
    _Symbol$for = Symbol.for("uppy test: getCompanionHeaders");
    var RequestClient = class {
      constructor(uppy2, opts) {
        Object.defineProperty(this, _errorHandler, {
          value: _errorHandler2
        });
        Object.defineProperty(this, _getUrl, {
          value: _getUrl2
        });
        Object.defineProperty(this, _companionHeaders, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _getPostResponseFunc, {
          writable: true,
          value: (skip) => (response) => skip ? response : this.onReceiveResponse(response)
        });
        this.uppy = uppy2;
        this.opts = opts;
        this.onReceiveResponse = this.onReceiveResponse.bind(this);
        this.allowedHeaders = ["accept", "content-type", "uppy-auth-token"];
        this.preflightDone = false;
        _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = opts == null ? void 0 : opts.companionHeaders;
      }
      setCompanionHeaders(headers) {
        _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = headers;
      }
      [_Symbol$for]() {
        return _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders];
      }
      get hostname() {
        const {
          companion
        } = this.uppy.getState();
        const host = this.opts.companionUrl;
        return stripSlash(companion && companion[host] ? companion[host] : host);
      }
      headers() {
        return Promise.resolve({
          ...RequestClient.defaultHeaders,
          ..._classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders]
        });
      }
      onReceiveResponse(response) {
        const state = this.uppy.getState();
        const companion = state.companion || {};
        const host = this.opts.companionUrl;
        const {
          headers
        } = response;
        if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
          this.uppy.setState({
            companion: {
              ...companion,
              [host]: headers.get("i-am")
            }
          });
        }
        return response;
      }
      preflight(path) {
        if (this.preflightDone) {
          return Promise.resolve(this.allowedHeaders.slice());
        }
        return fetch(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
          method: "OPTIONS"
        }).then((response) => {
          if (response.headers.has("access-control-allow-headers")) {
            this.allowedHeaders = response.headers.get("access-control-allow-headers").split(",").map((headerName) => headerName.trim().toLowerCase());
          }
          this.preflightDone = true;
          return this.allowedHeaders.slice();
        }).catch((err) => {
          this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, "warning");
          this.preflightDone = true;
          return this.allowedHeaders.slice();
        });
      }
      preflightAndHeaders(path) {
        return Promise.all([this.preflight(path), this.headers()]).then((_ref) => {
          let [allowedHeaders, headers] = _ref;
          Object.keys(headers).forEach((header) => {
            if (!allowedHeaders.includes(header.toLowerCase())) {
              this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
              delete headers[header];
            }
          });
          return headers;
        });
      }
      get(path, skipPostResponse) {
        const method = "get";
        return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
          method,
          headers,
          credentials: this.opts.companionCookiesRule || "same-origin"
        })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
      }
      post(path, data, skipPostResponse) {
        const method = "post";
        return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
          method,
          headers,
          credentials: this.opts.companionCookiesRule || "same-origin",
          body: JSON.stringify(data)
        })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
      }
      delete(path, data, skipPostResponse) {
        const method = "delete";
        return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(`${this.hostname}/${path}`, {
          method,
          headers,
          credentials: this.opts.companionCookiesRule || "same-origin",
          body: data ? JSON.stringify(data) : null
        })).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
      }
    };
    function _getUrl2(url2) {
      if (/^(https?:|)\/\//.test(url2)) {
        return url2;
      }
      return `${this.hostname}/${url2}`;
    }
    function _errorHandler2(method, path) {
      return (err) => {
        var _err;
        if (!((_err = err) != null && _err.isAuthError)) {
          err = new ErrorWithCause(`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`, {
            cause: err
          });
        }
        return Promise.reject(err);
      };
    }
    RequestClient.VERSION = packageJson.version;
    RequestClient.defaultHeaders = {
      Accept: "application/json",
      "Content-Type": "application/json",
      "Uppy-Versions": `@uppy/companion-client=${RequestClient.VERSION}`
    };
    module.exports = RequestClient;
  }
});

// node_modules/@uppy/companion-client/lib/tokenStorage.js
var require_tokenStorage = __commonJS({
  "node_modules/@uppy/companion-client/lib/tokenStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getItem = getItem;
    exports.removeItem = removeItem;
    exports.setItem = setItem;
    function setItem(key, value) {
      return new Promise((resolve) => {
        localStorage.setItem(key, value);
        resolve();
      });
    }
    function getItem(key) {
      return Promise.resolve(localStorage.getItem(key));
    }
    function removeItem(key) {
      return new Promise((resolve) => {
        localStorage.removeItem(key);
        resolve();
      });
    }
  }
});

// node_modules/@uppy/companion-client/lib/Provider.js
var require_Provider = __commonJS({
  "node_modules/@uppy/companion-client/lib/Provider.js"(exports, module) {
    "use strict";
    var tokenStorage = require_tokenStorage();
    var RequestClient = require_RequestClient();
    var getName = (id) => {
      return id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
    };
    var Provider = class extends RequestClient {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.provider = opts.provider;
        this.id = this.provider;
        this.name = this.opts.name || getName(this.id);
        this.pluginId = this.opts.pluginId;
        this.tokenKey = `companion-${this.pluginId}-auth-token`;
        this.companionKeysParams = this.opts.companionKeysParams;
        this.preAuthToken = null;
      }
      headers() {
        return Promise.all([super.headers(), this.getAuthToken()]).then((_ref) => {
          let [headers, token] = _ref;
          const authHeaders = {};
          if (token) {
            authHeaders["uppy-auth-token"] = token;
          }
          if (this.companionKeysParams) {
            authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
              params: this.companionKeysParams
            }));
          }
          return {
            ...headers,
            ...authHeaders
          };
        });
      }
      onReceiveResponse(response) {
        response = super.onReceiveResponse(response);
        const plugin = this.uppy.getPlugin(this.pluginId);
        const oldAuthenticated = plugin.getPluginState().authenticated;
        const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
        plugin.setPluginState({
          authenticated
        });
        return response;
      }
      setAuthToken(token) {
        return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
      }
      getAuthToken() {
        return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
      }
      async ensurePreAuth() {
        if (this.companionKeysParams && !this.preAuthToken) {
          await this.fetchPreAuthToken();
          if (!this.preAuthToken) {
            throw new Error("Could not load authentication data required for third-party login. Please try again later.");
          }
        }
      }
      authUrl(queries) {
        if (queries === void 0) {
          queries = {};
        }
        const params = new URLSearchParams(queries);
        if (this.preAuthToken) {
          params.set("uppyPreAuthToken", this.preAuthToken);
        }
        return `${this.hostname}/${this.id}/connect?${params}`;
      }
      fileUrl(id) {
        return `${this.hostname}/${this.id}/get/${id}`;
      }
      async fetchPreAuthToken() {
        if (!this.companionKeysParams) {
          return;
        }
        try {
          const res = await this.post(`${this.id}/preauth/`, {
            params: this.companionKeysParams
          });
          this.preAuthToken = res.token;
        } catch (err) {
          this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, "warning");
        }
      }
      list(directory) {
        return this.get(`${this.id}/list/${directory || ""}`);
      }
      logout() {
        return this.get(`${this.id}/logout`).then((response) => Promise.all([response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)])).then((_ref2) => {
          let [response] = _ref2;
          return response;
        });
      }
      static initPlugin(plugin, opts, defaultOpts) {
        plugin.type = "acquirer";
        plugin.files = [];
        if (defaultOpts) {
          plugin.opts = {
            ...defaultOpts,
            ...opts
          };
        }
        if (opts.serverUrl || opts.serverPattern) {
          throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
        }
        if (opts.companionAllowedHosts) {
          const pattern = opts.companionAllowedHosts;
          if (typeof pattern !== "string" && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
            throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
          }
          plugin.opts.companionAllowedHosts = pattern;
        } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
          plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`;
        } else {
          plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
        }
        plugin.storage = plugin.opts.storage || tokenStorage;
      }
    };
    module.exports = Provider;
  }
});

// node_modules/@uppy/companion-client/lib/SearchProvider.js
var require_SearchProvider = __commonJS({
  "node_modules/@uppy/companion-client/lib/SearchProvider.js"(exports, module) {
    "use strict";
    var RequestClient = require_RequestClient();
    var getName = (id) => {
      return id.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
    };
    var SearchProvider = class extends RequestClient {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.provider = opts.provider;
        this.id = this.provider;
        this.name = this.opts.name || getName(this.id);
        this.pluginId = this.opts.pluginId;
      }
      fileUrl(id) {
        return `${this.hostname}/search/${this.id}/get/${id}`;
      }
      search(text, queries) {
        return this.get(`search/${this.id}/list?q=${encodeURIComponent(text)}${queries ? `&${queries}` : ""}`);
      }
    };
    module.exports = SearchProvider;
  }
});

// node_modules/@uppy/companion-client/lib/Socket.js
var require_Socket = __commonJS({
  "node_modules/@uppy/companion-client/lib/Socket.js"(exports, module) {
    "use strict";
    var _Symbol$for;
    var _Symbol$for2;
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var ee = require_namespace_emitter();
    var _queued = /* @__PURE__ */ _classPrivateFieldLooseKey("queued");
    var _emitter = /* @__PURE__ */ _classPrivateFieldLooseKey("emitter");
    var _isOpen = /* @__PURE__ */ _classPrivateFieldLooseKey("isOpen");
    var _socket = /* @__PURE__ */ _classPrivateFieldLooseKey("socket");
    var _handleMessage = /* @__PURE__ */ _classPrivateFieldLooseKey("handleMessage");
    _Symbol$for = Symbol.for("uppy test: getSocket");
    _Symbol$for2 = Symbol.for("uppy test: getQueued");
    var UppySocket = class {
      constructor(opts) {
        Object.defineProperty(this, _queued, {
          writable: true,
          value: []
        });
        Object.defineProperty(this, _emitter, {
          writable: true,
          value: ee()
        });
        Object.defineProperty(this, _isOpen, {
          writable: true,
          value: false
        });
        Object.defineProperty(this, _socket, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _handleMessage, {
          writable: true,
          value: (e2) => {
            try {
              const message = JSON.parse(e2.data);
              this.emit(message.action, message.payload);
            } catch (err) {
              console.log(err);
            }
          }
        });
        this.opts = opts;
        if (!opts || opts.autoOpen !== false) {
          this.open();
        }
      }
      get isOpen() {
        return _classPrivateFieldLooseBase(this, _isOpen)[_isOpen];
      }
      [_Symbol$for]() {
        return _classPrivateFieldLooseBase(this, _socket)[_socket];
      }
      [_Symbol$for2]() {
        return _classPrivateFieldLooseBase(this, _queued)[_queued];
      }
      open() {
        _classPrivateFieldLooseBase(this, _socket)[_socket] = new WebSocket(this.opts.target);
        _classPrivateFieldLooseBase(this, _socket)[_socket].onopen = () => {
          _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = true;
          while (_classPrivateFieldLooseBase(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
            const first = _classPrivateFieldLooseBase(this, _queued)[_queued].shift();
            this.send(first.action, first.payload);
          }
        };
        _classPrivateFieldLooseBase(this, _socket)[_socket].onclose = () => {
          _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = false;
        };
        _classPrivateFieldLooseBase(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase(this, _handleMessage)[_handleMessage];
      }
      close() {
        var _classPrivateFieldLoo;
        (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
      }
      send(action, payload) {
        if (!_classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
          _classPrivateFieldLooseBase(this, _queued)[_queued].push({
            action,
            payload
          });
          return;
        }
        _classPrivateFieldLooseBase(this, _socket)[_socket].send(JSON.stringify({
          action,
          payload
        }));
      }
      on(action, handler) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(action, handler);
      }
      emit(action, payload) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(action, payload);
      }
      once(action, handler) {
        _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(action, handler);
      }
    };
    module.exports = UppySocket;
  }
});

// node_modules/@uppy/companion-client/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@uppy/companion-client/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Socket = exports.SearchProvider = exports.RequestClient = exports.Provider = void 0;
    var _0 = require_RequestClient();
    exports.RequestClient = _0;
    var _1 = require_Provider();
    exports.Provider = _1;
    var _22 = require_SearchProvider();
    exports.SearchProvider = _22;
    var _32 = require_Socket();
    exports.Socket = _32;
  }
});

// node_modules/@uppy/utils/lib/RateLimitedQueue.js
var require_RateLimitedQueue = __commonJS({
  "node_modules/@uppy/utils/lib/RateLimitedQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.internalRateLimitedQueue = exports.RateLimitedQueue = void 0;
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    function createCancelError() {
      return new Error("Cancelled");
    }
    var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey("activeRequests");
    var _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey("queuedHandlers");
    var _paused = /* @__PURE__ */ _classPrivateFieldLooseKey("paused");
    var _pauseTimer = /* @__PURE__ */ _classPrivateFieldLooseKey("pauseTimer");
    var _downLimit = /* @__PURE__ */ _classPrivateFieldLooseKey("downLimit");
    var _upperLimit = /* @__PURE__ */ _classPrivateFieldLooseKey("upperLimit");
    var _rateLimitingTimer = /* @__PURE__ */ _classPrivateFieldLooseKey("rateLimitingTimer");
    var _call = /* @__PURE__ */ _classPrivateFieldLooseKey("call");
    var _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey("queueNext");
    var _next = /* @__PURE__ */ _classPrivateFieldLooseKey("next");
    var _queue = /* @__PURE__ */ _classPrivateFieldLooseKey("queue");
    var _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey("dequeue");
    var _resume = /* @__PURE__ */ _classPrivateFieldLooseKey("resume");
    var _increaseLimit = /* @__PURE__ */ _classPrivateFieldLooseKey("increaseLimit");
    var RateLimitedQueue = class {
      constructor(limit) {
        Object.defineProperty(this, _dequeue, {
          value: _dequeue2
        });
        Object.defineProperty(this, _queue, {
          value: _queue2
        });
        Object.defineProperty(this, _next, {
          value: _next2
        });
        Object.defineProperty(this, _queueNext, {
          value: _queueNext2
        });
        Object.defineProperty(this, _call, {
          value: _call2
        });
        Object.defineProperty(this, _activeRequests, {
          writable: true,
          value: 0
        });
        Object.defineProperty(this, _queuedHandlers, {
          writable: true,
          value: []
        });
        Object.defineProperty(this, _paused, {
          writable: true,
          value: false
        });
        Object.defineProperty(this, _pauseTimer, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _downLimit, {
          writable: true,
          value: 1
        });
        Object.defineProperty(this, _upperLimit, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _rateLimitingTimer, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _resume, {
          writable: true,
          value: () => this.resume()
        });
        Object.defineProperty(this, _increaseLimit, {
          writable: true,
          value: () => {
            if (_classPrivateFieldLooseBase(this, _paused)[_paused]) {
              _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 0);
              return;
            }
            _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = this.limit;
            this.limit = Math.ceil((_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]) / 2);
            for (let i2 = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]; i2 <= this.limit; i2++) {
              _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
            }
            if (_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] > 3) {
              _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 2e3);
            } else {
              _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase(this, _downLimit)[_downLimit] / 2);
            }
          }
        });
        if (typeof limit !== "number" || limit === 0) {
          this.limit = Infinity;
        } else {
          this.limit = limit;
        }
      }
      run(fn, queueOptions) {
        if (!_classPrivateFieldLooseBase(this, _paused)[_paused] && _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {
          return _classPrivateFieldLooseBase(this, _call)[_call](fn);
        }
        return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);
      }
      wrapPromiseFunction(fn, queueOptions) {
        var _this = this;
        return function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          let queuedRequest;
          const outerPromise = new Promise((resolve, reject) => {
            queuedRequest = _this.run(() => {
              let cancelError;
              let innerPromise;
              try {
                innerPromise = Promise.resolve(fn(...args));
              } catch (err) {
                innerPromise = Promise.reject(err);
              }
              innerPromise.then((result) => {
                if (cancelError) {
                  reject(cancelError);
                } else {
                  queuedRequest.done();
                  resolve(result);
                }
              }, (err) => {
                if (cancelError) {
                  reject(cancelError);
                } else {
                  queuedRequest.done();
                  reject(err);
                }
              });
              return () => {
                cancelError = createCancelError();
              };
            }, queueOptions);
          });
          outerPromise.abort = () => {
            queuedRequest.abort();
          };
          return outerPromise;
        };
      }
      resume() {
        _classPrivateFieldLooseBase(this, _paused)[_paused] = false;
        clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);
        for (let i2 = 0; i2 < this.limit; i2++) {
          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
        }
      }
      pause(duration) {
        if (duration === void 0) {
          duration = null;
        }
        _classPrivateFieldLooseBase(this, _paused)[_paused] = true;
        clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);
        if (duration != null) {
          _classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase(this, _resume)[_resume], duration);
        }
      }
      rateLimit(duration) {
        clearTimeout(_classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer]);
        this.pause(duration);
        if (this.limit > 1 && Number.isFinite(this.limit)) {
          _classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] = this.limit - 1;
          this.limit = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit];
          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], duration);
        }
      }
      get isPaused() {
        return _classPrivateFieldLooseBase(this, _paused)[_paused];
      }
    };
    exports.RateLimitedQueue = RateLimitedQueue;
    function _call2(fn) {
      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;
      let done = false;
      let cancelActive;
      try {
        cancelActive = fn();
      } catch (err) {
        _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
        throw err;
      }
      return {
        abort: () => {
          if (done)
            return;
          done = true;
          _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
          cancelActive();
          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
        },
        done: () => {
          if (done)
            return;
          done = true;
          _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
        }
      };
    }
    function _queueNext2() {
      queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());
    }
    function _next2() {
      if (_classPrivateFieldLooseBase(this, _paused)[_paused] || _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {
        return;
      }
      if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {
        return;
      }
      const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();
      const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);
      next.abort = handler.abort;
      next.done = handler.done;
    }
    function _queue2(fn, options) {
      if (options === void 0) {
        options = {};
      }
      const handler = {
        fn,
        priority: options.priority || 0,
        abort: () => {
          _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);
        },
        done: () => {
          throw new Error("Cannot mark a queued request as done: this indicates a bug");
        }
      };
      const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
        return handler.priority > other.priority;
      });
      if (index === -1) {
        _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler);
      } else {
        _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
      }
      return handler;
    }
    function _dequeue2(handler) {
      const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
      if (index !== -1) {
        _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
      }
    }
    var internalRateLimitedQueue = Symbol("__queue");
    exports.internalRateLimitedQueue = internalRateLimitedQueue;
  }
});

// node_modules/@uppy/utils/lib/emitSocketProgress.js
var require_emitSocketProgress = __commonJS({
  "node_modules/@uppy/utils/lib/emitSocketProgress.js"(exports, module) {
    "use strict";
    var throttle = require_lodash2();
    function emitSocketProgress(uploader, progressData, file) {
      const {
        progress,
        bytesUploaded,
        bytesTotal
      } = progressData;
      if (progress) {
        uploader.uppy.log(`Upload progress: ${progress}`);
        uploader.uppy.emit("upload-progress", file, {
          uploader,
          bytesUploaded,
          bytesTotal
        });
      }
    }
    module.exports = throttle(emitSocketProgress, 300, {
      leading: true,
      trailing: true
    });
  }
});

// node_modules/@uppy/utils/lib/getSocketHost.js
var require_getSocketHost = __commonJS({
  "node_modules/@uppy/utils/lib/getSocketHost.js"(exports, module) {
    "use strict";
    function getSocketHost(url2) {
      const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
      const host = regex.exec(url2)[1];
      const socketProtocol = /^http:\/\//i.test(url2) ? "ws" : "wss";
      return `${socketProtocol}://${host}`;
    }
    module.exports = getSocketHost;
  }
});

// node_modules/@uppy/utils/lib/settle.js
var require_settle = __commonJS({
  "node_modules/@uppy/utils/lib/settle.js"(exports, module) {
    "use strict";
    function settle(promises) {
      const resolutions = [];
      const rejections = [];
      function resolved(value) {
        resolutions.push(value);
      }
      function rejected(error) {
        rejections.push(error);
      }
      const wait = Promise.all(promises.map((promise) => promise.then(resolved, rejected)));
      return wait.then(() => {
        return {
          successful: resolutions,
          failed: rejections
        };
      });
    }
    module.exports = settle;
  }
});

// node_modules/@uppy/utils/lib/EventTracker.js
var require_EventTracker = __commonJS({
  "node_modules/@uppy/utils/lib/EventTracker.js"(exports, module) {
    "use strict";
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var _emitter = /* @__PURE__ */ _classPrivateFieldLooseKey("emitter");
    var _events = /* @__PURE__ */ _classPrivateFieldLooseKey("events");
    var EventTracker = class {
      constructor(emitter) {
        Object.defineProperty(this, _emitter, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _events, {
          writable: true,
          value: []
        });
        _classPrivateFieldLooseBase(this, _emitter)[_emitter] = emitter;
      }
      on(event2, fn) {
        _classPrivateFieldLooseBase(this, _events)[_events].push([event2, fn]);
        return _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event2, fn);
      }
      remove() {
        for (const [event2, fn] of _classPrivateFieldLooseBase(this, _events)[_events].splice(0)) {
          _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event2, fn);
        }
      }
    };
    module.exports = EventTracker;
  }
});

// node_modules/@uppy/utils/lib/ProgressTimeout.js
var require_ProgressTimeout = __commonJS({
  "node_modules/@uppy/utils/lib/ProgressTimeout.js"(exports, module) {
    "use strict";
    function _classPrivateFieldLooseBase(receiver, privateKey) {
      if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
      }
      return receiver;
    }
    var id = 0;
    function _classPrivateFieldLooseKey(name) {
      return "__private_" + id++ + "_" + name;
    }
    var _aliveTimer = /* @__PURE__ */ _classPrivateFieldLooseKey("aliveTimer");
    var _isDone = /* @__PURE__ */ _classPrivateFieldLooseKey("isDone");
    var _onTimedOut = /* @__PURE__ */ _classPrivateFieldLooseKey("onTimedOut");
    var _timeout = /* @__PURE__ */ _classPrivateFieldLooseKey("timeout");
    var ProgressTimeout = class {
      constructor(timeout, timeoutHandler) {
        Object.defineProperty(this, _aliveTimer, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _isDone, {
          writable: true,
          value: false
        });
        Object.defineProperty(this, _onTimedOut, {
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _timeout, {
          writable: true,
          value: void 0
        });
        _classPrivateFieldLooseBase(this, _timeout)[_timeout] = timeout;
        _classPrivateFieldLooseBase(this, _onTimedOut)[_onTimedOut] = timeoutHandler;
      }
      progress() {
        if (_classPrivateFieldLooseBase(this, _isDone)[_isDone])
          return;
        if (_classPrivateFieldLooseBase(this, _timeout)[_timeout] > 0) {
          clearTimeout(_classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer]);
          _classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase(this, _timeout)[_timeout]);
        }
      }
      done() {
        if (!_classPrivateFieldLooseBase(this, _isDone)[_isDone]) {
          clearTimeout(_classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer]);
          _classPrivateFieldLooseBase(this, _aliveTimer)[_aliveTimer] = null;
          _classPrivateFieldLooseBase(this, _isDone)[_isDone] = true;
        }
      }
    };
    module.exports = ProgressTimeout;
  }
});

// node_modules/@uppy/utils/lib/isNetworkError.js
var require_isNetworkError = __commonJS({
  "node_modules/@uppy/utils/lib/isNetworkError.js"(exports, module) {
    "use strict";
    function isNetworkError(xhr) {
      if (!xhr) {
        return false;
      }
      return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
    }
    module.exports = isNetworkError;
  }
});

// node_modules/@uppy/xhr-upload/lib/locale.js
var require_locale5 = __commonJS({
  "node_modules/@uppy/xhr-upload/lib/locale.js"(exports, module) {
    "use strict";
    module.exports = {
      strings: {
        timedOut: "Upload stalled for %{seconds} seconds, aborting."
      }
    };
  }
});

// node_modules/@uppy/xhr-upload/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@uppy/xhr-upload/lib/index.js"(exports, module) {
    "use strict";
    var _nonSecure = require_non_secure();
    var _companionClient = require_lib7();
    var _RateLimitedQueue = require_RateLimitedQueue();
    var BasePlugin2 = require_BasePlugin();
    var emitSocketProgress = require_emitSocketProgress();
    var getSocketHost = require_getSocketHost();
    var settle = require_settle();
    var EventTracker = require_EventTracker();
    var ProgressTimeout = require_ProgressTimeout();
    var NetworkError = require_NetworkError();
    var isNetworkError = require_isNetworkError();
    var packageJson = {
      "version": "2.1.3"
    };
    var locale = require_locale5();
    function buildResponseError(xhr, err) {
      let error = err;
      if (!error)
        error = new Error("Upload error");
      if (typeof error === "string")
        error = new Error(error);
      if (!(error instanceof Error)) {
        error = Object.assign(new Error("Upload error"), {
          data: error
        });
      }
      if (isNetworkError(xhr)) {
        error = new NetworkError(error, xhr);
        return error;
      }
      error.request = xhr;
      return error;
    }
    function setTypeInBlob(file) {
      const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
      return dataWithUpdatedType;
    }
    var XHRUpload2 = class extends BasePlugin2 {
      constructor(uppy2, opts) {
        super(uppy2, opts);
        this.type = "uploader";
        this.id = this.opts.id || "XHRUpload";
        this.title = "XHRUpload";
        this.defaultLocale = locale;
        const defaultOptions = {
          formData: true,
          fieldName: opts.bundle ? "files[]" : "file",
          method: "post",
          metaFields: null,
          responseUrlFieldName: "url",
          bundle: false,
          headers: {},
          timeout: 30 * 1e3,
          limit: 5,
          withCredentials: false,
          responseType: "",
          getResponseData(responseText) {
            let parsedResponse = {};
            try {
              parsedResponse = JSON.parse(responseText);
            } catch (err) {
              uppy2.log(err);
            }
            return parsedResponse;
          },
          getResponseError(_5, response) {
            let error = new Error("Upload error");
            if (isNetworkError(response)) {
              error = new NetworkError(error, response);
            }
            return error;
          },
          validateStatus(status) {
            return status >= 200 && status < 300;
          }
        };
        this.opts = {
          ...defaultOptions,
          ...opts
        };
        this.i18nInit();
        this.handleUpload = this.handleUpload.bind(this);
        if (_RateLimitedQueue.internalRateLimitedQueue in this.opts) {
          this.requests = this.opts[_RateLimitedQueue.internalRateLimitedQueue];
        } else {
          this.requests = new _RateLimitedQueue.RateLimitedQueue(this.opts.limit);
        }
        if (this.opts.bundle && !this.opts.formData) {
          throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
        }
        this.uploaderEvents = /* @__PURE__ */ Object.create(null);
      }
      getOptions(file) {
        const overrides = this.uppy.getState().xhrUpload;
        const {
          headers
        } = this.opts;
        const opts = {
          ...this.opts,
          ...overrides || {},
          ...file.xhrUpload || {},
          headers: {}
        };
        if (typeof headers === "function") {
          opts.headers = headers(file);
        } else {
          Object.assign(opts.headers, this.opts.headers);
        }
        if (overrides) {
          Object.assign(opts.headers, overrides.headers);
        }
        if (file.xhrUpload) {
          Object.assign(opts.headers, file.xhrUpload.headers);
        }
        return opts;
      }
      addMetadata(formData, meta, opts) {
        const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields : Object.keys(meta);
        metaFields.forEach((item) => {
          formData.append(item, meta[item]);
        });
      }
      createFormDataUpload(file, opts) {
        const formPost = new FormData();
        this.addMetadata(formPost, file.meta, opts);
        const dataWithUpdatedType = setTypeInBlob(file);
        if (file.name) {
          formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
        } else {
          formPost.append(opts.fieldName, dataWithUpdatedType);
        }
        return formPost;
      }
      createBundledUpload(files, opts) {
        const formPost = new FormData();
        const {
          meta
        } = this.uppy.getState();
        this.addMetadata(formPost, meta, opts);
        files.forEach((file) => {
          const options = this.getOptions(file);
          const dataWithUpdatedType = setTypeInBlob(file);
          if (file.name) {
            formPost.append(options.fieldName, dataWithUpdatedType, file.name);
          } else {
            formPost.append(options.fieldName, dataWithUpdatedType);
          }
        });
        return formPost;
      }
      upload(file, current, total) {
        const opts = this.getOptions(file);
        this.uppy.log(`uploading ${current} of ${total}`);
        return new Promise((resolve, reject) => {
          this.uppy.emit("upload-started", file);
          const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
          const xhr = new XMLHttpRequest();
          this.uploaderEvents[file.id] = new EventTracker(this.uppy);
          let queuedRequest;
          const timer = new ProgressTimeout(opts.timeout, () => {
            xhr.abort();
            queuedRequest.done();
            const error = new Error(this.i18n("timedOut", {
              seconds: Math.ceil(opts.timeout / 1e3)
            }));
            this.uppy.emit("upload-error", file, error);
            reject(error);
          });
          const id = (0, _nonSecure.nanoid)();
          xhr.upload.addEventListener("loadstart", () => {
            this.uppy.log(`[XHRUpload] ${id} started`);
          });
          xhr.upload.addEventListener("progress", (ev) => {
            this.uppy.log(`[XHRUpload] ${id} progress: ${ev.loaded} / ${ev.total}`);
            timer.progress();
            if (ev.lengthComputable) {
              this.uppy.emit("upload-progress", file, {
                uploader: this,
                bytesUploaded: ev.loaded,
                bytesTotal: ev.total
              });
            }
          });
          xhr.addEventListener("load", () => {
            this.uppy.log(`[XHRUpload] ${id} finished`);
            timer.done();
            queuedRequest.done();
            if (this.uploaderEvents[file.id]) {
              this.uploaderEvents[file.id].remove();
              this.uploaderEvents[file.id] = null;
            }
            if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {
              const body2 = opts.getResponseData(xhr.responseText, xhr);
              const uploadURL = body2[opts.responseUrlFieldName];
              const uploadResp = {
                status: xhr.status,
                body: body2,
                uploadURL
              };
              this.uppy.emit("upload-success", file, uploadResp);
              if (uploadURL) {
                this.uppy.log(`Download ${file.name} from ${uploadURL}`);
              }
              return resolve(file);
            }
            const body = opts.getResponseData(xhr.responseText, xhr);
            const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
            const response = {
              status: xhr.status,
              body
            };
            this.uppy.emit("upload-error", file, error, response);
            return reject(error);
          });
          xhr.addEventListener("error", () => {
            this.uppy.log(`[XHRUpload] ${id} errored`);
            timer.done();
            queuedRequest.done();
            if (this.uploaderEvents[file.id]) {
              this.uploaderEvents[file.id].remove();
              this.uploaderEvents[file.id] = null;
            }
            const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
            this.uppy.emit("upload-error", file, error);
            return reject(error);
          });
          xhr.open(opts.method.toUpperCase(), opts.endpoint, true);
          xhr.withCredentials = opts.withCredentials;
          if (opts.responseType !== "") {
            xhr.responseType = opts.responseType;
          }
          queuedRequest = this.requests.run(() => {
            this.uppy.emit("upload-started", file);
            const currentOpts = this.getOptions(file);
            Object.keys(currentOpts.headers).forEach((header) => {
              xhr.setRequestHeader(header, currentOpts.headers[header]);
            });
            xhr.send(data);
            return () => {
              timer.done();
              xhr.abort();
            };
          });
          this.onFileRemove(file.id, () => {
            queuedRequest.abort();
            reject(new Error("File removed"));
          });
          this.onCancelAll(file.id, (_ref) => {
            let {
              reason
            } = _ref;
            if (reason === "user") {
              queuedRequest.abort();
            }
            reject(new Error("Upload cancelled"));
          });
        });
      }
      uploadRemote(file) {
        const opts = this.getOptions(file);
        return new Promise((resolve, reject) => {
          this.uppy.emit("upload-started", file);
          const fields = {};
          const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields : Object.keys(file.meta);
          metaFields.forEach((name) => {
            fields[name] = file.meta[name];
          });
          const Client = file.remote.providerOptions.provider ? _companionClient.Provider : _companionClient.RequestClient;
          const client = new Client(this.uppy, file.remote.providerOptions);
          client.post(file.remote.url, {
            ...file.remote.body,
            endpoint: opts.endpoint,
            size: file.data.size,
            fieldname: opts.fieldName,
            metadata: fields,
            httpMethod: opts.method,
            useFormData: opts.formData,
            headers: opts.headers
          }).then((res) => {
            const {
              token
            } = res;
            const host = getSocketHost(file.remote.companionUrl);
            const socket = new _companionClient.Socket({
              target: `${host}/api/${token}`,
              autoOpen: false
            });
            this.uploaderEvents[file.id] = new EventTracker(this.uppy);
            let queuedRequest;
            this.onFileRemove(file.id, () => {
              socket.send("cancel", {});
              queuedRequest.abort();
              resolve(`upload ${file.id} was removed`);
            });
            this.onCancelAll(file.id, function(_temp) {
              let {
                reason
              } = _temp === void 0 ? {} : _temp;
              if (reason === "user") {
                socket.send("cancel", {});
                queuedRequest.abort();
              }
              resolve(`upload ${file.id} was canceled`);
            });
            this.onRetry(file.id, () => {
              socket.send("pause", {});
              socket.send("resume", {});
            });
            this.onRetryAll(file.id, () => {
              socket.send("pause", {});
              socket.send("resume", {});
            });
            socket.on("progress", (progressData) => emitSocketProgress(this, progressData, file));
            socket.on("success", (data) => {
              const body = opts.getResponseData(data.response.responseText, data.response);
              const uploadURL = body[opts.responseUrlFieldName];
              const uploadResp = {
                status: data.response.status,
                body,
                uploadURL
              };
              this.uppy.emit("upload-success", file, uploadResp);
              queuedRequest.done();
              if (this.uploaderEvents[file.id]) {
                this.uploaderEvents[file.id].remove();
                this.uploaderEvents[file.id] = null;
              }
              return resolve();
            });
            socket.on("error", (errData) => {
              const resp = errData.response;
              const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {
                cause: errData.error
              });
              this.uppy.emit("upload-error", file, error);
              queuedRequest.done();
              if (this.uploaderEvents[file.id]) {
                this.uploaderEvents[file.id].remove();
                this.uploaderEvents[file.id] = null;
              }
              reject(error);
            });
            queuedRequest = this.requests.run(() => {
              socket.open();
              if (file.isPaused) {
                socket.send("pause", {});
              }
              return () => socket.close();
            });
          }).catch((err) => {
            this.uppy.emit("upload-error", file, err);
            reject(err);
          });
        });
      }
      uploadBundle(files) {
        return new Promise((resolve, reject) => {
          const {
            endpoint
          } = this.opts;
          const {
            method
          } = this.opts;
          const optsFromState = this.uppy.getState().xhrUpload;
          const formData = this.createBundledUpload(files, {
            ...this.opts,
            ...optsFromState || {}
          });
          const xhr = new XMLHttpRequest();
          const emitError = (error) => {
            files.forEach((file) => {
              this.uppy.emit("upload-error", file, error);
            });
          };
          const timer = new ProgressTimeout(this.opts.timeout, () => {
            xhr.abort();
            const error = new Error(this.i18n("timedOut", {
              seconds: Math.ceil(this.opts.timeout / 1e3)
            }));
            emitError(error);
            reject(error);
          });
          xhr.upload.addEventListener("loadstart", () => {
            this.uppy.log("[XHRUpload] started uploading bundle");
            timer.progress();
          });
          xhr.upload.addEventListener("progress", (ev) => {
            timer.progress();
            if (!ev.lengthComputable)
              return;
            files.forEach((file) => {
              this.uppy.emit("upload-progress", file, {
                uploader: this,
                bytesUploaded: ev.loaded / ev.total * file.size,
                bytesTotal: file.size
              });
            });
          });
          xhr.addEventListener("load", (ev) => {
            timer.done();
            if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
              const body = this.opts.getResponseData(xhr.responseText, xhr);
              const uploadResp = {
                status: ev.target.status,
                body
              };
              files.forEach((file) => {
                this.uppy.emit("upload-success", file, uploadResp);
              });
              return resolve();
            }
            const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
            error.request = xhr;
            emitError(error);
            return reject(error);
          });
          xhr.addEventListener("error", () => {
            timer.done();
            const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
            emitError(error);
            return reject(error);
          });
          this.uppy.on("cancel-all", function(_temp2) {
            let {
              reason
            } = _temp2 === void 0 ? {} : _temp2;
            if (reason !== "user")
              return;
            timer.done();
            xhr.abort();
          });
          xhr.open(method.toUpperCase(), endpoint, true);
          xhr.withCredentials = this.opts.withCredentials;
          if (this.opts.responseType !== "") {
            xhr.responseType = this.opts.responseType;
          }
          Object.keys(this.opts.headers).forEach((header) => {
            xhr.setRequestHeader(header, this.opts.headers[header]);
          });
          xhr.send(formData);
          files.forEach((file) => {
            this.uppy.emit("upload-started", file);
          });
        });
      }
      uploadFiles(files) {
        const promises = files.map((file, i2) => {
          const current = parseInt(i2, 10) + 1;
          const total = files.length;
          if (file.error) {
            return Promise.reject(new Error(file.error));
          }
          if (file.isRemote) {
            return this.uploadRemote(file, current, total);
          }
          return this.upload(file, current, total);
        });
        return settle(promises);
      }
      onFileRemove(fileID, cb) {
        this.uploaderEvents[fileID].on("file-removed", (file) => {
          if (fileID === file.id)
            cb(file.id);
        });
      }
      onRetry(fileID, cb) {
        this.uploaderEvents[fileID].on("upload-retry", (targetFileID) => {
          if (fileID === targetFileID) {
            cb();
          }
        });
      }
      onRetryAll(fileID, cb) {
        this.uploaderEvents[fileID].on("retry-all", () => {
          if (!this.uppy.getFile(fileID))
            return;
          cb();
        });
      }
      onCancelAll(fileID, eventHandler) {
        var _this = this;
        this.uploaderEvents[fileID].on("cancel-all", function() {
          if (!_this.uppy.getFile(fileID))
            return;
          eventHandler(...arguments);
        });
      }
      handleUpload(fileIDs) {
        if (fileIDs.length === 0) {
          this.uppy.log("[XHRUpload] No files to upload!");
          return Promise.resolve();
        }
        if (this.opts.limit === 0 && !this.opts[_RateLimitedQueue.internalRateLimitedQueue]) {
          this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
        }
        this.uppy.log("[XHRUpload] Uploading...");
        const files = fileIDs.map((fileID) => this.uppy.getFile(fileID));
        if (this.opts.bundle) {
          const isSomeFileRemote = files.some((file) => file.isRemote);
          if (isSomeFileRemote) {
            throw new Error("Can\u2019t upload remote files when the `bundle: true` option is set");
          }
          if (typeof this.opts.headers === "function") {
            throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
          }
          return this.uploadBundle(files);
        }
        return this.uploadFiles(files).then(() => null);
      }
      install() {
        if (this.opts.bundle) {
          const {
            capabilities
          } = this.uppy.getState();
          this.uppy.setState({
            capabilities: {
              ...capabilities,
              individualCancellation: false
            }
          });
        }
        this.uppy.addUploader(this.handleUpload);
      }
      uninstall() {
        if (this.opts.bundle) {
          const {
            capabilities
          } = this.uppy.getState();
          this.uppy.setState({
            capabilities: {
              ...capabilities,
              individualCancellation: true
            }
          });
        }
        this.uppy.removeUploader(this.handleUpload);
      }
    };
    XHRUpload2.VERSION = packageJson.version;
    module.exports = XHRUpload2;
  }
});

// app/javascript/files/clip_board.js
var import_clipboard = __toESM(require_clipboard());
var import_handlebars3 = __toESM(require_handlebars());

// app/javascript/files/data_table.js
var import_handlebars = __toESM(require_handlebars());

// app/javascript/files/sweet_alert.js
var import_sweetalert2 = __toESM(require_sweetalert2_all());
var EVENTNAME2 = {
  showError: "showError",
  showInput: "showInput",
  showLoading: "showLoading",
  showPrompt: "showPrompt",
  closeSwal: "closeSwal"
};
var sweetAlert = null;
jQuery(function() {
  sweetAlert = new SweetAlert();
  $(CONTENTID).on(EVENTNAME2.showError, function(e2, options) {
    sweetAlert.alertError(options.title, options.message);
  });
  $(CONTENTID).on(EVENTNAME2.showPrompt, function(e2, options) {
    sweetAlert.alertError(options.title, options.message);
  });
  $(CONTENTID).on(EVENTNAME2.showInput, function(e2, options) {
    sweetAlert.input(options);
  });
  $(CONTENTID).on(EVENTNAME2.showLoading, function(e2, options) {
    sweetAlert.loading(options.message);
  });
  $(CONTENTID).on(EVENTNAME2.closeSwal, function() {
    sweetAlert.close();
  });
});
var SweetAlert = class {
  constructor() {
    this.setMixin();
  }
  input(options) {
    import_sweetalert2.default.fire(options.inputOptions).then(function(result) {
      if (result.isConfirmed) {
        const eventData = {
          result,
          files: options.files ? options.files : null
        };
        $(CONTENTID).trigger(options.action, eventData);
      } else {
        $(CONTENTID).trigger(EVENTNAME.reloadTable);
      }
    });
  }
  setMixin() {
    import_sweetalert2.default.mixIn = {
      showClass: {
        popup: "swal2-noanimation",
        backdrop: "swal2-noanimation"
      },
      hideClass: {
        popup: "",
        backdrop: ""
      }
    };
  }
  alertError(error_title, error_message) {
    import_sweetalert2.default.fire(error_title, error_message, "error");
  }
  async loading(title) {
    import_sweetalert2.default.fire({
      title,
      allowOutsideClick: false,
      showConfirmButton: false,
      willOpen: () => {
        import_sweetalert2.default.showLoading();
      }
    });
  }
  close() {
    import_sweetalert2.default.close();
  }
};

// app/javascript/files/globus.js
var globus_endpoints;
$(document).ready(function() {
  globus_endpoints = $("#globus_endpoints").data("globusEndpoints");
});
function getEndpointInfo(directory) {
  for (const endpoint of globus_endpoints) {
    if (directory.startsWith(endpoint["path"])) {
      return endpoint;
    }
  }
}
function getGlobusLink(directory) {
  let info = getEndpointInfo(directory);
  if (info) {
    let origin_path = directory.replace(info.path, info.endpoint_path);
    origin_path = origin_path.replace("//", "/");
    url = "https://app.globus.org/file-manager?origin_id=" + info.endpoint + "&origin_path=" + origin_path;
    return url;
  }
}
function updateGlobusLink(directory, link, wrapper) {
  let info = getEndpointInfo(directory);
  if (info) {
    link.removeClass("disabled");
    wrapper.prop("title", "Open the current directory with Globus");
  } else {
    link.addClass("disabled");
    wrapper.prop("title", "No Globus endpoint associated with this directory");
  }
}

// app/javascript/files/data_table.js
var EVENTNAME = {
  getJsonResponse: "getJsonResponse",
  reloadTable: "reloadTable",
  goto: "goto"
};
var CONTENTID = "#directory-contents";
var table = null;
jQuery(function() {
  table = new DataTable();
  window.onpopstate = function(event2) {
    table.goto(location.href);
  };
  $(CONTENTID).on(EVENTNAME.reloadTable, function(e2, options) {
    let url2 = $.isEmptyObject(options) ? "" : options.url;
    table.reloadTable(url2);
  });
  $(CONTENTID).on(EVENTNAME.getJsonResponse, function(e2, options) {
    table.dataFromJsonResponse(options.response);
  });
  $(CONTENTID).on(EVENTNAME.goto, function(e2, options) {
    table.goto(options.path);
  });
  $("#show-dotfiles").on("change", function() {
    table.setShowDotFiles(this.checked);
    table.updateDotFileVisibility();
  });
  $("#show-dotfiles").on("keypress", function(event2) {
    if (event2.which === 13) {
      this.checked = !this.checked;
      this.dispatchEvent(new Event("change"));
    }
  });
  $("#show-owner-mode").on("change", function() {
    table.setShowOwnerMode(this.checked);
    table.updateShowOwnerModeVisibility();
  });
  $("#show-owner-mode").on("keypress", function(event2) {
    if (event2.which === 13) {
      this.checked = !this.checked;
      this.dispatchEvent(new Event("change"));
    }
  });
  $("#select_all").on("click", function() {
    if ($(this).is(":checked")) {
      table.getTable().rows().select();
    } else {
      table.getTable().rows().deselect();
    }
  });
  table.getTable().on("draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt", function() {
    table.updateDatatablesStatus();
  });
  table.getTable().on("user-select", function(e2, dt, type, cell, originalEvent) {
    var selected_rows = dt.rows({ selected: true });
    if (originalEvent.target.closest(".actions-btn-group")) {
      e2.preventDefault();
    } else if (selected_rows.count() == 1 && cell.index().row == selected_rows.indexes()[0]) {
      e2.preventDefault();
    } else {
      cell.node().closest("tr").querySelector("input[type=checkbox]").focus();
    }
  });
  table.getTable().on("deselect", function(e2, dt, type, indexes) {
    dt.rows(indexes).nodes().toArray().forEach((e3) => $(e3).find("input[type=checkbox]").prop("checked", false));
  });
  table.getTable().on("select", function(e2, dt, type, indexes) {
    dt.rows(indexes).nodes().toArray().forEach((e3) => $(e3).find("input[type=checkbox]").prop("checked", true));
  });
  $("#directory-contents tbody").on("click", "tr td:first-child input[type=checkbox]", function() {
    if ($(this).is(":checked")) {
      table.getTable().row(this.closest("tr")).select();
    } else {
      table.getTable().row(this.closest("tr")).deselect();
    }
    this.focus();
  });
  $("#directory-contents tbody").on("keydown", "input, a", function(e2) {
    if (e2.key == "ArrowDown") {
      e2.preventDefault();
      let tr = $(this.closest("tr")).next("tr").get(0);
      if (tr) {
        tr.querySelector("input[type=checkbox]").focus();
        if (!e2.shiftKey) {
          table.getTable().rows().deselect();
        }
        table.getTable().row(tr).select();
      }
    } else if (e2.key == "ArrowUp") {
      e2.preventDefault();
      let tr = $(this.closest("tr")).prev("tr").get(0);
      if (tr) {
        tr.querySelector("input[type=checkbox]").focus();
        if (!e2.shiftKey) {
          table.getTable().rows().deselect();
        }
        table.getTable().row(tr).select();
      }
    }
  });
  $.fn.dataTable.ext.search.push(
    function(settings, data, dataIndex) {
      return table.getShowDotFiles() || !data[2].startsWith(".");
    }
  );
});
var DataTable = class {
  _table = null;
  constructor() {
    this.loadDataTable();
    this.reloadTable();
  }
  getTable() {
    return this._table;
  }
  loadDataTable() {
    this._table = $(CONTENTID).on("xhr.dt", function(e2, settings, json, xhr) {
      if (json && json.time) {
        history.replaceState(_.merge({}, history.state, { currentDirectoryUpdatedAt: json.time }), null);
      }
    }).DataTable({
      autoWidth: false,
      language: {
        search: "Filter:"
      },
      order: [[1, "asc"], [2, "asc"]],
      rowId: "id",
      paging: false,
      scrollCollapse: true,
      select: {
        style: "os",
        className: "selected",
        toggleable: true,
        selector: "td:not(:first-child)"
      },
      dom: "<'row'<'col-sm-12'f>><'row'<'col-sm-12'<'dt-status-bar'<'datatables-status float-end'><'transfers-status'>>>><'row'<'col-sm-12'tr>>",
      columns: [
        {
          data: null,
          orderable: false,
          defaultContent: '<input type="checkbox">'
        },
        { data: "type", render: (data, type, row, meta) => data == "d" ? '<span title="directory" class="fa fa-folder" style="color: gold"><span class="sr-only"> dir</span></span>' : '<span title="file" class="fa fa-file" style="color: lightgrey"><span class="sr-only"> file</span></span>' },
        { name: "name", data: "name", className: "text-break", render: (data, type, row, meta) => `<a class="${row.type} name ${row.type == "d" ? "" : "view-file"}" href="${row.url}">${import_handlebars.default.escapeExpression(data)}</a>` },
        { name: "actions", orderable: false, searchable: false, data: null, render: (data, type, row, meta) => this.actionsBtnTemplate({ row_index: meta.row, file: row.type != "d", data: row }) },
        {
          data: "size",
          render: (data, type, row, meta) => {
            return type == "display" ? row.human_size : data;
          }
        },
        {
          data: "modified_at",
          render: (data, type, row, meta) => {
            if (type == "display") {
              let date = new Date(data * 1e3);
              return isNaN(data) ? "Invalid Date" : `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
            } else {
              return data;
            }
          }
        },
        { name: "owner", data: "owner", visible: this.getShowOwnerMode() },
        {
          name: "mode",
          data: "mode",
          visible: this.getShowOwnerMode(),
          render: (data, type, row, meta) => {
            let mode = data.toString(8);
            let chmodDisplay = mode.substring(mode.length - 3);
            return chmodDisplay;
          }
        }
      ]
    });
    $("#directory-contents_filter").prepend(`<label style="margin-right: 20px" for="show-dotfiles"><input type="checkbox" id="show-dotfiles" ${this.getShowDotFiles() ? "checked" : ""}> Show Dotfiles</label>`);
    $("#directory-contents_filter").prepend(`<label style="margin-right: 14px" for="show-owner-mode"><input type="checkbox" id="show-owner-mode" ${this.getShowOwnerMode() ? "checked" : ""}> Show Owner/Mode</label>`);
    this.updateGlobus();
  }
  async reloadTable(url2) {
    var request_url = url2 || history.state.currentDirectoryUrl;
    try {
      const response = await fetch(request_url, { headers: { "Accept": "application/json" }, cache: "no-store" });
      const data = await this.dataFromJsonResponse(response);
      history.state.currentFilenames = Array.from(data.files, (x2) => x2.name);
      $("#shell-wrapper").replaceWith(data.shell_dropdown_html);
      this._table.clear();
      this._table.rows.add(data.files);
      this._table.draw();
      $("#open-in-terminal-btn").attr("href", data.shell_url);
      $("#open-in-terminal-btn").removeClass("disabled");
      if ($("#select_all").is(":checked")) {
        $("#select_all").click();
      }
      let result = await Promise.resolve(data);
      $("td input[type=checkbox]").on("keypress", function(event2) {
        if (event2.which === 13) {
          this.checked = !this.checked;
          this.dispatchEvent(new Event("change"));
          if (this.checked) {
            table.getTable().row(this.closest("tr")).select();
          } else {
            table.getTable().row(this.closest("tr")).deselect();
          }
        }
      });
      return result;
    } catch (e2) {
      const eventData = {
        "title": `Error occurred when attempting to access ${request_url}`,
        "message": e2.message
      };
      $(CONTENTID).trigger(EVENTNAME2.showError, eventData);
      $("#open-in-terminal-btn").addClass("disabled");
    }
  }
  updateDotFileVisibility() {
    this.reloadTable();
  }
  updateGlobus() {
    if ($("#globus-link").length) {
      $("#globus-link").attr("href", getGlobusLink(history.state.currentDirectory));
      updateGlobusLink(history.state.currentDirectory, $("#globus-link"), $("#globus-wrapper"));
    }
  }
  updateShowOwnerModeVisibility() {
    let visible = this.getShowOwnerMode();
    this._table.column("owner:name").visible(visible);
    this._table.column("mode:name").visible(visible);
  }
  setShowOwnerMode(visible) {
    localStorage.setItem("show-owner-mode", new Boolean(visible));
  }
  setShowDotFiles(visible) {
    localStorage.setItem("show-dotfiles", new Boolean(visible));
  }
  getShowDotFiles() {
    return localStorage.getItem("show-dotfiles") == "true";
  }
  getShowOwnerMode() {
    return localStorage.getItem("show-owner-mode") == "true";
  }
  dataFromJsonResponse(response) {
    return new Promise((resolve, reject) => {
      Promise.resolve(response).then((response2) => response2.ok ? Promise.resolve(response2) : Promise.reject(new Error(response2.statusText))).then((response2) => response2.json()).then((data) => data.error_message ? Promise.reject(new Error(data.error_message)) : resolve(data)).catch((e2) => reject(e2));
    });
  }
  actionsBtnTemplate(options) {
    let template_str = $("#actions-btn-template").html();
    let compiled = import_handlebars.default.compile(template_str);
    let results = compiled(options);
    return results;
  }
  updateDatatablesStatus() {
    let api = this._table;
    let rows = api.rows({ selected: true }).flatten().length, page_info = api.page.info(), msg = page_info.recordsTotal == page_info.recordsDisplay ? `Showing ${page_info.recordsDisplay} rows` : `Showing ${page_info.recordsDisplay} of ${page_info.recordsTotal} rows`;
    $(".datatables-status").html(`${msg} - ${rows} rows selected`);
  }
  goto(url2, pushState = true, show_processing_indicator = true) {
    if (url2 == history.state.currentDirectoryUrl)
      pushState = false;
    this.reloadTable(url2).then((data) => {
      if (data) {
        $("#path-breadcrumbs").html(data.breadcrumbs_html);
        if (pushState) {
          this._table.search("").draw();
          history.pushState({
            currentDirectory: data.path,
            currentDirectoryUrl: data.url,
            currentFilesPath: data.files_path,
            currentFilesUploadPath: data.files_upload_path,
            currentFilesystem: data.filesystem,
            currentFilenames: Array.from(data.files, (x2) => x2.name)
          }, data.name, data.url);
        }
        this.updateGlobus();
      }
    }).finally(() => {
    });
  }
};

// app/javascript/files/file_ops.js
var import_handlebars2 = __toESM(require_handlebars());
var import_lodash = __toESM(require_lodash());

// app/javascript/config.js
"use strict;";
var CONFIG_ID = "ood_config";
function configData() {
  return document.getElementById(CONFIG_ID).dataset;
}
function maxFileSize() {
  const cfgData = configData();
  if (cfgData["maxFileSize"].length == 0) {
    return parseInt(1073742e4, 10);
  } else {
    const maxFileSize2 = cfgData["maxFileSize"];
    return parseInt(maxFileSize2, 10);
  }
}
function transfersPath() {
  const cfgData = configData();
  const transfersPath2 = cfgData["transfersPath"];
  return transfersPath2;
}
function csrfToken() {
  const csrf_token = document.querySelector('meta[name="csrf-token"]').content;
  return csrf_token;
}
function uppyLocale() {
  const cfgData = configData();
  return JSON.parse(cfgData["uppyLocale"]);
}

// app/javascript/files/file_ops.js
var EVENTNAME4 = {
  changeDirectory: "changeDirectory",
  changeDirectoryPrompt: "changeDirectoryPrompt",
  copyFile: "copyFile",
  createFile: "createFile",
  createDirectory: "createDirectory",
  deleteFile: "deleteFile",
  deletePrompt: "deletePrompt",
  download: "download",
  moveFile: "moveFile",
  newFile: "newFile",
  newFilePrompt: "newFilePrompt",
  newDirectoryPrompt: "newDirectoryPrompt",
  newDirectory: "newDirectory",
  renameFile: "renameFile",
  renameFilePrompt: "renameFilePrompt"
};
var fileOps = null;
jQuery(function() {
  fileOps = new FileOps();
  $("#directory-contents tbody, #path-breadcrumbs, #favorites").on("click", "a.d", function(event2) {
    if (fileOps.clickEventIsSignificant(event2)) {
      event2.preventDefault();
      event2.cancelBubble = true;
      if (event2.stopPropagation)
        event2.stopPropagation();
      const eventData = {
        "path": this.getAttribute("href")
      };
      $(CONTENTID).trigger(EVENTNAME.goto, eventData);
    }
  });
  $("#directory-contents tbody").on("dblclick", "tr td:not(:first-child)", function() {
    let a2 = this.parentElement.querySelector("a");
    if (a2.classList.contains("d")) {
      const eventData = {
        "path": a2.getAttribute("href")
      };
      $(CONTENTID).trigger(EVENTNAME.goto, eventData);
    }
  });
  $("#directory-contents tbody").on("click", ".download-file", function(e2) {
    e2.preventDefault();
    const table2 = $(CONTENTID).DataTable();
    const row = e2.currentTarget.dataset.rowIndex;
    const eventData = {
      selection: table2.rows(row).data()
    };
    $(CONTENTID).trigger(EVENTNAME4.download, eventData);
  });
  $("#refresh-btn").on("click", function() {
    $(CONTENTID).trigger(EVENTNAME.reloadTable);
  });
  $("#new-file-btn").on("click", function() {
    $(CONTENTID).trigger(EVENTNAME4.newFilePrompt);
  });
  $("#new-dir-btn").on("click", function() {
    $(CONTENTID).trigger(EVENTNAME4.newDirectoryPrompt);
  });
  $("#download-btn").on("click", function() {
    let table2 = $(CONTENTID).DataTable();
    let selection = table2.rows({ selected: true }).data();
    const eventData = {
      selection
    };
    $(CONTENTID).trigger(EVENTNAME4.download, eventData);
  });
  $("#delete-btn").on("click", function() {
    let table2 = $(CONTENTID).DataTable();
    let files = table2.rows({ selected: true }).data().toArray().map((f2) => f2.name);
    const eventData = {
      files
    };
    $(CONTENTID).trigger(EVENTNAME4.deletePrompt, eventData);
  });
  $(document).on("click", "#goto-btn", function() {
    $(CONTENTID).trigger(EVENTNAME4.changeDirectoryPrompt);
  });
  $(document).on("click", ".rename-file", function(e2) {
    e2.preventDefault();
    let table2 = $(CONTENTID).DataTable();
    let rowId = e2.currentTarget.dataset.rowIndex;
    let row = table2.row(rowId).data();
    let fileName = $($.parseHTML(row.name)).text();
    const eventData = {
      file: fileName
    };
    $(CONTENTID).trigger(EVENTNAME4.renameFilePrompt, eventData);
  });
  $(document).on("click", ".delete-file", function(e2) {
    e2.preventDefault();
    let table2 = $(CONTENTID).DataTable();
    let rowId = e2.currentTarget.dataset.rowIndex;
    let row = table2.row(rowId).data();
    let fileName = $($.parseHTML(row.name)).text();
    const eventData = {
      files: [fileName]
    };
    $(CONTENTID).trigger(EVENTNAME4.deletePrompt, eventData);
  });
  $(CONTENTID).on(EVENTNAME4.newFilePrompt, function() {
    fileOps.newFilePrompt();
  });
  $(CONTENTID).on(EVENTNAME4.newDirectoryPrompt, function() {
    fileOps.newDirectoryPrompt();
  });
  $(CONTENTID).on(EVENTNAME4.renameFilePrompt, function(e2, options) {
    fileOps.renameFilePrompt(options.file);
  });
  $(CONTENTID).on(EVENTNAME4.renameFile, function(e2, options) {
    fileOps.renameFile(options.files, options.result.value);
  });
  $(CONTENTID).on(EVENTNAME4.createFile, function(e2, options) {
    fileOps.newFile(options.result.value);
  });
  $(CONTENTID).on(EVENTNAME4.createDirectory, function(e2, options) {
    fileOps.newDirectory(options.result.value);
  });
  $(CONTENTID).on(EVENTNAME4.download, function(e2, options) {
    if (options.selection.length == 0) {
      const eventData = {
        "title": "Select a file, files, or directory to download",
        "message": "You have selected none."
      };
      $(CONTENTID).trigger(EVENTNAME2.showError, eventData);
    } else {
      fileOps.download(options.selection);
    }
  });
  $(CONTENTID).on(EVENTNAME4.deletePrompt, function(e2, options) {
    if (options.files.length == 0) {
      const eventData = {
        "title": "Select a file, files, or directory to delete.",
        "message": "You have selected none."
      };
      $(CONTENTID).trigger(EVENTNAME2.showError, eventData);
    } else {
      fileOps.deletePrompt(options.files);
    }
  });
  $(CONTENTID).on(EVENTNAME4.deleteFile, function(e2, options) {
    fileOps.delete(options.files, options.from_fs);
  });
  $(CONTENTID).on(EVENTNAME4.moveFile, function(e2, options) {
    fileOps.move(options.files, options.token, options.from_fs, options.to_fs);
  });
  $(CONTENTID).on(EVENTNAME4.copyFile, function(e2, options) {
    fileOps.copy(options.files, options.token, options.from_fs, options.to_fs);
  });
  $(CONTENTID).on(EVENTNAME4.changeDirectoryPrompt, function() {
    fileOps.changeDirectoryPrompt();
  });
  $(CONTENTID).on(EVENTNAME4.changeDirectory, function(e2, options) {
    fileOps.changeDirectory(options.result.value);
  });
});
var FileOps = class {
  _timeout = 2e3;
  _failures = 0;
  _filesPath = history.state.currentFilesPath;
  constructor() {
  }
  clickEventIsSignificant(event2) {
    return !(event2.defaultPrevented || event2.which > 1 || event2.altKey || event2.ctrlKey || event2.metaKey || event2.shiftKey);
  }
  changeDirectory(path) {
    const eventData = {
      "path": history.state.currentFilesPath + path
    };
    $(CONTENTID).trigger(EVENTNAME.goto, eventData);
  }
  changeDirectoryPrompt() {
    const eventData = {
      action: "changeDirectory",
      "inputOptions": {
        title: "Change Directory",
        input: "text",
        inputLabel: "Path",
        inputValue: history.state.currentDirectory,
        inputAttributes: {
          spellcheck: "false"
        },
        showCancelButton: true,
        inputValidator: (value) => {
          if (!value || !value.startsWith("/")) {
            return "Provide an absolute pathname";
          }
        }
      }
    };
    $(CONTENTID).trigger(EVENTNAME2.showInput, eventData);
  }
  deletePrompt(files) {
    const eventData = {
      action: EVENTNAME4.deleteFile,
      files,
      "inputOptions": {
        title: files.length == 1 ? `Delete ${files[0]}?` : `Delete ${files.length} selected files?`,
        text: "Are you sure you want to delete the files: " + files.join(", "),
        showCancelButton: true
      }
    };
    $(CONTENTID).trigger(EVENTNAME2.showInput, eventData);
  }
  removeFiles(files) {
    this.transferFiles(files, "rm", "remove files", history.state.currentFilesystem);
  }
  renameFile(fileName, newFileName) {
    let files = {};
    files[`${history.state.currentDirectory}/${fileName}`] = `${history.state.currentDirectory}/${newFileName}`;
    this.transferFiles(files, "mv", "rename file", history.state.currentFilesystem, history.state.currentFilesystem);
  }
  renameFilePrompt(fileName) {
    const eventData = {
      action: EVENTNAME4.renameFile,
      files: fileName,
      "inputOptions": {
        title: "Rename",
        input: "text",
        inputLabel: "Filename",
        inputValue: fileName,
        inputAttributes: {
          spellcheck: "false"
        },
        showCancelButton: true,
        inputValidator: (value) => {
          if (!value) {
            return "Provide a filename to rename this to";
          } else if (value.includes("/") || value.includes("..")) {
            return "Filename cannot include / or ..";
          }
        }
      }
    };
    $(CONTENTID).trigger(EVENTNAME2.showInput, eventData);
  }
  newFilePrompt() {
    const eventData = {
      action: EVENTNAME4.createFile,
      "inputOptions": {
        title: "New File",
        input: "text",
        inputLabel: "Filename",
        showCancelButton: true,
        inputValidator: (value) => {
          if (!value) {
            return "Provide a non-empty filename.";
          } else if (value.includes("/")) {
            return "Illegal character (/) not allowed in filename.";
          }
        }
      }
    };
    $(CONTENTID).trigger(EVENTNAME2.showInput, eventData);
  }
  newFile(filename) {
    let myFileOp = new FileOps();
    fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?touch=true`, { method: "put", headers: { "X-CSRF-Token": csrfToken() } }).then((response) => this.dataFromJsonResponse(response)).then(function() {
      myFileOp.reloadTable();
    }).catch(function(e2) {
      myFileOp.alertError("Error occurred when attempting to create new file", e2.message);
    });
  }
  newDirectoryPrompt() {
    const eventData = {
      action: EVENTNAME4.createDirectory,
      "inputOptions": {
        title: "New Directory",
        input: "text",
        inputLabel: "Directory name",
        showCancelButton: true,
        inputValidator: (value) => {
          if (!value || value.includes("/")) {
            return "Provide a directory name that does not have / in it";
          }
        }
      }
    };
    $(CONTENTID).trigger(EVENTNAME2.showInput, eventData);
  }
  newDirectory(filename) {
    let myFileOp = new FileOps();
    fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?dir=true`, { method: "put", headers: { "X-CSRF-Token": csrfToken() } }).then((response) => this.dataFromJsonResponse(response)).then(function() {
      myFileOp.reloadTable();
    }).catch(function(e2) {
      myFileOp.alertError("Error occurred when attempting to create new directory", e2.message);
    });
  }
  download(selection) {
    selection.toArray().forEach((f2) => {
      if (f2.type == "d") {
        this.downloadDirectory(f2);
      } else if (f2.type == "f") {
        this.downloadFile(f2);
      }
    });
  }
  downloadDirectory(file) {
    let filename = $($.parseHTML(file.name)).text(), canDownloadReq = `${history.state.currentDirectoryUrl}/${encodeURI(filename)}?can_download=${Date.now().toString()}`;
    this.showSwalLoading("preparing to download directory: " + file.name);
    fetch(canDownloadReq, {
      method: "GET",
      headers: {
        "X-CSRF-Token": csrfToken(),
        "Accept": "application/json"
      }
    }).then((response) => this.dataFromJsonResponse(response)).then((data) => {
      if (data.can_download) {
        this.doneLoading();
        this.downloadFile(file);
      } else {
        this.doneLoading();
        this.alertError("Error while downloading", data.error_message);
      }
    }).catch((e2) => {
      this.doneLoading();
      this.alertError("Error while downloading", e2.message);
    });
  }
  downloadFile(file) {
    let filename = $($.parseHTML(file.name)).text(), downloadUrl = `${history.state.currentDirectoryUrl}/${encodeURI(filename)}?download=${Date.now().toString()}`, iframe = document.createElement("iframe"), TIME = 30 * 1e3;
    iframe.setAttribute("class", "d-none");
    iframe.setAttribute("src", downloadUrl);
    document.body.appendChild(iframe);
    setTimeout(function() {
      document.body.removeChild(iframe);
    }, TIME);
  }
  dataFromJsonResponse(response) {
    return new Promise((resolve, reject) => {
      Promise.resolve(response).then((response2) => response2.ok ? Promise.resolve(response2) : Promise.reject(new Error(response2.statusText))).then((response2) => response2.json()).then((data) => data.error_message ? Promise.reject(new Error(data.error_message)) : resolve(data)).catch((e2) => reject(e2));
    });
  }
  delete(files) {
    this.showSwalLoading("Deleting files...: ");
    this.removeFiles(files.map((f2) => [history.state.currentDirectory, f2].join("/")), csrfToken());
  }
  transferFiles(files, action, summary, from_fs, to_fs) {
    this._failures = 0;
    this.showSwalLoading(import_lodash.default.startCase(summary));
    return fetch(transfersPath(), {
      method: "post",
      body: JSON.stringify({
        command: action,
        files,
        from_fs,
        to_fs
      }),
      headers: { "X-CSRF-Token": csrfToken() }
    }).then((response) => this.dataFromJsonResponse(response)).then((data) => {
      if (!data.completed) {
        this.reportTransfer(data);
        this.findAndUpdateTransferStatus(data);
      } else {
      }
      if (action == "mv" || action == "cp") {
        this.reloadTable();
        this.clearClipboard();
        this.updateClipboard();
      }
      this.fadeOutTransferStatus(data);
      this.doneLoading();
      this.reloadTable();
    }).then(() => this.doneLoading()).catch((e2) => this.alertError("Error occurred when attempting to " + summary, e2.message));
  }
  findAndUpdateTransferStatus(data) {
    let id = `#${data.id}`;
    if ($(id).length) {
      $(id).replaceWith(this.reportTransferTemplate(data));
    } else {
      $(".transfers-status").append(this.reportTransferTemplate(data));
    }
  }
  fadeOutTransferStatus(data) {
    let id = `#${data.id}`;
    $(id).fadeOut(4e3);
  }
  reportTransferTemplate = function() {
    let template_str = $("#transfer-template").html();
    return import_handlebars2.default.compile(template_str);
  }();
  poll(data) {
    let that = this;
    $.getJSON(data.show_json_url, function(newdata) {
      that.findAndUpdateTransferStatus(newdata);
      if (newdata.completed) {
        if (!newdata.error_message) {
          if (newdata.target_dir == history.state.currentDirectory) {
            that.reloadTable();
          }
          that.fadeOutTransferStatus(newdata);
        }
      } else {
        setTimeout(function() {
          that.poll(data);
        }, that._timeout);
      }
    }).fail(function() {
      if (that._failures >= 3) {
        that.alertError("Operation may not have happened", "Failed to retrieve file operation status.");
      } else {
        setTimeout(function() {
          that._failures++;
          that.poll(data);
        }, that._timeout);
      }
    });
  }
  reportTransfer(data) {
    this.findAndUpdateTransferStatus(data);
    this.poll(data);
  }
  move(files, token, from_fs, to_fs) {
    this.transferFiles(files, "mv", "move files", from_fs, to_fs);
  }
  copy(files, token, from_fs, to_fs) {
    this.transferFiles(files, "cp", "copy files", from_fs, to_fs);
  }
  alertError(title, message) {
    const eventData = {
      "title": title,
      "message": message
    };
    $(CONTENTID).trigger(EVENTNAME2.showError, eventData);
  }
  doneLoading() {
    $(CONTENTID).trigger(EVENTNAME2.closeSwal);
  }
  clearClipboard() {
    $(CONTENTID).trigger(EVENTNAME3.clearClipboard);
  }
  reloadTable(url2) {
    const eventData = {
      "url": url2
    };
    $(CONTENTID).trigger(EVENTNAME.reloadTable, eventData);
  }
  showSwalLoading(message) {
    const eventData = {
      "message": message
    };
    $(CONTENTID).trigger(EVENTNAME2.showLoading, eventData);
  }
  updateClipboard() {
    $(CONTENTID).trigger(EVENTNAME3.updateClipboardView);
  }
};

// app/javascript/files/clip_board.js
var EVENTNAME3 = {
  clearClipboard: "clearClipboard",
  updateClipboard: "updateClipboard",
  updateClipboardView: "updateClipboardView"
};
jQuery(function() {
  var clipBoard = new ClipBoard();
  $("#copy-move-btn").on("click", function() {
    let table2 = $(CONTENTID).DataTable();
    let selection = table2.rows({ selected: true }).data();
    const eventData = {
      selection
    };
    $(CONTENTID).trigger(EVENTNAME3.updateClipboard, eventData);
  });
  $(CONTENTID).on("success", function(e2) {
    $(e2.trigger).tooltip({ title: "Copied path to clipboard!", trigger: "manual", placement: "bottom" }).tooltip("show");
    setTimeout(() => $(e2.trigger).tooltip("hide"), 2e3);
    e2.clearSelection();
  });
  $(CONTENTID).on("error", function(e2) {
    e2.clearSelection();
  });
  $(CONTENTID).on(EVENTNAME3.clearClipboard, function(e2, options) {
    clipBoard.clearClipboard();
    clipBoard.updateViewForClipboard();
  });
  $(CONTENTID).on(EVENTNAME3.updateClipboard, function(e2, options) {
    if (options.selection.length == 0) {
      const eventData = {
        "title": "Select a file, files, or directory to copy or move.",
        "message": "You have selected none."
      };
      $(CONTENTID).trigger(EVENTNAME2.showError, eventData);
      $(CONTENTID).trigger(EVENTNAME3.clearClipboard, eventData);
    } else {
      clipBoard.updateClipboardFromSelection(options.selection);
      clipBoard.updateViewForClipboard();
    }
  });
  $(CONTENTID).on(EVENTNAME3.updateClipboardView, function(e2, options) {
    clipBoard.updateViewForClipboard();
  });
});
var ClipBoard = class {
  _clipBoard = null;
  constructor() {
    this._clipBoard = new import_clipboard.default("#copy-path");
    this.updateViewForClipboard();
  }
  getClipBoard() {
    return this._clipBoard;
  }
  clearClipboard() {
    localStorage.removeItem("filesClipboard");
  }
  updateClipboardFromSelection(selection) {
    if (selection.length == 0) {
      this.clearClipboard();
    } else {
      let clipboardData = {
        from: history.state.currentDirectory,
        from_fs: history.state.currentFilesystem,
        files: selection.toArray().map((f2) => {
          return { directory: f2.type == "d", name: f2.name };
        })
      };
      localStorage.setItem("filesClipboard", JSON.stringify(clipboardData));
    }
  }
  updateViewForClipboard() {
    let clipboard = JSON.parse(localStorage.getItem("filesClipboard") || "{}"), template_str = $("#clipboard-template").html(), template = import_handlebars3.default.compile(template_str);
    $("#clipboard").html(template(clipboard));
    $("#clipboard-clear").on("click", () => {
      this.clearClipboard();
      this.updateViewForClipboard();
    });
    $("#clipboard-move-to-dir").on("click", () => {
      let clipboard2 = JSON.parse(localStorage.getItem("filesClipboard") || "null");
      if (clipboard2) {
        clipboard2.to = history.state.currentDirectory;
        clipboard2.to_fs = history.state.currentFilesystem;
        if (clipboard2.from == clipboard2.to) {
          this.clearClipboard();
          this.updateViewForClipboard();
        } else {
          let files = {};
          clipboard2.files.forEach((f2) => {
            files[`${clipboard2.from}/${f2.name}`] = `${history.state.currentDirectory}/${f2.name}`;
          });
          const eventData = {
            "files": files,
            "token": csrfToken(),
            "from_fs": clipboard2.from_fs,
            "to_fs": clipboard2.to_fs
          };
          $(CONTENTID).trigger(EVENTNAME4.moveFile, eventData);
        }
      } else {
        console.error("files clipboard is empty");
      }
    });
    $("#clipboard-copy-to-dir").on("click", () => {
      let clipboard2 = JSON.parse(localStorage.getItem("filesClipboard") || "null");
      if (clipboard2) {
        clipboard2.to = history.state.currentDirectory;
        clipboard2.to_fs = history.state.currentFilesystem;
        let files = {};
        clipboard2.files.forEach((f2) => {
          files[`${clipboard2.from}/${f2.name}`] = `${clipboard2.to}/${f2.name}`;
        });
        const eventData = {
          "files": files,
          "token": csrfToken(),
          "from_fs": clipboard2.from_fs,
          "to_fs": clipboard2.to_fs
        };
        $(CONTENTID).trigger(EVENTNAME4.copyFile, eventData);
      } else {
        console.error("files clipboard is empty");
      }
    });
  }
};

// app/javascript/files/uppy_ops.js
var import_core = __toESM(require_lib2());
var import_dashboard = __toESM(require_lib6());
var import_xhr_upload = __toESM(require_lib8());
var import_lodash2 = __toESM(require_lodash());
var uppy = null;
jQuery(function() {
  class EmptyDirCreator extends import_core.BasePlugin {
    constructor(uppy2, opts) {
      super(uppy2, opts);
      this.id = this.opts.id || "EmptyDirUploaderCatcher";
      this.type = "acquirer";
      this.empty_dirs = [];
      this.last_entries = [];
      this.handleRootDrop = this.handleRootDrop.bind(this);
      this.createEmptyDirs = this.createEmptyDirs.bind(this);
      this.uppy = uppy2;
    }
    handleRootDrop(e2) {
      if (e2.dataTransfer.items && e2.dataTransfer.items[0] && "webkitGetAsEntry" in e2.dataTransfer.items[0]) {
        let items = Array.prototype.slice.call(e2.dataTransfer.items || [], 0);
        let entries = items.map((i2) => i2.webkitGetAsEntry()).filter((i2) => i2);
        return Promise.all(entries.map((i2) => getEmptyDirs(i2))).then((dirs) => {
          this.empty_dirs = this.empty_dirs.concat(import_lodash2.default.flattenDeep(dirs));
        });
      }
    }
    createEmptyDirs(ids) {
      if (!this.uppy.getState().error) {
        return Promise.all(this.empty_dirs.map((d2) => {
          let filename = import_lodash2.default.trimStart(d2.fullPath, "/");
          return fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?dir=true`, { method: "put", headers: { "X-CSRF-Token": csrfToken() } });
        })).then(() => this.empty_dirs = []);
      }
    }
    install() {
      this.uppy.addPostProcessor(this.createEmptyDirs);
    }
    uninstall() {
      this.uppy.removePostProcessor(this.createEmptyDirs);
    }
  }
  uppy = new import_core.Uppy({
    restrictions: {
      maxFileSize: maxFileSize()
    },
    onBeforeUpload: updateEndpoint,
    locale: uppyLocale()
  });
  uppy.use(EmptyDirCreator);
  uppy.use(import_dashboard.default, {
    trigger: "#upload-btn",
    fileManagerSelectionType: "both",
    disableThumbnailGenerator: true,
    showLinkToFileUploadResult: false,
    closeModalOnClickOutside: true,
    closeAfterFinish: true,
    allowMultipleUploads: false,
    onRequestCloseModal: () => closeAndResetUppyModal(uppy),
    note: "Empty directories will be included in the upload only when a directory upload is initiated via drag and drop. This is because the File and Directory Entries API is available only on a drop event, not during an input change event."
  });
  uppy.use(import_xhr_upload.default, {
    withCredentials: true,
    fieldName: "file",
    limit: 1,
    headers: { "X-CSRF-Token": csrfToken() },
    timeout: 128 * 1e3
  });
  uppy.on("file-added", (file) => {
    uppy.setFileMeta(file.id, { parent: history.state.currentDirectory });
    if (file.meta.relativePath == null && file.data.webkitRelativePath) {
      uppy.setFileMeta(file.id, { relativePath: file.data.webkitRelativePath });
    }
  });
  uppy.on("complete", (result) => {
    if (result.successful.length > 0) {
      reloadTable();
    }
  });
  window.addEventListener("dragover", function(e2) {
    e2 = e2 || event;
    e2.preventDefault();
  }, false);
  window.addEventListener("drop", function(e2) {
    e2 = e2 || event;
    e2.preventDefault();
  }, false);
  $("#directory-contents").on("drop", function(e2) {
    this.classList.remove("dragover");
    uppy.getPlugin("Dashboard").openModal().then(() => uppy.getPlugin("Dashboard").handleDrop(e2.originalEvent));
  });
  $("#directory-contents").on("dragover", function(e2) {
    this.classList.add("dragover");
    e2.preventDefault();
    e2.originalEvent.dataTransfer.dropEffect = "copy";
  });
  $("#directory-contents").on("dragleave", function(e2) {
    this.classList.remove("dragover");
  });
});
function closeAndResetUppyModal(uppy2) {
  uppy2.getPlugin("Dashboard").closeModal();
  uppy2.reset();
}
function getEmptyDirs(entry) {
  return new Promise((resolve) => {
    if (entry.isFile) {
      resolve([]);
    } else {
      getFilesAndDirectoriesFromDirectory(entry.createReader(), [], function(error) {
        console.error(error);
      }, {
        onSuccess: (entries) => {
          if (entries.length == 0) {
            resolve([entry]);
          } else {
            Promise.all(entries.map((e2) => getEmptyDirs(e2))).then((dirs) => resolve(import_lodash2.default.flattenDeep(dirs)));
          }
        }
      });
    }
  });
}
function updateEndpoint() {
  uppy.getPlugin("XHRUpload").setOptions({
    endpoint: history.state.currentFilesUploadPath
  });
}
function reloadTable() {
  $(CONTENTID).trigger(EVENTNAME.reloadTable, {});
}
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
/*!
* sweetalert2 v10.16.9
* Released under the MIT License.
*/
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */
//# sourceMappingURL=/pun/sys/ood/assets/files/index.js-7f027c68807af0db31466bcb707534a6272193819e885c835ec34a6fd0365ff6.map
//!
;
