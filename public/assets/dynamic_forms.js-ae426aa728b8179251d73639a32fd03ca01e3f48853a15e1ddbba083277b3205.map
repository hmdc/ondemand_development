{
  "version": 3,
  "sources": ["../../javascript/dynamic_forms.js"],
  "sourcesContent": ["'use strict';\n\n// these are initialized in makeChangeHandlers\nvar idPrefix = undefined;\nvar shortNameRex = undefined;\n\n// @example ['NodeType', 'Cluster']\nconst formTokens = [];\n\n// simple lookup table to indicate that the change handler is setup between two\n// elements. I.e., {'cluster': [ 'node_type' ] } means that changes to cluster\n// trigger changes to node_type\nconst optionForHandlerCache = {};\n\n\n// simples array of string ids for elements that have a handler\nconst minMaxHandlerCache = [];\nconst setHandlerCache = [];\n// hide handler cache is a map in the form '{ from: [hideThing1, hideThing2] }'\nconst hideHandlerCache = {};\nconst labelHandlerCache = {};\n\n// Lookup tables for setting min & max values\n// for different directives.\nconst minMaxLookup = {};\nconst setValueLookup = {};\nconst hideLookup = {};\nconst labelLookup = {};\n\n// the regular expression for mountain casing\nconst mcRex = /[-_]([a-z])|([_-][0-9])|([\\/])/g;\n\n// whether we're still initializing or not\nlet initializing = true;\n\nfunction idWithPrefix(name) {\n  return `${idPrefix}_${name.toLowerCase()}`;\n};\n\n// here the simple name for 'batch_connect_session_context_cluster'\n// is just 'cluster'.\nfunction shortId(elementId) {\n  const match = elementId.match(shortNameRex);\n\n  if (match.length >= 1) {\n    return match[1];\n  } else {\n    return '';\n  };\n};\n\n/**\n * Mountain case the words from a string, by tokenizing on [-_].  In the\n * simplest case it just capitalizes.\n *\n * There is a special case where seperators are followed numbers. In this case\n * The seperator is kept as a hyphen because that's how jQuery expects it.\n *\n * @param      {string}  str     The word string to mountain case\n *\n * @example  given 'foo' this returns 'Foo'\n * @example  given 'foo-bar' this returns 'FooBar'\n * @example  given 'physics_1234' this returns 'Physics-1234'\n */\n// Convert dashed to camelCase\nfunction mountainCaseWords(str) {\n  const lower = str.toLowerCase();\n  const first = lower.charAt(0).toUpperCase();\n  const rest = lower.slice(1).replace(mcRex, function(_all, letter, prefixedNumber, slash) {\n    if(letter){\n      return letter.toUpperCase();\n    }else if(prefixedNumber){\n      return prefixedNumber.replace('_','-');\n    }else if(slash){\n      return '_';\n    }\n  });\n\n  return  `${first}${rest}`;\n}\n\n/**\n * Format passed string to snake_case. All characters become lowercase. Existing\n * underscores are unchanged and dashes become underscores. Underscores are added \n * before locations where an uppercase character is followed by a lowercase character.\n *\n * @param      {string}  str     The word string to snake case\n *\n * @example  given 'MountainCase' this returns 'mountain_case'\n * @example  given 'camelCase' this returns 'camel_case'\n * @example  given 'OSC_JUPYTER' this returns 'osc_jupyter'\n */\nfunction snakeCaseWords(str) {\n  if(str === undefined) return undefined;\n\n  let snakeCase = \"\";\n\n  str.split('').forEach((c, index) => {\n    if(c === '-' || c === '_') {\n      snakeCase += '_';\n    } else if (index == 0) {\n      snakeCase += c.toLowerCase();\n    } else if(c == c.toUpperCase() && isNaN(c)) {\n      const nextIsUpper = (index + 1 !== str.length) ? str[index + 1] === str[index + 1].toUpperCase() : true;\n      const nextIsNum = !isNaN(str[index + 1]);\n      if ((str[index-1] === '_' || nextIsUpper) && !nextIsNum) {\n        snakeCase += c.toLowerCase();\n      } else {\n        snakeCase += `_${c.toLowerCase()}`;\n      }\n    } else {\n      snakeCase += c;\n    }\n  });\n\n  return snakeCase;\n}\n\n/**\n *\n * @param {Array} elements\n */\nfunction memorizeElements(elements) {\n  elements.each((_i, ele) => {\n    formTokens.push(mountainCaseWords(shortId(ele['id'])));\n    optionForHandlerCache[ele['id']] = [];\n  });\n};\n\nfunction makeChangeHandlers(prefix){\n\n  // initialize some global variables.\n  idPrefix = prefix;\n  shortNameRex = new RegExp(`${idPrefix}_([\\\\w\\\\-]+)`);\n\n  const allElements = $(`[id^=${idPrefix}]`);\n  memorizeElements(allElements);\n\n  allElements.each((_i, element) => {\n    if (element['type'] == \"select-one\"){\n      let optionSearch = `#${element['id']} option`;\n      let options = $(optionSearch);\n      options.each((_i, opt) => {\n          // the variable 'opt' is just a data structure, not a jQuery result. \n          // it has no attr, data, show or hide methods so we have to query\n          // for it again\n          let data = $(`${optionSearch}[value='${opt.value}']`).data();\n          let keys = Object.keys(data);\n          if(keys.length !== 0) {\n            keys.forEach((key) => {\n              if(key.startsWith('optionFor')) {\n                let token = key.replace(/^optionFor/,'');\n                addOptionForHandler(idFromToken(token), element['id']);\n              } else if(key.startsWith('max') || key.startsWith('min')) {\n                addMinMaxForHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('set')) {\n                addSetHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('hide')) {\n                addHideHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('label')) {\n                addLabelHandler(element['id'], opt.value, key, data[key]);\n              }\n            });\n          }\n      });\n    } else if(element['type'] == \"checkbox\") {\n      let data = $(element).data();\n      let keys = Object.keys(data);\n      if(keys.length !== 0) {\n        keys.forEach((key) => {\n          if(key.startsWith('hide')) {\n            let tokens = parseCheckedWhen(key);\n            if(tokens !== undefined){\n              addHideHandler(element['id'], tokens['value'], tokens['key'], data[key]);\n            }\n          }\n        });\n      }\n    }\n  });\n\n  initializing = false;\n};\n\nfunction addHideHandler(optionId, option, key, configValue) {\n  const changeId = idFromToken(key.replace(/^hide/,''));\n\n  if(hideLookup[optionId] === undefined) hideLookup[optionId] = new Table(changeId, undefined);\n  const table = hideLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(hideHandlerCache[optionId] === undefined) hideHandlerCache[optionId] = [];\n\n  if(!hideHandlerCache[optionId].includes(changeId)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      updateVisibility(event, changeId);\n    });\n\n    hideHandlerCache[optionId].push(changeId);\n  }\n\n  updateVisibility({ target: document.querySelector(`#${optionId}`) }, changeId);\n};\n\nfunction newLabel(changeElement, key) {\n  const selectedOptionLabelIndex = changeElement[0].selectedIndex;\n  const selectedOptionLabel = changeElement[0].options[selectedOptionLabelIndex];\n  return selectedOptionLabel.dataset[key];\n};\n\nfunction updateLabel(changeId, changeElement, key) {\n  $(`label[for=\"${changeId}\"]`)[0].innerHTML = newLabel(changeElement, key);\n}\n\nfunction addLabelHandler(optionId, option, key, configValue) {\n  const changeId = idFromToken(key.replace(/^label/, ''));\n  const changeElement = $(`#${optionId}`);\n\n  if(labelLookup[optionId] === undefined) labelLookup[optionId] = new Table(changeId, undefined);\n  const table = labelLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(labelHandlerCache[optionId] === undefined) labelHandlerCache[optionId] = [];\n\n  if(!labelHandlerCache[optionId].includes(changeId)) {\n    changeElement.on('change', (event) => {\n      updateLabel(changeId, changeElement, key);\n    });\n  };\n\n  updateLabel(changeId, changeElement, key);\n};\n\n/**\n *\n * @param {*} subjectId batch_connect_session_context_node_type\n * @param {*} option gpu\n * @param {*} key maxNumCoresForClusterAnnieOakley\n * @param {*} configValue 42\n *\n * node_type:\n *   widget: select\n *   options:\n *    - [\n *        'gpu',\n *        data-max-num-cores-for-cluster-annie-oakley: 42\n *      ]\n */\nfunction addMinMaxForHandler(subjectId, option, key,  configValue) {\n  subjectId = String(subjectId || '');\n  configValue = parseInt(configValue);\n\n  const configObj = parseMinMaxFor(key);\n  const objectId = configObj['subjectId'];\n  // this is the id of the target object we're setting the min/max for.\n  // if it's undefined - there's nothing to do, it was likely configured wrong.\n  if(objectId === undefined) return;\n\n  const secondDimId = configObj['predicateId'];\n  const secondDimValue = configObj['predicateValue'];\n\n  // several subjects can try to change the object, so the table lookup key has to have both\n  const lookupKey = `${subjectId}_${objectId}`;\n  if(minMaxLookup[lookupKey] === undefined) minMaxLookup[lookupKey] = new Table(subjectId, secondDimId);\n  const table = minMaxLookup[lookupKey];\n  table.put(option, secondDimValue, {[minOrMax(key)] : configValue });\n\n  let cacheKey = `${objectId}_${subjectId}_${secondDimId}`;\n  if(!minMaxHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${subjectId}`);\n\n    changeElement.on('change', (event) => {\n      toggleMinMax(event, objectId, secondDimId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  cacheKey = `${objectId}_${secondDimId}_${subjectId}`;\n  if(secondDimId !== undefined && !minMaxHandlerCache.includes(cacheKey)){\n    const secondEle = $(`#${secondDimId}`);\n\n    secondEle.on('change', (event) => {\n      toggleMinMax(event, objectId, subjectId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  toggleMinMax({ target: document.querySelector(`#${subjectId}`) }, objectId, secondDimId);\n}\n\n/**\n *\n * @param {*} optionId batch_connect_session_context_classroom\n * @param {*} option 'PHY_9000'\n * @param {*} key setAccount\n * @param {*} configValue 'phy3005'\n *\n * classroom:\n *   widget: select\n *   options:\n *    - [\n *        'Physics Maximum', 'PHY_9000',\n *        data-set-account: 'phy3005'\n *      ]\n */\nfunction addSetHandler(optionId, option, key, configValue) {\n  const k = key.replace(/^set/,'');\n  const id = String(idFromToken(k));\n  if(id === 'undefined') return;\n\n  // id is account. optionId is classroom\n  let cacheKey = `${id}_${optionId}`\n  if(setValueLookup[cacheKey] === undefined) setValueLookup[cacheKey] = new Table(optionId, undefined);\n  const table = setValueLookup[cacheKey];\n  table.put(option, undefined, configValue);\n\n  if(!setHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      setValue(event, id);\n    });\n\n    setHandlerCache.push(cacheKey);\n  }\n\n  setValue({ target: document.querySelector(`#${optionId}`) }, id);\n}\n\nfunction setValue(event, changeId) {\n  const chosenVal = event.target.value;\n  const cacheKey = `${changeId}_${event.target['id']}`\n  const table = setValueLookup[cacheKey];\n  if (table === undefined) return;\n\n  const changeVal = table.get(chosenVal, undefined);\n\n  if(changeVal !== undefined) {\n    const element = document.getElementById(changeId);\n    if(element['type'] == 'checkbox') {\n      setCheckboxValue(element, changeVal);\n    } else {\n      element.value = changeVal;\n    }\n  }\n}\n\nfunction setCheckboxValue(checkbox, value) {\n  const positiveValue = checkbox.value;\n  if(value == positiveValue) {\n    checkbox.checked = true;\n  } else {\n    checkbox.checked = false;\n  }\n}\n\n/**\n *\n *  This is a simple table class to describe the relationship between\n *  two different element types as a table with named columns.\n *\n *  table.get('gpu','owens') would return the value shown.\n *\n *      'oakley'   |                    |                |\n *      'owens'    | { min: 3, max: 42} |                |\n *                 |  'gpu'             |   'hugemem'    |\n *\n * In the simple case, it's a 1d vector instead of a 2d matrix. This\n * allows for, say, gpu to have the same min & max across clusters.\n */\nclass Table {\n  constructor(x, y) {\n    // FIXME: probably need to make Vector class? Wouldn't want to add a flag to the constructor.\n    // we don't use x or y internally, though x is used externally.\n    this.x = x;\n    this.xIdxLookup = {};\n\n    this.y = y;\n    this.yIdxLookup = {};\n    this.table = y === undefined ? [] : [[]];\n  }\n\n  put(x, y, value) {\n    if(!x) return;\n    x = snakeCaseWords(x);\n    y = snakeCaseWords(y);\n\n    if(this.xIdxLookup[x] === undefined) this.xIdxLookup[x] = Object.keys(this.xIdxLookup).length;\n    if(y && this.yIdxLookup[y] === undefined) this.yIdxLookup[y] = Object.keys(this.yIdxLookup).length;\n\n    const xIdx = this.xIdxLookup[x];\n    const yIdx = this.yIdxLookup[y];\n\n    if(this.table[xIdx] === undefined ){\n      this.table[xIdx] = y === undefined ? undefined : [];\n    }\n\n    // if y's index is defined, then it's a 2d matrix. Otherwise a 1d vector.\n    if(yIdx === undefined) {\n      if(this.table[xIdx] === undefined){\n        this.table[xIdx] = value;\n      } else {\n        const prev = this.table[xIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx] = newer;\n        } else {\n          this.table[xIdx] = Object.assign(prev, newer);\n        }\n      }\n    } else {\n      if(this.table[xIdx][yIdx] === undefined){\n        this.table[xIdx][yIdx] = value;\n      } else {\n        const prev = this.table[xIdx][yIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx][yIdx] = newer;\n        } else {\n          this.table[xIdx][yIdx] = Object.assign(prev, newer);\n        }\n      }\n    }\n  }\n\n  get(x, y) {\n    const xIdx = this.xIdxLookup[snakeCaseWords(x)];\n    const yIdx = this.yIdxLookup[snakeCaseWords(y)];\n\n    if(this.table[xIdx] === undefined){\n      return undefined;\n    }else if(y === undefined){\n      return this.table[xIdx];\n    }else {\n      return this.table[xIdx][yIdx];\n    }\n  }\n}\n\n/**\n * Update the visibility of `changeId` based on the\n * event and what's in the hideLookup table.\n */\nfunction updateVisibility(event, changeId) {\n  const val = valueFromEvent(event);\n  const id = event.target['id'];\n  let changeElement = undefined;\n  \n  $(`#${changeId}`).parents().each(function(_i, parent) {\n    var classListValues = parent.classList.values();\n    for (const val of classListValues) {\n      // TODO: Using 'mb-3' here because 'form-group' was removed\n      // from Bootstrap 5 and replaced with 'mb-3' - however, this\n      // is a grid class which could (??) apply to parent elements\n      // in unpredictable parts of the chain - test for & resolve\n      if (val.match('mb-3')) {\n        changeElement = $(parent);\n      }\n    }\n  });\n\n  if (changeElement === undefined || changeElement.length <= 0) return;\n\n  // safe to access directly?\n  const hide = hideLookup[id].get(changeId, val);\n  if((hide === false) || (hide === undefined && !initializing)) {\n    changeElement.show();\n  }else if(hide === true) {\n    changeElement.hide();\n  }\n}\n\n// extract the value from the event. With checkbox being\n// handleded specially.\nfunction valueFromEvent(event) {\n  if(event.target['type'] == 'checkbox') {\n    return event.target.checked ? 'checked' : 'unchecked';\n  } else {\n    return event.target.value;\n  }\n}\n/**\n * Update the min & max values of `changeId` based on the\n * event, the `otherId` and the settings in minMaxLookup table.\n */\nfunction toggleMinMax(event, changeId, otherId) {\n  let x = undefined, y = undefined;\n\n  // many subjects can change the object, so we have to find the correct table\n  // in the form <subject>_<object>\n  let lookupKey = `${event.target['id']}_${changeId}`;\n  if(minMaxLookup[lookupKey] === undefined) {\n    lookupKey = `${otherId}_${changeId}`;\n  }\n\n  const table = minMaxLookup[lookupKey];\n\n  // in the example of cluster & node_type, either element can trigger a change\n  // so let's figure out the axis' based on the change element's id.\n  if(event.target['id'] == table.x) {\n    x = snakeCaseWords(event.target.value);\n    y = snakeCaseWords($(`#${otherId}`).val());\n  } else {\n    y = snakeCaseWords(event.target.value);\n    x = snakeCaseWords($(`#${otherId}`).val());\n  }\n\n  const changeElement = $(`#${changeId}`);\n  const mm = table.get(x, y);\n  const prev = {\n    min: parseInt(changeElement.attr('min')),\n    max: parseInt(changeElement.attr('max')),\n  };\n\n  [ 'max', 'min' ].forEach((dim) => {\n    if(mm && mm[dim] !== undefined) {\n      changeElement.attr(dim, mm[dim]);\n    }\n  });\n\n  const val = clamp(parseInt(changeElement.val()), prev, mm)\n  if (val !== undefined) {\n    changeElement.attr('value', val);\n    changeElement.val(val);\n  }\n}\n\nfunction clamp(currentValue, previous, next) {\n  if(next === undefined){\n    return undefined;\n\n  // you've set the boundary, so when you go to the next value - keep it at the next's boundary\n  } else if(currentValue === previous['min']) {\n    return next['min'];\n  } else if(currentValue === previous['max']) {\n    return next['max'];\n\n  // otherwise you could be up or down shifting to fit within the next's boundaries\n  } else if(currentValue <= next['min']) {\n    return next['min'];\n  } else if(currentValue >= next['max']) {\n    return next['max'];\n  } else {\n    return undefined;\n  }\n}\n\nfunction addOptionForHandler(causeId, targetId) {\n  const changeId = String(causeId || '');\n\n  if(changeId.length == 0 || optionForHandlerCache[causeId].includes(targetId)) {\n    // nothing to do. invalid causeId or we already have a handler between the 2\n    return;\n  }\n\n  let causeElement = $(`#${causeId}`);\n\n  if(targetId && causeElement) {\n    // cache the fact that there's a new handler here\n    optionForHandlerCache[causeId].push(targetId);\n\n    causeElement.on('change', (event) => {\n      toggleOptionsFor(event, targetId);\n    });\n\n    // fake an event to initialize\n    toggleOptionsFor({ target: document.querySelector(`#${causeId}`) }, targetId);\n  }\n};\n\nfunction parseCheckedWhen(key) {\n  const tokens = key.match(/^hide(\\w+)When(\\w+)$/);\n\n  if(tokens !== undefined && tokens.length && tokens.length == 3) {\n    return {\n      'key': tokens[1],\n      'value': tokens[2].toLowerCase() == 'checked' ? 'checked' : 'unchecked'\n    };\n  } else {\n    return undefined;\n  }\n}\n\n/**\n *\n * @param {*} key minNumCoresForClusterAnnieOakley\n * @returns\n *\n *  {\n *    'subjectId': 'batch_connect_session_context_num_cores',\n *    'predicateId': 'batch_connect_session_context_cluster',\n *    'predicateValue': 'annie_oakley'\n *  }\n */\nfunction parseMinMaxFor(key) {\n  let k = undefined;\n  let predicateId = undefined;\n  let predicateValue = undefined;\n  let subjectId = undefined;\n\n  if(key.startsWith('min')) {\n    k = key.replace(/^min/,'');\n  } else if(key.startsWith('max')) {\n    k = key.replace(/^max/, '')\n  }\n\n  //trying to parse maxNumCoresForClusterOwens\n  const tokens = k.match(/^(\\w+)For(\\w+)$/);\n\n  if(tokens == null) {\n    // the key is likely just maxNumCores with no For clause\n    subjectId = idFromToken(k);\n\n  } else if(tokens.length == 3) {\n    const subject = tokens[1];\n    const predicateFull = tokens[2];\n    subjectId = idFromToken(subject);\n\n    const predicateTokens = predicateFull.split(/(?=[A-Z])/);\n    if(predicateTokens && predicateTokens.length >= 2) {\n\n      // if there are only 2 tokens then it's like 'ClusterOwens' which is easy\n      if(predicateTokens.length == 2) {\n        predicateId = idFromToken(predicateTokens[0]);\n        predicateValue = predicateTokens[1];\n\n      // else it's like NodeTypeFooBar, so it's a little more difficult\n      } else {\n        let tokenString = '';\n        let done = false;\n        predicateTokens.forEach((pt, idx) => {\n          if(done) { return; }\n\n          tokenString = `${tokenString}${pt}`\n          let tokenId = idFromToken(tokenString);\n          if(tokenId !== undefined) {\n            done = true;\n            predicateId = tokenId;\n            predicateValue = predicateTokens.slice(idx+1).join('');\n          }\n        })\n      }\n    }\n  }\n\n  return {\n    'subjectId': subjectId,\n    'predicateId': predicateId,\n    'predicateValue': snakeCaseWords(predicateValue),\n  }\n}\n\nfunction minOrMax(key) {\n  if(key.startsWith('min')){\n    return 'min';\n  } else if(key.startsWith('max')){\n    return 'max';\n  } else {\n    return null;\n  }\n}\n\n/**\n * Turn a MountainCase token into a form element id\n *\n * @example\n *  NodeType -> batch_connect_session_context_node_type\n *\n * @param {*} str\n * @returns\n */\nfunction idFromToken(str) {\n  elements = formTokens.map((token) => {\n    let match = str.match(`^${token}{1}`);\n\n    if (match && match.length >= 1) {\n      let ele = snakeCaseWords(match[0]);\n      return idWithPrefix(ele);\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  });\n\n  if(elements.length == 0) {\n    return undefined;\n  }else if(elements.length == 1) {\n    return elements[0];\n\n  // you matched multiple things. For example you're searching for\n  // ClusterFilesystem and matched against both 'Cluster' and 'ClusterFilesystem'.\n  // The correrct element id ends with cluster_filesystem.\n  } else if(elements.length > 1) {\n    const snake_case_str = snakeCaseWords(str);\n    return elements.filter((element) => {\n      return element.endsWith(snake_case_str);\n    })[0];\n  }\n}\n\n\n/**\n * Extract the option for out of an option for directive.\n *\n * @example\n *  optionForClusterOakley -> Cluster\n *\n * @param {*} str\n * @returns - the option for string\n */\nfunction optionForFromToken(str) {\n  return formTokens.map((token) => {\n    let match = str.match(`^optionFor${token}`);\n\n    if (match && match.length >= 1) {\n      return token;\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  })[0];\n}\n\n/**\n * Hide or show options of an element based on which cluster is\n * currently selected and the data-option-for-CLUSTER attributes\n * for each option\n *\n * @param      {string}  element_name  The name of the element with options to toggle\n */\n function toggleOptionsFor(_event, elementId) {\n  const options = [...document.querySelectorAll(`#${elementId} option`)];\n  let hideSelectedValue = undefined;\n\n  options.forEach(option => {\n    let hide = false;\n\n    // even though an event occured - an option may be hidden based on the value of\n    // something else entirely. We're going to hide this option if _any_ of the\n    // option-for- directives apply.\n    for (let key of Object.keys(option.dataset)) {\n      let optionFor = optionForFromToken(key);\n      let optionForId = idFromToken(key.replace(/^optionFor/,''));\n\n      // it's some other directive type, so just keep going and/or not real\n      if(!key.startsWith('optionFor') || optionForId === undefined) {\n        continue;\n      }\n\n      let optionForValue = mountainCaseWords(document.getElementById(optionForId).value);\n      // handle special case where the very first token here is a number.\n      // browsers expect a prefix of hyphens as if it's the next token.\n      if (optionForValue.match(/^\\d/)) {\n        optionForValue = `-${optionForValue}`;\n      }\n\n      hide = option.dataset[`optionFor${optionFor}${optionForValue}`] === 'false';\n      if (hide) {\n        break;\n      }\n    };\n\n    if(hide) {\n      if(option.selected) {\n        option.selected = false;\n        hideSelectedValue = option.textContent;\n      }\n\n      option.style.display = 'none';\n      option.disabled = true;\n    } else {\n      option.style.display = '';\n      option.disabled = false;\n    }\n  });\n\n  // now that we've hidden/shown everything, let's choose what should now\n  // be the current selected value.\n  // if you've hidden what _was_ selected.\n  if(hideSelectedValue !== undefined) {\n    let others = [...document.querySelectorAll(`#${elementId} option[value='${hideSelectedValue}']`)];\n    let newSelectedOption = undefined;\n\n    // You have hidden what _was_ selected, so try to find a duplicate option that is visible\n    if(others.length > 1) {\n      others.forEach(ele => {\n        if(ele.style.display === '') {\n          newSelectedOption = ele;\n          return;\n        }\n      });\n    }\n\n    // no duplciates are visible, so just pick the first visible option\n    if (newSelectedOption === undefined) {\n      others = document.querySelectorAll(`#${elementId} option`);\n      others.forEach(ele => {\n        if(newSelectedOption === undefined && ele.style.display === '') {\n          newSelectedOption = ele;\n        }\n      });\n    }\n\n    if (newSelectedOption !== undefined) {\n      newSelectedOption.selected = true;\n    }\n  }\n\n  // now that we're done, propogate this change to data-set or data-hide handlers\n  document.getElementById(elementId).dispatchEvent((new Event('change', { bubbles: true })));\n};\n\n\nexport {\n  makeChangeHandlers\n}\n"],
  "mappings": "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",
  "names": ["elements", "_i", "val"]
}
